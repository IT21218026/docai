"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/simple-git";
exports.ids = ["vendor-chunks/simple-git"];
exports.modules = {

/***/ "(rsc)/./node_modules/simple-git/dist/esm/index.js":
/*!***************************************************!*\
  !*** ./node_modules/simple-git/dist/esm/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CheckRepoActions: () => (/* binding */ CheckRepoActions),\n/* harmony export */   CleanOptions: () => (/* binding */ CleanOptions),\n/* harmony export */   DiffNameStatus: () => (/* binding */ DiffNameStatus),\n/* harmony export */   GitConfigScope: () => (/* binding */ GitConfigScope),\n/* harmony export */   GitConstructError: () => (/* binding */ GitConstructError),\n/* harmony export */   GitError: () => (/* binding */ GitError),\n/* harmony export */   GitPluginError: () => (/* binding */ GitPluginError),\n/* harmony export */   GitResponseError: () => (/* binding */ GitResponseError),\n/* harmony export */   ResetMode: () => (/* binding */ ResetMode),\n/* harmony export */   TaskConfigurationError: () => (/* binding */ TaskConfigurationError),\n/* harmony export */   \"default\": () => (/* binding */ esm_default),\n/* harmony export */   gitP: () => (/* binding */ gitP),\n/* harmony export */   grepQueryBuilder: () => (/* binding */ grepQueryBuilder),\n/* harmony export */   pathspec: () => (/* binding */ pathspec),\n/* harmony export */   simpleGit: () => (/* binding */ simpleGit)\n/* harmony export */ });\n/* harmony import */ var _kwsites_file_exists__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @kwsites/file-exists */ \"(rsc)/./node_modules/@kwsites/file-exists/dist/index.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var _kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @kwsites/promise-deferred */ \"(rsc)/./node_modules/@kwsites/promise-deferred/dist/index.js\");\n/* harmony import */ var node_events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node:events */ \"node:events\");\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/lib/args/pathspec.ts\nfunction pathspec(...paths) {\n  const key = new String(paths);\n  cache.set(key, paths);\n  return key;\n}\nfunction isPathSpec(path) {\n  return path instanceof String && cache.has(path);\n}\nfunction toPaths(pathSpec) {\n  return cache.get(pathSpec) || [];\n}\nvar cache;\nvar init_pathspec = __esm({\n  \"src/lib/args/pathspec.ts\"() {\n    \"use strict\";\n    cache = /* @__PURE__ */ new WeakMap();\n  }\n});\n\n// src/lib/errors/git-error.ts\nvar GitError;\nvar init_git_error = __esm({\n  \"src/lib/errors/git-error.ts\"() {\n    \"use strict\";\n    GitError = class extends Error {\n      constructor(task, message) {\n        super(message);\n        this.task = task;\n        Object.setPrototypeOf(this, new.target.prototype);\n      }\n    };\n  }\n});\n\n// src/lib/errors/git-response-error.ts\nvar GitResponseError;\nvar init_git_response_error = __esm({\n  \"src/lib/errors/git-response-error.ts\"() {\n    \"use strict\";\n    init_git_error();\n    GitResponseError = class extends GitError {\n      constructor(git, message) {\n        super(void 0, message || String(git));\n        this.git = git;\n      }\n    };\n  }\n});\n\n// src/lib/errors/task-configuration-error.ts\nvar TaskConfigurationError;\nvar init_task_configuration_error = __esm({\n  \"src/lib/errors/task-configuration-error.ts\"() {\n    \"use strict\";\n    init_git_error();\n    TaskConfigurationError = class extends GitError {\n      constructor(message) {\n        super(void 0, message);\n      }\n    };\n  }\n});\n\n// src/lib/utils/util.ts\n\nfunction asFunction(source) {\n  return typeof source === \"function\" ? source : NOOP;\n}\nfunction isUserFunction(source) {\n  return typeof source === \"function\" && source !== NOOP;\n}\nfunction splitOn(input, char) {\n  const index = input.indexOf(char);\n  if (index <= 0) {\n    return [input, \"\"];\n  }\n  return [input.substr(0, index), input.substr(index + 1)];\n}\nfunction first(input, offset = 0) {\n  return isArrayLike(input) && input.length > offset ? input[offset] : void 0;\n}\nfunction last(input, offset = 0) {\n  if (isArrayLike(input) && input.length > offset) {\n    return input[input.length - 1 - offset];\n  }\n}\nfunction isArrayLike(input) {\n  return !!(input && typeof input.length === \"number\");\n}\nfunction toLinesWithContent(input = \"\", trimmed2 = true, separator = \"\\n\") {\n  return input.split(separator).reduce((output, line) => {\n    const lineContent = trimmed2 ? line.trim() : line;\n    if (lineContent) {\n      output.push(lineContent);\n    }\n    return output;\n  }, []);\n}\nfunction forEachLineWithContent(input, callback) {\n  return toLinesWithContent(input, true).map((line) => callback(line));\n}\nfunction folderExists(path) {\n  return (0,_kwsites_file_exists__WEBPACK_IMPORTED_MODULE_0__.exists)(path, _kwsites_file_exists__WEBPACK_IMPORTED_MODULE_0__.FOLDER);\n}\nfunction append(target, item) {\n  if (Array.isArray(target)) {\n    if (!target.includes(item)) {\n      target.push(item);\n    }\n  } else {\n    target.add(item);\n  }\n  return item;\n}\nfunction including(target, item) {\n  if (Array.isArray(target) && !target.includes(item)) {\n    target.push(item);\n  }\n  return target;\n}\nfunction remove(target, item) {\n  if (Array.isArray(target)) {\n    const index = target.indexOf(item);\n    if (index >= 0) {\n      target.splice(index, 1);\n    }\n  } else {\n    target.delete(item);\n  }\n  return item;\n}\nfunction asArray(source) {\n  return Array.isArray(source) ? source : [source];\n}\nfunction asCamelCase(str) {\n  return str.replace(/[\\s-]+(.)/g, (_all, chr) => {\n    return chr.toUpperCase();\n  });\n}\nfunction asStringArray(source) {\n  return asArray(source).map(String);\n}\nfunction asNumber(source, onNaN = 0) {\n  if (source == null) {\n    return onNaN;\n  }\n  const num = parseInt(source, 10);\n  return isNaN(num) ? onNaN : num;\n}\nfunction prefixedArray(input, prefix) {\n  const output = [];\n  for (let i = 0, max = input.length; i < max; i++) {\n    output.push(prefix, input[i]);\n  }\n  return output;\n}\nfunction bufferToString(input) {\n  return (Array.isArray(input) ? Buffer.concat(input) : input).toString(\"utf-8\");\n}\nfunction pick(source, properties) {\n  return Object.assign(\n    {},\n    ...properties.map((property) => property in source ? { [property]: source[property] } : {})\n  );\n}\nfunction delay(duration = 0) {\n  return new Promise((done) => setTimeout(done, duration));\n}\nfunction orVoid(input) {\n  if (input === false) {\n    return void 0;\n  }\n  return input;\n}\nvar NULL, NOOP, objectToString;\nvar init_util = __esm({\n  \"src/lib/utils/util.ts\"() {\n    \"use strict\";\n    NULL = \"\\0\";\n    NOOP = () => {\n    };\n    objectToString = Object.prototype.toString.call.bind(Object.prototype.toString);\n  }\n});\n\n// src/lib/utils/argument-filters.ts\nfunction filterType(input, filter, def) {\n  if (filter(input)) {\n    return input;\n  }\n  return arguments.length > 2 ? def : void 0;\n}\nfunction filterPrimitives(input, omit) {\n  const type = isPathSpec(input) ? \"string\" : typeof input;\n  return /number|string|boolean/.test(type) && (!omit || !omit.includes(type));\n}\nfunction filterPlainObject(input) {\n  return !!input && objectToString(input) === \"[object Object]\";\n}\nfunction filterFunction(input) {\n  return typeof input === \"function\";\n}\nvar filterArray, filterString, filterStringArray, filterStringOrStringArray, filterHasLength;\nvar init_argument_filters = __esm({\n  \"src/lib/utils/argument-filters.ts\"() {\n    \"use strict\";\n    init_util();\n    init_pathspec();\n    filterArray = (input) => {\n      return Array.isArray(input);\n    };\n    filterString = (input) => {\n      return typeof input === \"string\";\n    };\n    filterStringArray = (input) => {\n      return Array.isArray(input) && input.every(filterString);\n    };\n    filterStringOrStringArray = (input) => {\n      return filterString(input) || Array.isArray(input) && input.every(filterString);\n    };\n    filterHasLength = (input) => {\n      if (input == null || \"number|boolean|function\".includes(typeof input)) {\n        return false;\n      }\n      return Array.isArray(input) || typeof input === \"string\" || typeof input.length === \"number\";\n    };\n  }\n});\n\n// src/lib/utils/exit-codes.ts\nvar ExitCodes;\nvar init_exit_codes = __esm({\n  \"src/lib/utils/exit-codes.ts\"() {\n    \"use strict\";\n    ExitCodes = /* @__PURE__ */ ((ExitCodes2) => {\n      ExitCodes2[ExitCodes2[\"SUCCESS\"] = 0] = \"SUCCESS\";\n      ExitCodes2[ExitCodes2[\"ERROR\"] = 1] = \"ERROR\";\n      ExitCodes2[ExitCodes2[\"NOT_FOUND\"] = -2] = \"NOT_FOUND\";\n      ExitCodes2[ExitCodes2[\"UNCLEAN\"] = 128] = \"UNCLEAN\";\n      return ExitCodes2;\n    })(ExitCodes || {});\n  }\n});\n\n// src/lib/utils/git-output-streams.ts\nvar GitOutputStreams;\nvar init_git_output_streams = __esm({\n  \"src/lib/utils/git-output-streams.ts\"() {\n    \"use strict\";\n    GitOutputStreams = class {\n      constructor(stdOut, stdErr) {\n        this.stdOut = stdOut;\n        this.stdErr = stdErr;\n      }\n      asStrings() {\n        return new GitOutputStreams(this.stdOut.toString(\"utf8\"), this.stdErr.toString(\"utf8\"));\n      }\n    };\n  }\n});\n\n// src/lib/utils/line-parser.ts\nvar LineParser, RemoteLineParser;\nvar init_line_parser = __esm({\n  \"src/lib/utils/line-parser.ts\"() {\n    \"use strict\";\n    LineParser = class {\n      constructor(regExp, useMatches) {\n        this.matches = [];\n        this.parse = (line, target) => {\n          this.resetMatches();\n          if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {\n            return false;\n          }\n          return this.useMatches(target, this.prepareMatches()) !== false;\n        };\n        this._regExp = Array.isArray(regExp) ? regExp : [regExp];\n        if (useMatches) {\n          this.useMatches = useMatches;\n        }\n      }\n      useMatches(target, match) {\n        throw new Error(`LineParser:useMatches not implemented`);\n      }\n      resetMatches() {\n        this.matches.length = 0;\n      }\n      prepareMatches() {\n        return this.matches;\n      }\n      addMatch(reg, index, line) {\n        const matched = line && reg.exec(line);\n        if (matched) {\n          this.pushMatch(index, matched);\n        }\n        return !!matched;\n      }\n      pushMatch(_index, matched) {\n        this.matches.push(...matched.slice(1));\n      }\n    };\n    RemoteLineParser = class extends LineParser {\n      addMatch(reg, index, line) {\n        return /^remote:\\s/.test(String(line)) && super.addMatch(reg, index, line);\n      }\n      pushMatch(index, matched) {\n        if (index > 0 || matched.length > 1) {\n          super.pushMatch(index, matched);\n        }\n      }\n    };\n  }\n});\n\n// src/lib/utils/simple-git-options.ts\nfunction createInstanceConfig(...options) {\n  const baseDir = process.cwd();\n  const config = Object.assign(\n    __spreadValues({ baseDir }, defaultOptions),\n    ...options.filter((o) => typeof o === \"object\" && o)\n  );\n  config.baseDir = config.baseDir || baseDir;\n  config.trimmed = config.trimmed === true;\n  return config;\n}\nvar defaultOptions;\nvar init_simple_git_options = __esm({\n  \"src/lib/utils/simple-git-options.ts\"() {\n    \"use strict\";\n    defaultOptions = {\n      binary: \"git\",\n      maxConcurrentProcesses: 5,\n      config: [],\n      trimmed: false\n    };\n  }\n});\n\n// src/lib/utils/task-options.ts\nfunction appendTaskOptions(options, commands = []) {\n  if (!filterPlainObject(options)) {\n    return commands;\n  }\n  return Object.keys(options).reduce((commands2, key) => {\n    const value = options[key];\n    if (isPathSpec(value)) {\n      commands2.push(value);\n    } else if (filterPrimitives(value, [\"boolean\"])) {\n      commands2.push(key + \"=\" + value);\n    } else {\n      commands2.push(key);\n    }\n    return commands2;\n  }, commands);\n}\nfunction getTrailingOptions(args, initialPrimitive = 0, objectOnly = false) {\n  const command = [];\n  for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) {\n    if (\"string|number\".includes(typeof args[i])) {\n      command.push(String(args[i]));\n    }\n  }\n  appendTaskOptions(trailingOptionsArgument(args), command);\n  if (!objectOnly) {\n    command.push(...trailingArrayArgument(args));\n  }\n  return command;\n}\nfunction trailingArrayArgument(args) {\n  const hasTrailingCallback = typeof last(args) === \"function\";\n  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterArray, []);\n}\nfunction trailingOptionsArgument(args) {\n  const hasTrailingCallback = filterFunction(last(args));\n  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterPlainObject);\n}\nfunction trailingFunctionArgument(args, includeNoop = true) {\n  const callback = asFunction(last(args));\n  return includeNoop || isUserFunction(callback) ? callback : void 0;\n}\nvar init_task_options = __esm({\n  \"src/lib/utils/task-options.ts\"() {\n    \"use strict\";\n    init_argument_filters();\n    init_util();\n    init_pathspec();\n  }\n});\n\n// src/lib/utils/task-parser.ts\nfunction callTaskParser(parser4, streams) {\n  return parser4(streams.stdOut, streams.stdErr);\n}\nfunction parseStringResponse(result, parsers12, texts, trim = true) {\n  asArray(texts).forEach((text) => {\n    for (let lines = toLinesWithContent(text, trim), i = 0, max = lines.length; i < max; i++) {\n      const line = (offset = 0) => {\n        if (i + offset >= max) {\n          return;\n        }\n        return lines[i + offset];\n      };\n      parsers12.some(({ parse }) => parse(line, result));\n    }\n  });\n  return result;\n}\nvar init_task_parser = __esm({\n  \"src/lib/utils/task-parser.ts\"() {\n    \"use strict\";\n    init_util();\n  }\n});\n\n// src/lib/utils/index.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  ExitCodes: () => ExitCodes,\n  GitOutputStreams: () => GitOutputStreams,\n  LineParser: () => LineParser,\n  NOOP: () => NOOP,\n  NULL: () => NULL,\n  RemoteLineParser: () => RemoteLineParser,\n  append: () => append,\n  appendTaskOptions: () => appendTaskOptions,\n  asArray: () => asArray,\n  asCamelCase: () => asCamelCase,\n  asFunction: () => asFunction,\n  asNumber: () => asNumber,\n  asStringArray: () => asStringArray,\n  bufferToString: () => bufferToString,\n  callTaskParser: () => callTaskParser,\n  createInstanceConfig: () => createInstanceConfig,\n  delay: () => delay,\n  filterArray: () => filterArray,\n  filterFunction: () => filterFunction,\n  filterHasLength: () => filterHasLength,\n  filterPlainObject: () => filterPlainObject,\n  filterPrimitives: () => filterPrimitives,\n  filterString: () => filterString,\n  filterStringArray: () => filterStringArray,\n  filterStringOrStringArray: () => filterStringOrStringArray,\n  filterType: () => filterType,\n  first: () => first,\n  folderExists: () => folderExists,\n  forEachLineWithContent: () => forEachLineWithContent,\n  getTrailingOptions: () => getTrailingOptions,\n  including: () => including,\n  isUserFunction: () => isUserFunction,\n  last: () => last,\n  objectToString: () => objectToString,\n  orVoid: () => orVoid,\n  parseStringResponse: () => parseStringResponse,\n  pick: () => pick,\n  prefixedArray: () => prefixedArray,\n  remove: () => remove,\n  splitOn: () => splitOn,\n  toLinesWithContent: () => toLinesWithContent,\n  trailingFunctionArgument: () => trailingFunctionArgument,\n  trailingOptionsArgument: () => trailingOptionsArgument\n});\nvar init_utils = __esm({\n  \"src/lib/utils/index.ts\"() {\n    \"use strict\";\n    init_argument_filters();\n    init_exit_codes();\n    init_git_output_streams();\n    init_line_parser();\n    init_simple_git_options();\n    init_task_options();\n    init_task_parser();\n    init_util();\n  }\n});\n\n// src/lib/tasks/check-is-repo.ts\nvar check_is_repo_exports = {};\n__export(check_is_repo_exports, {\n  CheckRepoActions: () => CheckRepoActions,\n  checkIsBareRepoTask: () => checkIsBareRepoTask,\n  checkIsRepoRootTask: () => checkIsRepoRootTask,\n  checkIsRepoTask: () => checkIsRepoTask\n});\nfunction checkIsRepoTask(action) {\n  switch (action) {\n    case \"bare\" /* BARE */:\n      return checkIsBareRepoTask();\n    case \"root\" /* IS_REPO_ROOT */:\n      return checkIsRepoRootTask();\n  }\n  const commands = [\"rev-parse\", \"--is-inside-work-tree\"];\n  return {\n    commands,\n    format: \"utf-8\",\n    onError,\n    parser\n  };\n}\nfunction checkIsRepoRootTask() {\n  const commands = [\"rev-parse\", \"--git-dir\"];\n  return {\n    commands,\n    format: \"utf-8\",\n    onError,\n    parser(path) {\n      return /^\\.(git)?$/.test(path.trim());\n    }\n  };\n}\nfunction checkIsBareRepoTask() {\n  const commands = [\"rev-parse\", \"--is-bare-repository\"];\n  return {\n    commands,\n    format: \"utf-8\",\n    onError,\n    parser\n  };\n}\nfunction isNotRepoMessage(error) {\n  return /(Not a git repository|Kein Git-Repository)/i.test(String(error));\n}\nvar CheckRepoActions, onError, parser;\nvar init_check_is_repo = __esm({\n  \"src/lib/tasks/check-is-repo.ts\"() {\n    \"use strict\";\n    init_utils();\n    CheckRepoActions = /* @__PURE__ */ ((CheckRepoActions2) => {\n      CheckRepoActions2[\"BARE\"] = \"bare\";\n      CheckRepoActions2[\"IN_TREE\"] = \"tree\";\n      CheckRepoActions2[\"IS_REPO_ROOT\"] = \"root\";\n      return CheckRepoActions2;\n    })(CheckRepoActions || {});\n    onError = ({ exitCode }, error, done, fail) => {\n      if (exitCode === 128 /* UNCLEAN */ && isNotRepoMessage(error)) {\n        return done(Buffer.from(\"false\"));\n      }\n      fail(error);\n    };\n    parser = (text) => {\n      return text.trim() === \"true\";\n    };\n  }\n});\n\n// src/lib/responses/CleanSummary.ts\nfunction cleanSummaryParser(dryRun, text) {\n  const summary = new CleanResponse(dryRun);\n  const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;\n  toLinesWithContent(text).forEach((line) => {\n    const removed = line.replace(regexp, \"\");\n    summary.paths.push(removed);\n    (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);\n  });\n  return summary;\n}\nvar CleanResponse, removalRegexp, dryRunRemovalRegexp, isFolderRegexp;\nvar init_CleanSummary = __esm({\n  \"src/lib/responses/CleanSummary.ts\"() {\n    \"use strict\";\n    init_utils();\n    CleanResponse = class {\n      constructor(dryRun) {\n        this.dryRun = dryRun;\n        this.paths = [];\n        this.files = [];\n        this.folders = [];\n      }\n    };\n    removalRegexp = /^[a-z]+\\s*/i;\n    dryRunRemovalRegexp = /^[a-z]+\\s+[a-z]+\\s*/i;\n    isFolderRegexp = /\\/$/;\n  }\n});\n\n// src/lib/tasks/task.ts\nvar task_exports = {};\n__export(task_exports, {\n  EMPTY_COMMANDS: () => EMPTY_COMMANDS,\n  adhocExecTask: () => adhocExecTask,\n  configurationErrorTask: () => configurationErrorTask,\n  isBufferTask: () => isBufferTask,\n  isEmptyTask: () => isEmptyTask,\n  straightThroughBufferTask: () => straightThroughBufferTask,\n  straightThroughStringTask: () => straightThroughStringTask\n});\nfunction adhocExecTask(parser4) {\n  return {\n    commands: EMPTY_COMMANDS,\n    format: \"empty\",\n    parser: parser4\n  };\n}\nfunction configurationErrorTask(error) {\n  return {\n    commands: EMPTY_COMMANDS,\n    format: \"empty\",\n    parser() {\n      throw typeof error === \"string\" ? new TaskConfigurationError(error) : error;\n    }\n  };\n}\nfunction straightThroughStringTask(commands, trimmed2 = false) {\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return trimmed2 ? String(text).trim() : text;\n    }\n  };\n}\nfunction straightThroughBufferTask(commands) {\n  return {\n    commands,\n    format: \"buffer\",\n    parser(buffer) {\n      return buffer;\n    }\n  };\n}\nfunction isBufferTask(task) {\n  return task.format === \"buffer\";\n}\nfunction isEmptyTask(task) {\n  return task.format === \"empty\" || !task.commands.length;\n}\nvar EMPTY_COMMANDS;\nvar init_task = __esm({\n  \"src/lib/tasks/task.ts\"() {\n    \"use strict\";\n    init_task_configuration_error();\n    EMPTY_COMMANDS = [];\n  }\n});\n\n// src/lib/tasks/clean.ts\nvar clean_exports = {};\n__export(clean_exports, {\n  CONFIG_ERROR_INTERACTIVE_MODE: () => CONFIG_ERROR_INTERACTIVE_MODE,\n  CONFIG_ERROR_MODE_REQUIRED: () => CONFIG_ERROR_MODE_REQUIRED,\n  CONFIG_ERROR_UNKNOWN_OPTION: () => CONFIG_ERROR_UNKNOWN_OPTION,\n  CleanOptions: () => CleanOptions,\n  cleanTask: () => cleanTask,\n  cleanWithOptionsTask: () => cleanWithOptionsTask,\n  isCleanOptionsArray: () => isCleanOptionsArray\n});\nfunction cleanWithOptionsTask(mode, customArgs) {\n  const { cleanMode, options, valid } = getCleanOptions(mode);\n  if (!cleanMode) {\n    return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);\n  }\n  if (!valid.options) {\n    return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));\n  }\n  options.push(...customArgs);\n  if (options.some(isInteractiveMode)) {\n    return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);\n  }\n  return cleanTask(cleanMode, options);\n}\nfunction cleanTask(mode, customArgs) {\n  const commands = [\"clean\", `-${mode}`, ...customArgs];\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return cleanSummaryParser(mode === \"n\" /* DRY_RUN */, text);\n    }\n  };\n}\nfunction isCleanOptionsArray(input) {\n  return Array.isArray(input) && input.every((test) => CleanOptionValues.has(test));\n}\nfunction getCleanOptions(input) {\n  let cleanMode;\n  let options = [];\n  let valid = { cleanMode: false, options: true };\n  input.replace(/[^a-z]i/g, \"\").split(\"\").forEach((char) => {\n    if (isCleanMode(char)) {\n      cleanMode = char;\n      valid.cleanMode = true;\n    } else {\n      valid.options = valid.options && isKnownOption(options[options.length] = `-${char}`);\n    }\n  });\n  return {\n    cleanMode,\n    options,\n    valid\n  };\n}\nfunction isCleanMode(cleanMode) {\n  return cleanMode === \"f\" /* FORCE */ || cleanMode === \"n\" /* DRY_RUN */;\n}\nfunction isKnownOption(option) {\n  return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));\n}\nfunction isInteractiveMode(option) {\n  if (/^-[^\\-]/.test(option)) {\n    return option.indexOf(\"i\") > 0;\n  }\n  return option === \"--interactive\";\n}\nvar CONFIG_ERROR_INTERACTIVE_MODE, CONFIG_ERROR_MODE_REQUIRED, CONFIG_ERROR_UNKNOWN_OPTION, CleanOptions, CleanOptionValues;\nvar init_clean = __esm({\n  \"src/lib/tasks/clean.ts\"() {\n    \"use strict\";\n    init_CleanSummary();\n    init_utils();\n    init_task();\n    CONFIG_ERROR_INTERACTIVE_MODE = \"Git clean interactive mode is not supported\";\n    CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter (\"n\" or \"f\") is required';\n    CONFIG_ERROR_UNKNOWN_OPTION = \"Git clean unknown option found in: \";\n    CleanOptions = /* @__PURE__ */ ((CleanOptions2) => {\n      CleanOptions2[\"DRY_RUN\"] = \"n\";\n      CleanOptions2[\"FORCE\"] = \"f\";\n      CleanOptions2[\"IGNORED_INCLUDED\"] = \"x\";\n      CleanOptions2[\"IGNORED_ONLY\"] = \"X\";\n      CleanOptions2[\"EXCLUDING\"] = \"e\";\n      CleanOptions2[\"QUIET\"] = \"q\";\n      CleanOptions2[\"RECURSIVE\"] = \"d\";\n      return CleanOptions2;\n    })(CleanOptions || {});\n    CleanOptionValues = /* @__PURE__ */ new Set([\n      \"i\",\n      ...asStringArray(Object.values(CleanOptions))\n    ]);\n  }\n});\n\n// src/lib/responses/ConfigList.ts\nfunction configListParser(text) {\n  const config = new ConfigList();\n  for (const item of configParser(text)) {\n    config.addValue(item.file, String(item.key), item.value);\n  }\n  return config;\n}\nfunction configGetParser(text, key) {\n  let value = null;\n  const values = [];\n  const scopes = /* @__PURE__ */ new Map();\n  for (const item of configParser(text, key)) {\n    if (item.key !== key) {\n      continue;\n    }\n    values.push(value = item.value);\n    if (!scopes.has(item.file)) {\n      scopes.set(item.file, []);\n    }\n    scopes.get(item.file).push(value);\n  }\n  return {\n    key,\n    paths: Array.from(scopes.keys()),\n    scopes,\n    value,\n    values\n  };\n}\nfunction configFilePath(filePath) {\n  return filePath.replace(/^(file):/, \"\");\n}\nfunction* configParser(text, requestedKey = null) {\n  const lines = text.split(\"\\0\");\n  for (let i = 0, max = lines.length - 1; i < max; ) {\n    const file = configFilePath(lines[i++]);\n    let value = lines[i++];\n    let key = requestedKey;\n    if (value.includes(\"\\n\")) {\n      const line = splitOn(value, \"\\n\");\n      key = line[0];\n      value = line[1];\n    }\n    yield { file, key, value };\n  }\n}\nvar ConfigList;\nvar init_ConfigList = __esm({\n  \"src/lib/responses/ConfigList.ts\"() {\n    \"use strict\";\n    init_utils();\n    ConfigList = class {\n      constructor() {\n        this.files = [];\n        this.values = /* @__PURE__ */ Object.create(null);\n      }\n      get all() {\n        if (!this._all) {\n          this._all = this.files.reduce((all, file) => {\n            return Object.assign(all, this.values[file]);\n          }, {});\n        }\n        return this._all;\n      }\n      addFile(file) {\n        if (!(file in this.values)) {\n          const latest = last(this.files);\n          this.values[file] = latest ? Object.create(this.values[latest]) : {};\n          this.files.push(file);\n        }\n        return this.values[file];\n      }\n      addValue(file, key, value) {\n        const values = this.addFile(file);\n        if (!values.hasOwnProperty(key)) {\n          values[key] = value;\n        } else if (Array.isArray(values[key])) {\n          values[key].push(value);\n        } else {\n          values[key] = [values[key], value];\n        }\n        this._all = void 0;\n      }\n    };\n  }\n});\n\n// src/lib/tasks/config.ts\nfunction asConfigScope(scope, fallback) {\n  if (typeof scope === \"string\" && GitConfigScope.hasOwnProperty(scope)) {\n    return scope;\n  }\n  return fallback;\n}\nfunction addConfigTask(key, value, append2, scope) {\n  const commands = [\"config\", `--${scope}`];\n  if (append2) {\n    commands.push(\"--add\");\n  }\n  commands.push(key, value);\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return text;\n    }\n  };\n}\nfunction getConfigTask(key, scope) {\n  const commands = [\"config\", \"--null\", \"--show-origin\", \"--get-all\", key];\n  if (scope) {\n    commands.splice(1, 0, `--${scope}`);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return configGetParser(text, key);\n    }\n  };\n}\nfunction listConfigTask(scope) {\n  const commands = [\"config\", \"--list\", \"--show-origin\", \"--null\"];\n  if (scope) {\n    commands.push(`--${scope}`);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return configListParser(text);\n    }\n  };\n}\nfunction config_default() {\n  return {\n    addConfig(key, value, ...rest) {\n      return this._runTask(\n        addConfigTask(\n          key,\n          value,\n          rest[0] === true,\n          asConfigScope(rest[1], \"local\" /* local */)\n        ),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    getConfig(key, scope) {\n      return this._runTask(\n        getConfigTask(key, asConfigScope(scope, void 0)),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    listConfig(...rest) {\n      return this._runTask(\n        listConfigTask(asConfigScope(rest[0], void 0)),\n        trailingFunctionArgument(arguments)\n      );\n    }\n  };\n}\nvar GitConfigScope;\nvar init_config = __esm({\n  \"src/lib/tasks/config.ts\"() {\n    \"use strict\";\n    init_ConfigList();\n    init_utils();\n    GitConfigScope = /* @__PURE__ */ ((GitConfigScope2) => {\n      GitConfigScope2[\"system\"] = \"system\";\n      GitConfigScope2[\"global\"] = \"global\";\n      GitConfigScope2[\"local\"] = \"local\";\n      GitConfigScope2[\"worktree\"] = \"worktree\";\n      return GitConfigScope2;\n    })(GitConfigScope || {});\n  }\n});\n\n// src/lib/tasks/diff-name-status.ts\nfunction isDiffNameStatus(input) {\n  return diffNameStatus.has(input);\n}\nvar DiffNameStatus, diffNameStatus;\nvar init_diff_name_status = __esm({\n  \"src/lib/tasks/diff-name-status.ts\"() {\n    \"use strict\";\n    DiffNameStatus = /* @__PURE__ */ ((DiffNameStatus2) => {\n      DiffNameStatus2[\"ADDED\"] = \"A\";\n      DiffNameStatus2[\"COPIED\"] = \"C\";\n      DiffNameStatus2[\"DELETED\"] = \"D\";\n      DiffNameStatus2[\"MODIFIED\"] = \"M\";\n      DiffNameStatus2[\"RENAMED\"] = \"R\";\n      DiffNameStatus2[\"CHANGED\"] = \"T\";\n      DiffNameStatus2[\"UNMERGED\"] = \"U\";\n      DiffNameStatus2[\"UNKNOWN\"] = \"X\";\n      DiffNameStatus2[\"BROKEN\"] = \"B\";\n      return DiffNameStatus2;\n    })(DiffNameStatus || {});\n    diffNameStatus = new Set(Object.values(DiffNameStatus));\n  }\n});\n\n// src/lib/tasks/grep.ts\nfunction grepQueryBuilder(...params) {\n  return new GrepQuery().param(...params);\n}\nfunction parseGrep(grep) {\n  const paths = /* @__PURE__ */ new Set();\n  const results = {};\n  forEachLineWithContent(grep, (input) => {\n    const [path, line, preview] = input.split(NULL);\n    paths.add(path);\n    (results[path] = results[path] || []).push({\n      line: asNumber(line),\n      path,\n      preview\n    });\n  });\n  return {\n    paths,\n    results\n  };\n}\nfunction grep_default() {\n  return {\n    grep(searchTerm) {\n      const then = trailingFunctionArgument(arguments);\n      const options = getTrailingOptions(arguments);\n      for (const option of disallowedOptions) {\n        if (options.includes(option)) {\n          return this._runTask(\n            configurationErrorTask(`git.grep: use of \"${option}\" is not supported.`),\n            then\n          );\n        }\n      }\n      if (typeof searchTerm === \"string\") {\n        searchTerm = grepQueryBuilder().param(searchTerm);\n      }\n      const commands = [\"grep\", \"--null\", \"-n\", \"--full-name\", ...options, ...searchTerm];\n      return this._runTask(\n        {\n          commands,\n          format: \"utf-8\",\n          parser(stdOut) {\n            return parseGrep(stdOut);\n          }\n        },\n        then\n      );\n    }\n  };\n}\nvar disallowedOptions, Query, _a, GrepQuery;\nvar init_grep = __esm({\n  \"src/lib/tasks/grep.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n    disallowedOptions = [\"-h\"];\n    Query = Symbol(\"grepQuery\");\n    GrepQuery = class {\n      constructor() {\n        this[_a] = [];\n      }\n      *[(_a = Query, Symbol.iterator)]() {\n        for (const query of this[Query]) {\n          yield query;\n        }\n      }\n      and(...and) {\n        and.length && this[Query].push(\"--and\", \"(\", ...prefixedArray(and, \"-e\"), \")\");\n        return this;\n      }\n      param(...param) {\n        this[Query].push(...prefixedArray(param, \"-e\"));\n        return this;\n      }\n    };\n  }\n});\n\n// src/lib/tasks/reset.ts\nvar reset_exports = {};\n__export(reset_exports, {\n  ResetMode: () => ResetMode,\n  getResetMode: () => getResetMode,\n  resetTask: () => resetTask\n});\nfunction resetTask(mode, customArgs) {\n  const commands = [\"reset\"];\n  if (isValidResetMode(mode)) {\n    commands.push(`--${mode}`);\n  }\n  commands.push(...customArgs);\n  return straightThroughStringTask(commands);\n}\nfunction getResetMode(mode) {\n  if (isValidResetMode(mode)) {\n    return mode;\n  }\n  switch (typeof mode) {\n    case \"string\":\n    case \"undefined\":\n      return \"soft\" /* SOFT */;\n  }\n  return;\n}\nfunction isValidResetMode(mode) {\n  return ResetModes.includes(mode);\n}\nvar ResetMode, ResetModes;\nvar init_reset = __esm({\n  \"src/lib/tasks/reset.ts\"() {\n    \"use strict\";\n    init_task();\n    ResetMode = /* @__PURE__ */ ((ResetMode2) => {\n      ResetMode2[\"MIXED\"] = \"mixed\";\n      ResetMode2[\"SOFT\"] = \"soft\";\n      ResetMode2[\"HARD\"] = \"hard\";\n      ResetMode2[\"MERGE\"] = \"merge\";\n      ResetMode2[\"KEEP\"] = \"keep\";\n      return ResetMode2;\n    })(ResetMode || {});\n    ResetModes = Array.from(Object.values(ResetMode));\n  }\n});\n\n// src/lib/git-logger.ts\n\nfunction createLog() {\n  return debug__WEBPACK_IMPORTED_MODULE_1__(\"simple-git\");\n}\nfunction prefixedLogger(to, prefix, forward) {\n  if (!prefix || !String(prefix).replace(/\\s*/, \"\")) {\n    return !forward ? to : (message, ...args) => {\n      to(message, ...args);\n      forward(message, ...args);\n    };\n  }\n  return (message, ...args) => {\n    to(`%s ${message}`, prefix, ...args);\n    if (forward) {\n      forward(message, ...args);\n    }\n  };\n}\nfunction childLoggerName(name, childDebugger, { namespace: parentNamespace }) {\n  if (typeof name === \"string\") {\n    return name;\n  }\n  const childNamespace = childDebugger && childDebugger.namespace || \"\";\n  if (childNamespace.startsWith(parentNamespace)) {\n    return childNamespace.substr(parentNamespace.length + 1);\n  }\n  return childNamespace || parentNamespace;\n}\nfunction createLogger(label, verbose, initialStep, infoDebugger = createLog()) {\n  const labelPrefix = label && `[${label}]` || \"\";\n  const spawned = [];\n  const debugDebugger = typeof verbose === \"string\" ? infoDebugger.extend(verbose) : verbose;\n  const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);\n  return step(initialStep);\n  function sibling(name, initial) {\n    return append(\n      spawned,\n      createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger)\n    );\n  }\n  function step(phase) {\n    const stepPrefix = phase && `[${phase}]` || \"\";\n    const debug2 = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;\n    const info = prefixedLogger(infoDebugger, `${labelPrefix} ${stepPrefix}`, debug2);\n    return Object.assign(debugDebugger ? debug2 : info, {\n      label,\n      sibling,\n      info,\n      step\n    });\n  }\n}\nvar init_git_logger = __esm({\n  \"src/lib/git-logger.ts\"() {\n    \"use strict\";\n    init_utils();\n    debug__WEBPACK_IMPORTED_MODULE_1__.formatters.L = (value) => String(filterHasLength(value) ? value.length : \"-\");\n    debug__WEBPACK_IMPORTED_MODULE_1__.formatters.B = (value) => {\n      if (Buffer.isBuffer(value)) {\n        return value.toString(\"utf8\");\n      }\n      return objectToString(value);\n    };\n  }\n});\n\n// src/lib/runners/tasks-pending-queue.ts\nvar _TasksPendingQueue, TasksPendingQueue;\nvar init_tasks_pending_queue = __esm({\n  \"src/lib/runners/tasks-pending-queue.ts\"() {\n    \"use strict\";\n    init_git_error();\n    init_git_logger();\n    _TasksPendingQueue = class {\n      constructor(logLabel = \"GitExecutor\") {\n        this.logLabel = logLabel;\n        this._queue = /* @__PURE__ */ new Map();\n      }\n      withProgress(task) {\n        return this._queue.get(task);\n      }\n      createProgress(task) {\n        const name = _TasksPendingQueue.getName(task.commands[0]);\n        const logger = createLogger(this.logLabel, name);\n        return {\n          task,\n          logger,\n          name\n        };\n      }\n      push(task) {\n        const progress = this.createProgress(task);\n        progress.logger(\"Adding task to the queue, commands = %o\", task.commands);\n        this._queue.set(task, progress);\n        return progress;\n      }\n      fatal(err) {\n        for (const [task, { logger }] of Array.from(this._queue.entries())) {\n          if (task === err.task) {\n            logger.info(`Failed %o`, err);\n            logger(\n              `Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`\n            );\n          } else {\n            logger.info(\n              `A fatal exception occurred in a previous task, the queue has been purged: %o`,\n              err.message\n            );\n          }\n          this.complete(task);\n        }\n        if (this._queue.size !== 0) {\n          throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);\n        }\n      }\n      complete(task) {\n        const progress = this.withProgress(task);\n        if (progress) {\n          this._queue.delete(task);\n        }\n      }\n      attempt(task) {\n        const progress = this.withProgress(task);\n        if (!progress) {\n          throw new GitError(void 0, \"TasksPendingQueue: attempt called for an unknown task\");\n        }\n        progress.logger(\"Starting task\");\n        return progress;\n      }\n      static getName(name = \"empty\") {\n        return `task:${name}:${++_TasksPendingQueue.counter}`;\n      }\n    };\n    TasksPendingQueue = _TasksPendingQueue;\n    TasksPendingQueue.counter = 0;\n  }\n});\n\n// src/lib/runners/git-executor-chain.ts\n\nfunction pluginContext(task, commands) {\n  return {\n    method: first(task.commands) || \"\",\n    commands\n  };\n}\nfunction onErrorReceived(target, logger) {\n  return (err) => {\n    logger(`[ERROR] child process exception %o`, err);\n    target.push(Buffer.from(String(err.stack), \"ascii\"));\n  };\n}\nfunction onDataReceived(target, name, logger, output) {\n  return (buffer) => {\n    logger(`%s received %L bytes`, name, buffer);\n    output(`%B`, buffer);\n    target.push(buffer);\n  };\n}\nvar GitExecutorChain;\nvar init_git_executor_chain = __esm({\n  \"src/lib/runners/git-executor-chain.ts\"() {\n    \"use strict\";\n    init_git_error();\n    init_task();\n    init_utils();\n    init_tasks_pending_queue();\n    GitExecutorChain = class {\n      constructor(_executor, _scheduler, _plugins) {\n        this._executor = _executor;\n        this._scheduler = _scheduler;\n        this._plugins = _plugins;\n        this._chain = Promise.resolve();\n        this._queue = new TasksPendingQueue();\n      }\n      get cwd() {\n        return this._cwd || this._executor.cwd;\n      }\n      set cwd(cwd) {\n        this._cwd = cwd;\n      }\n      get env() {\n        return this._executor.env;\n      }\n      get outputHandler() {\n        return this._executor.outputHandler;\n      }\n      chain() {\n        return this;\n      }\n      push(task) {\n        this._queue.push(task);\n        return this._chain = this._chain.then(() => this.attemptTask(task));\n      }\n      attemptTask(task) {\n        return __async(this, null, function* () {\n          const onScheduleComplete = yield this._scheduler.next();\n          const onQueueComplete = () => this._queue.complete(task);\n          try {\n            const { logger } = this._queue.attempt(task);\n            return yield isEmptyTask(task) ? this.attemptEmptyTask(task, logger) : this.attemptRemoteTask(task, logger);\n          } catch (e) {\n            throw this.onFatalException(task, e);\n          } finally {\n            onQueueComplete();\n            onScheduleComplete();\n          }\n        });\n      }\n      onFatalException(task, e) {\n        const gitError = e instanceof GitError ? Object.assign(e, { task }) : new GitError(task, e && String(e));\n        this._chain = Promise.resolve();\n        this._queue.fatal(gitError);\n        return gitError;\n      }\n      attemptRemoteTask(task, logger) {\n        return __async(this, null, function* () {\n          const binary = this._plugins.exec(\"spawn.binary\", \"\", pluginContext(task, task.commands));\n          const args = this._plugins.exec(\n            \"spawn.args\",\n            [...task.commands],\n            pluginContext(task, task.commands)\n          );\n          const raw = yield this.gitResponse(\n            task,\n            binary,\n            args,\n            this.outputHandler,\n            logger.step(\"SPAWN\")\n          );\n          const outputStreams = yield this.handleTaskData(task, args, raw, logger.step(\"HANDLE\"));\n          logger(`passing response to task's parser as a %s`, task.format);\n          if (isBufferTask(task)) {\n            return callTaskParser(task.parser, outputStreams);\n          }\n          return callTaskParser(task.parser, outputStreams.asStrings());\n        });\n      }\n      attemptEmptyTask(task, logger) {\n        return __async(this, null, function* () {\n          logger(`empty task bypassing child process to call to task's parser`);\n          return task.parser(this);\n        });\n      }\n      handleTaskData(task, args, result, logger) {\n        const { exitCode, rejection, stdOut, stdErr } = result;\n        return new Promise((done, fail) => {\n          logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);\n          const { error } = this._plugins.exec(\n            \"task.error\",\n            { error: rejection },\n            __spreadValues(__spreadValues({}, pluginContext(task, args)), result)\n          );\n          if (error && task.onError) {\n            logger.info(`exitCode=%s handling with custom error handler`);\n            return task.onError(\n              result,\n              error,\n              (newStdOut) => {\n                logger.info(`custom error handler treated as success`);\n                logger(`custom error returned a %s`, objectToString(newStdOut));\n                done(\n                  new GitOutputStreams(\n                    Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut,\n                    Buffer.concat(stdErr)\n                  )\n                );\n              },\n              fail\n            );\n          }\n          if (error) {\n            logger.info(\n              `handling as error: exitCode=%s stdErr=%s rejection=%o`,\n              exitCode,\n              stdErr.length,\n              rejection\n            );\n            return fail(error);\n          }\n          logger.info(`retrieving task output complete`);\n          done(new GitOutputStreams(Buffer.concat(stdOut), Buffer.concat(stdErr)));\n        });\n      }\n      gitResponse(task, command, args, outputHandler, logger) {\n        return __async(this, null, function* () {\n          const outputLogger = logger.sibling(\"output\");\n          const spawnOptions = this._plugins.exec(\n            \"spawn.options\",\n            {\n              cwd: this.cwd,\n              env: this.env,\n              windowsHide: true\n            },\n            pluginContext(task, task.commands)\n          );\n          return new Promise((done) => {\n            const stdOut = [];\n            const stdErr = [];\n            logger.info(`%s %o`, command, args);\n            logger(\"%O\", spawnOptions);\n            let rejection = this._beforeSpawn(task, args);\n            if (rejection) {\n              return done({\n                stdOut,\n                stdErr,\n                exitCode: 9901,\n                rejection\n              });\n            }\n            this._plugins.exec(\"spawn.before\", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {\n              kill(reason) {\n                rejection = reason || rejection;\n              }\n            }));\n            const spawned = (0,child_process__WEBPACK_IMPORTED_MODULE_2__.spawn)(command, args, spawnOptions);\n            spawned.stdout.on(\n              \"data\",\n              onDataReceived(stdOut, \"stdOut\", logger, outputLogger.step(\"stdOut\"))\n            );\n            spawned.stderr.on(\n              \"data\",\n              onDataReceived(stdErr, \"stdErr\", logger, outputLogger.step(\"stdErr\"))\n            );\n            spawned.on(\"error\", onErrorReceived(stdErr, logger));\n            if (outputHandler) {\n              logger(`Passing child process stdOut/stdErr to custom outputHandler`);\n              outputHandler(command, spawned.stdout, spawned.stderr, [...args]);\n            }\n            this._plugins.exec(\"spawn.after\", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {\n              spawned,\n              close(exitCode, reason) {\n                done({\n                  stdOut,\n                  stdErr,\n                  exitCode,\n                  rejection: rejection || reason\n                });\n              },\n              kill(reason) {\n                if (spawned.killed) {\n                  return;\n                }\n                rejection = reason;\n                spawned.kill(\"SIGINT\");\n              }\n            }));\n          });\n        });\n      }\n      _beforeSpawn(task, args) {\n        let rejection;\n        this._plugins.exec(\"spawn.before\", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {\n          kill(reason) {\n            rejection = reason || rejection;\n          }\n        }));\n        return rejection;\n      }\n    };\n  }\n});\n\n// src/lib/runners/git-executor.ts\nvar git_executor_exports = {};\n__export(git_executor_exports, {\n  GitExecutor: () => GitExecutor\n});\nvar GitExecutor;\nvar init_git_executor = __esm({\n  \"src/lib/runners/git-executor.ts\"() {\n    \"use strict\";\n    init_git_executor_chain();\n    GitExecutor = class {\n      constructor(cwd, _scheduler, _plugins) {\n        this.cwd = cwd;\n        this._scheduler = _scheduler;\n        this._plugins = _plugins;\n        this._chain = new GitExecutorChain(this, this._scheduler, this._plugins);\n      }\n      chain() {\n        return new GitExecutorChain(this, this._scheduler, this._plugins);\n      }\n      push(task) {\n        return this._chain.push(task);\n      }\n    };\n  }\n});\n\n// src/lib/task-callback.ts\nfunction taskCallback(task, response, callback = NOOP) {\n  const onSuccess = (data) => {\n    callback(null, data);\n  };\n  const onError2 = (err) => {\n    if ((err == null ? void 0 : err.task) === task) {\n      callback(\n        err instanceof GitResponseError ? addDeprecationNoticeToError(err) : err,\n        void 0\n      );\n    }\n  };\n  response.then(onSuccess, onError2);\n}\nfunction addDeprecationNoticeToError(err) {\n  let log = (name) => {\n    console.warn(\n      `simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`\n    );\n    log = NOOP;\n  };\n  return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));\n  function descriptorReducer(all, name) {\n    if (name in err) {\n      return all;\n    }\n    all[name] = {\n      enumerable: false,\n      configurable: false,\n      get() {\n        log(name);\n        return err.git[name];\n      }\n    };\n    return all;\n  }\n}\nvar init_task_callback = __esm({\n  \"src/lib/task-callback.ts\"() {\n    \"use strict\";\n    init_git_response_error();\n    init_utils();\n  }\n});\n\n// src/lib/tasks/change-working-directory.ts\nfunction changeWorkingDirectoryTask(directory, root) {\n  return adhocExecTask((instance) => {\n    if (!folderExists(directory)) {\n      throw new Error(`Git.cwd: cannot change to non-directory \"${directory}\"`);\n    }\n    return (root || instance).cwd = directory;\n  });\n}\nvar init_change_working_directory = __esm({\n  \"src/lib/tasks/change-working-directory.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/checkout.ts\nfunction checkoutTask(args) {\n  const commands = [\"checkout\", ...args];\n  if (commands[1] === \"-b\" && commands.includes(\"-B\")) {\n    commands[1] = remove(commands, \"-B\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction checkout_default() {\n  return {\n    checkout() {\n      return this._runTask(\n        checkoutTask(getTrailingOptions(arguments, 1)),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    checkoutBranch(branchName, startPoint) {\n      return this._runTask(\n        checkoutTask([\"-b\", branchName, startPoint, ...getTrailingOptions(arguments)]),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    checkoutLocalBranch(branchName) {\n      return this._runTask(\n        checkoutTask([\"-b\", branchName, ...getTrailingOptions(arguments)]),\n        trailingFunctionArgument(arguments)\n      );\n    }\n  };\n}\nvar init_checkout = __esm({\n  \"src/lib/tasks/checkout.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/count-objects.ts\nfunction countObjectsResponse() {\n  return {\n    count: 0,\n    garbage: 0,\n    inPack: 0,\n    packs: 0,\n    prunePackable: 0,\n    size: 0,\n    sizeGarbage: 0,\n    sizePack: 0\n  };\n}\nfunction count_objects_default() {\n  return {\n    countObjects() {\n      return this._runTask({\n        commands: [\"count-objects\", \"--verbose\"],\n        format: \"utf-8\",\n        parser(stdOut) {\n          return parseStringResponse(countObjectsResponse(), [parser2], stdOut);\n        }\n      });\n    }\n  };\n}\nvar parser2;\nvar init_count_objects = __esm({\n  \"src/lib/tasks/count-objects.ts\"() {\n    \"use strict\";\n    init_utils();\n    parser2 = new LineParser(\n      /([a-z-]+): (\\d+)$/,\n      (result, [key, value]) => {\n        const property = asCamelCase(key);\n        if (result.hasOwnProperty(property)) {\n          result[property] = asNumber(value);\n        }\n      }\n    );\n  }\n});\n\n// src/lib/parsers/parse-commit.ts\nfunction parseCommitResult(stdOut) {\n  const result = {\n    author: null,\n    branch: \"\",\n    commit: \"\",\n    root: false,\n    summary: {\n      changes: 0,\n      insertions: 0,\n      deletions: 0\n    }\n  };\n  return parseStringResponse(result, parsers, stdOut);\n}\nvar parsers;\nvar init_parse_commit = __esm({\n  \"src/lib/parsers/parse-commit.ts\"() {\n    \"use strict\";\n    init_utils();\n    parsers = [\n      new LineParser(/^\\[([^\\s]+)( \\([^)]+\\))? ([^\\]]+)/, (result, [branch, root, commit]) => {\n        result.branch = branch;\n        result.commit = commit;\n        result.root = !!root;\n      }),\n      new LineParser(/\\s*Author:\\s(.+)/i, (result, [author]) => {\n        const parts = author.split(\"<\");\n        const email = parts.pop();\n        if (!email || !email.includes(\"@\")) {\n          return;\n        }\n        result.author = {\n          email: email.substr(0, email.length - 1),\n          name: parts.join(\"<\").trim()\n        };\n      }),\n      new LineParser(\n        /(\\d+)[^,]*(?:,\\s*(\\d+)[^,]*)(?:,\\s*(\\d+))/g,\n        (result, [changes, insertions, deletions]) => {\n          result.summary.changes = parseInt(changes, 10) || 0;\n          result.summary.insertions = parseInt(insertions, 10) || 0;\n          result.summary.deletions = parseInt(deletions, 10) || 0;\n        }\n      ),\n      new LineParser(\n        /^(\\d+)[^,]*(?:,\\s*(\\d+)[^(]+\\(([+-]))?/,\n        (result, [changes, lines, direction]) => {\n          result.summary.changes = parseInt(changes, 10) || 0;\n          const count = parseInt(lines, 10) || 0;\n          if (direction === \"-\") {\n            result.summary.deletions = count;\n          } else if (direction === \"+\") {\n            result.summary.insertions = count;\n          }\n        }\n      )\n    ];\n  }\n});\n\n// src/lib/tasks/commit.ts\nfunction commitTask(message, files, customArgs) {\n  const commands = [\n    \"-c\",\n    \"core.abbrev=40\",\n    \"commit\",\n    ...prefixedArray(message, \"-m\"),\n    ...files,\n    ...customArgs\n  ];\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: parseCommitResult\n  };\n}\nfunction commit_default() {\n  return {\n    commit(message, ...rest) {\n      const next = trailingFunctionArgument(arguments);\n      const task = rejectDeprecatedSignatures(message) || commitTask(\n        asArray(message),\n        asArray(filterType(rest[0], filterStringOrStringArray, [])),\n        [...filterType(rest[1], filterArray, []), ...getTrailingOptions(arguments, 0, true)]\n      );\n      return this._runTask(task, next);\n    }\n  };\n  function rejectDeprecatedSignatures(message) {\n    return !filterStringOrStringArray(message) && configurationErrorTask(\n      `git.commit: requires the commit message to be supplied as a string/string[]`\n    );\n  }\n}\nvar init_commit = __esm({\n  \"src/lib/tasks/commit.ts\"() {\n    \"use strict\";\n    init_parse_commit();\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/first-commit.ts\nfunction first_commit_default() {\n  return {\n    firstCommit() {\n      return this._runTask(\n        straightThroughStringTask([\"rev-list\", \"--max-parents=0\", \"HEAD\"], true),\n        trailingFunctionArgument(arguments)\n      );\n    }\n  };\n}\nvar init_first_commit = __esm({\n  \"src/lib/tasks/first-commit.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/tasks/hash-object.ts\nfunction hashObjectTask(filePath, write) {\n  const commands = [\"hash-object\", filePath];\n  if (write) {\n    commands.push(\"-w\");\n  }\n  return straightThroughStringTask(commands, true);\n}\nvar init_hash_object = __esm({\n  \"src/lib/tasks/hash-object.ts\"() {\n    \"use strict\";\n    init_task();\n  }\n});\n\n// src/lib/responses/InitSummary.ts\nfunction parseInit(bare, path, text) {\n  const response = String(text).trim();\n  let result;\n  if (result = initResponseRegex.exec(response)) {\n    return new InitSummary(bare, path, false, result[1]);\n  }\n  if (result = reInitResponseRegex.exec(response)) {\n    return new InitSummary(bare, path, true, result[1]);\n  }\n  let gitDir = \"\";\n  const tokens = response.split(\" \");\n  while (tokens.length) {\n    const token = tokens.shift();\n    if (token === \"in\") {\n      gitDir = tokens.join(\" \");\n      break;\n    }\n  }\n  return new InitSummary(bare, path, /^re/i.test(response), gitDir);\n}\nvar InitSummary, initResponseRegex, reInitResponseRegex;\nvar init_InitSummary = __esm({\n  \"src/lib/responses/InitSummary.ts\"() {\n    \"use strict\";\n    InitSummary = class {\n      constructor(bare, path, existing, gitDir) {\n        this.bare = bare;\n        this.path = path;\n        this.existing = existing;\n        this.gitDir = gitDir;\n      }\n    };\n    initResponseRegex = /^Init.+ repository in (.+)$/;\n    reInitResponseRegex = /^Rein.+ in (.+)$/;\n  }\n});\n\n// src/lib/tasks/init.ts\nfunction hasBareCommand(command) {\n  return command.includes(bareCommand);\n}\nfunction initTask(bare = false, path, customArgs) {\n  const commands = [\"init\", ...customArgs];\n  if (bare && !hasBareCommand(commands)) {\n    commands.splice(1, 0, bareCommand);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(text) {\n      return parseInit(commands.includes(\"--bare\"), path, text);\n    }\n  };\n}\nvar bareCommand;\nvar init_init = __esm({\n  \"src/lib/tasks/init.ts\"() {\n    \"use strict\";\n    init_InitSummary();\n    bareCommand = \"--bare\";\n  }\n});\n\n// src/lib/args/log-format.ts\nfunction logFormatFromCommand(customArgs) {\n  for (let i = 0; i < customArgs.length; i++) {\n    const format = logFormatRegex.exec(customArgs[i]);\n    if (format) {\n      return `--${format[1]}`;\n    }\n  }\n  return \"\" /* NONE */;\n}\nfunction isLogFormat(customArg) {\n  return logFormatRegex.test(customArg);\n}\nvar logFormatRegex;\nvar init_log_format = __esm({\n  \"src/lib/args/log-format.ts\"() {\n    \"use strict\";\n    logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;\n  }\n});\n\n// src/lib/responses/DiffSummary.ts\nvar DiffSummary;\nvar init_DiffSummary = __esm({\n  \"src/lib/responses/DiffSummary.ts\"() {\n    \"use strict\";\n    DiffSummary = class {\n      constructor() {\n        this.changed = 0;\n        this.deletions = 0;\n        this.insertions = 0;\n        this.files = [];\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-diff-summary.ts\nfunction getDiffParser(format = \"\" /* NONE */) {\n  const parser4 = diffSummaryParsers[format];\n  return (stdOut) => parseStringResponse(new DiffSummary(), parser4, stdOut, false);\n}\nvar statParser, numStatParser, nameOnlyParser, nameStatusParser, diffSummaryParsers;\nvar init_parse_diff_summary = __esm({\n  \"src/lib/parsers/parse-diff-summary.ts\"() {\n    \"use strict\";\n    init_log_format();\n    init_DiffSummary();\n    init_diff_name_status();\n    init_utils();\n    statParser = [\n      new LineParser(\n        /^(.+)\\s+\\|\\s+(\\d+)(\\s+[+\\-]+)?$/,\n        (result, [file, changes, alterations = \"\"]) => {\n          result.files.push({\n            file: file.trim(),\n            changes: asNumber(changes),\n            insertions: alterations.replace(/[^+]/g, \"\").length,\n            deletions: alterations.replace(/[^-]/g, \"\").length,\n            binary: false\n          });\n        }\n      ),\n      new LineParser(\n        /^(.+) \\|\\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/,\n        (result, [file, before, after]) => {\n          result.files.push({\n            file: file.trim(),\n            before: asNumber(before),\n            after: asNumber(after),\n            binary: true\n          });\n        }\n      ),\n      new LineParser(\n        /(\\d+) files? changed\\s*((?:, \\d+ [^,]+){0,2})/,\n        (result, [changed, summary]) => {\n          const inserted = /(\\d+) i/.exec(summary);\n          const deleted = /(\\d+) d/.exec(summary);\n          result.changed = asNumber(changed);\n          result.insertions = asNumber(inserted == null ? void 0 : inserted[1]);\n          result.deletions = asNumber(deleted == null ? void 0 : deleted[1]);\n        }\n      )\n    ];\n    numStatParser = [\n      new LineParser(\n        /(\\d+)\\t(\\d+)\\t(.+)$/,\n        (result, [changesInsert, changesDelete, file]) => {\n          const insertions = asNumber(changesInsert);\n          const deletions = asNumber(changesDelete);\n          result.changed++;\n          result.insertions += insertions;\n          result.deletions += deletions;\n          result.files.push({\n            file,\n            changes: insertions + deletions,\n            insertions,\n            deletions,\n            binary: false\n          });\n        }\n      ),\n      new LineParser(/-\\t-\\t(.+)$/, (result, [file]) => {\n        result.changed++;\n        result.files.push({\n          file,\n          after: 0,\n          before: 0,\n          binary: true\n        });\n      })\n    ];\n    nameOnlyParser = [\n      new LineParser(/(.+)$/, (result, [file]) => {\n        result.changed++;\n        result.files.push({\n          file,\n          changes: 0,\n          insertions: 0,\n          deletions: 0,\n          binary: false\n        });\n      })\n    ];\n    nameStatusParser = [\n      new LineParser(\n        /([ACDMRTUXB])([0-9]{0,3})\\t(.[^\\t]*)(\\t(.[^\\t]*))?$/,\n        (result, [status, similarity, from, _to, to]) => {\n          result.changed++;\n          result.files.push({\n            file: to != null ? to : from,\n            changes: 0,\n            insertions: 0,\n            deletions: 0,\n            binary: false,\n            status: orVoid(isDiffNameStatus(status) && status),\n            from: orVoid(!!to && from !== to && from),\n            similarity: asNumber(similarity)\n          });\n        }\n      )\n    ];\n    diffSummaryParsers = {\n      [\"\" /* NONE */]: statParser,\n      [\"--stat\" /* STAT */]: statParser,\n      [\"--numstat\" /* NUM_STAT */]: numStatParser,\n      [\"--name-status\" /* NAME_STATUS */]: nameStatusParser,\n      [\"--name-only\" /* NAME_ONLY */]: nameOnlyParser\n    };\n  }\n});\n\n// src/lib/parsers/parse-list-log-summary.ts\nfunction lineBuilder(tokens, fields) {\n  return fields.reduce(\n    (line, field, index) => {\n      line[field] = tokens[index] || \"\";\n      return line;\n    },\n    /* @__PURE__ */ Object.create({ diff: null })\n  );\n}\nfunction createListLogSummaryParser(splitter = SPLITTER, fields = defaultFieldNames, logFormat = \"\" /* NONE */) {\n  const parseDiffResult = getDiffParser(logFormat);\n  return function(stdOut) {\n    const all = toLinesWithContent(\n      stdOut.trim(),\n      false,\n      START_BOUNDARY\n    ).map(function(item) {\n      const lineDetail = item.split(COMMIT_BOUNDARY);\n      const listLogLine = lineBuilder(lineDetail[0].split(splitter), fields);\n      if (lineDetail.length > 1 && !!lineDetail[1].trim()) {\n        listLogLine.diff = parseDiffResult(lineDetail[1]);\n      }\n      return listLogLine;\n    });\n    return {\n      all,\n      latest: all.length && all[0] || null,\n      total: all.length\n    };\n  };\n}\nvar START_BOUNDARY, COMMIT_BOUNDARY, SPLITTER, defaultFieldNames;\nvar init_parse_list_log_summary = __esm({\n  \"src/lib/parsers/parse-list-log-summary.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_parse_diff_summary();\n    init_log_format();\n    START_BOUNDARY = \"\\xF2\\xF2\\xF2\\xF2\\xF2\\xF2 \";\n    COMMIT_BOUNDARY = \" \\xF2\\xF2\";\n    SPLITTER = \" \\xF2 \";\n    defaultFieldNames = [\"hash\", \"date\", \"message\", \"refs\", \"author_name\", \"author_email\"];\n  }\n});\n\n// src/lib/tasks/diff.ts\nvar diff_exports = {};\n__export(diff_exports, {\n  diffSummaryTask: () => diffSummaryTask,\n  validateLogFormatConfig: () => validateLogFormatConfig\n});\nfunction diffSummaryTask(customArgs) {\n  let logFormat = logFormatFromCommand(customArgs);\n  const commands = [\"diff\"];\n  if (logFormat === \"\" /* NONE */) {\n    logFormat = \"--stat\" /* STAT */;\n    commands.push(\"--stat=4096\");\n  }\n  commands.push(...customArgs);\n  return validateLogFormatConfig(commands) || {\n    commands,\n    format: \"utf-8\",\n    parser: getDiffParser(logFormat)\n  };\n}\nfunction validateLogFormatConfig(customArgs) {\n  const flags = customArgs.filter(isLogFormat);\n  if (flags.length > 1) {\n    return configurationErrorTask(\n      `Summary flags are mutually exclusive - pick one of ${flags.join(\",\")}`\n    );\n  }\n  if (flags.length && customArgs.includes(\"-z\")) {\n    return configurationErrorTask(\n      `Summary flag ${flags} parsing is not compatible with null termination option '-z'`\n    );\n  }\n}\nvar init_diff = __esm({\n  \"src/lib/tasks/diff.ts\"() {\n    \"use strict\";\n    init_log_format();\n    init_parse_diff_summary();\n    init_task();\n  }\n});\n\n// src/lib/tasks/log.ts\nfunction prettyFormat(format, splitter) {\n  const fields = [];\n  const formatStr = [];\n  Object.keys(format).forEach((field) => {\n    fields.push(field);\n    formatStr.push(String(format[field]));\n  });\n  return [fields, formatStr.join(splitter)];\n}\nfunction userOptions(input) {\n  return Object.keys(input).reduce((out, key) => {\n    if (!(key in excludeOptions)) {\n      out[key] = input[key];\n    }\n    return out;\n  }, {});\n}\nfunction parseLogOptions(opt = {}, customArgs = []) {\n  const splitter = filterType(opt.splitter, filterString, SPLITTER);\n  const format = !filterPrimitives(opt.format) && opt.format ? opt.format : {\n    hash: \"%H\",\n    date: opt.strictDate === false ? \"%ai\" : \"%aI\",\n    message: \"%s\",\n    refs: \"%D\",\n    body: opt.multiLine ? \"%B\" : \"%b\",\n    author_name: opt.mailMap !== false ? \"%aN\" : \"%an\",\n    author_email: opt.mailMap !== false ? \"%aE\" : \"%ae\"\n  };\n  const [fields, formatStr] = prettyFormat(format, splitter);\n  const suffix = [];\n  const command = [\n    `--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`,\n    ...customArgs\n  ];\n  const maxCount = opt.n || opt[\"max-count\"] || opt.maxCount;\n  if (maxCount) {\n    command.push(`--max-count=${maxCount}`);\n  }\n  if (opt.from || opt.to) {\n    const rangeOperator = opt.symmetric !== false ? \"...\" : \"..\";\n    suffix.push(`${opt.from || \"\"}${rangeOperator}${opt.to || \"\"}`);\n  }\n  if (filterString(opt.file)) {\n    command.push(\"--follow\", pathspec(opt.file));\n  }\n  appendTaskOptions(userOptions(opt), command);\n  return {\n    fields,\n    splitter,\n    commands: [...command, ...suffix]\n  };\n}\nfunction logTask(splitter, fields, customArgs) {\n  const parser4 = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));\n  return {\n    commands: [\"log\", ...customArgs],\n    format: \"utf-8\",\n    parser: parser4\n  };\n}\nfunction log_default() {\n  return {\n    log(...rest) {\n      const next = trailingFunctionArgument(arguments);\n      const options = parseLogOptions(\n        trailingOptionsArgument(arguments),\n        filterType(arguments[0], filterArray)\n      );\n      const task = rejectDeprecatedSignatures(...rest) || validateLogFormatConfig(options.commands) || createLogTask(options);\n      return this._runTask(task, next);\n    }\n  };\n  function createLogTask(options) {\n    return logTask(options.splitter, options.fields, options.commands);\n  }\n  function rejectDeprecatedSignatures(from, to) {\n    return filterString(from) && filterString(to) && configurationErrorTask(\n      `git.log(string, string) should be replaced with git.log({ from: string, to: string })`\n    );\n  }\n}\nvar excludeOptions;\nvar init_log = __esm({\n  \"src/lib/tasks/log.ts\"() {\n    \"use strict\";\n    init_log_format();\n    init_pathspec();\n    init_parse_list_log_summary();\n    init_utils();\n    init_task();\n    init_diff();\n    excludeOptions = /* @__PURE__ */ ((excludeOptions2) => {\n      excludeOptions2[excludeOptions2[\"--pretty\"] = 0] = \"--pretty\";\n      excludeOptions2[excludeOptions2[\"max-count\"] = 1] = \"max-count\";\n      excludeOptions2[excludeOptions2[\"maxCount\"] = 2] = \"maxCount\";\n      excludeOptions2[excludeOptions2[\"n\"] = 3] = \"n\";\n      excludeOptions2[excludeOptions2[\"file\"] = 4] = \"file\";\n      excludeOptions2[excludeOptions2[\"format\"] = 5] = \"format\";\n      excludeOptions2[excludeOptions2[\"from\"] = 6] = \"from\";\n      excludeOptions2[excludeOptions2[\"to\"] = 7] = \"to\";\n      excludeOptions2[excludeOptions2[\"splitter\"] = 8] = \"splitter\";\n      excludeOptions2[excludeOptions2[\"symmetric\"] = 9] = \"symmetric\";\n      excludeOptions2[excludeOptions2[\"mailMap\"] = 10] = \"mailMap\";\n      excludeOptions2[excludeOptions2[\"multiLine\"] = 11] = \"multiLine\";\n      excludeOptions2[excludeOptions2[\"strictDate\"] = 12] = \"strictDate\";\n      return excludeOptions2;\n    })(excludeOptions || {});\n  }\n});\n\n// src/lib/responses/MergeSummary.ts\nvar MergeSummaryConflict, MergeSummaryDetail;\nvar init_MergeSummary = __esm({\n  \"src/lib/responses/MergeSummary.ts\"() {\n    \"use strict\";\n    MergeSummaryConflict = class {\n      constructor(reason, file = null, meta) {\n        this.reason = reason;\n        this.file = file;\n        this.meta = meta;\n      }\n      toString() {\n        return `${this.file}:${this.reason}`;\n      }\n    };\n    MergeSummaryDetail = class {\n      constructor() {\n        this.conflicts = [];\n        this.merges = [];\n        this.result = \"success\";\n      }\n      get failed() {\n        return this.conflicts.length > 0;\n      }\n      get reason() {\n        return this.result;\n      }\n      toString() {\n        if (this.conflicts.length) {\n          return `CONFLICTS: ${this.conflicts.join(\", \")}`;\n        }\n        return \"OK\";\n      }\n    };\n  }\n});\n\n// src/lib/responses/PullSummary.ts\nvar PullSummary, PullFailedSummary;\nvar init_PullSummary = __esm({\n  \"src/lib/responses/PullSummary.ts\"() {\n    \"use strict\";\n    PullSummary = class {\n      constructor() {\n        this.remoteMessages = {\n          all: []\n        };\n        this.created = [];\n        this.deleted = [];\n        this.files = [];\n        this.deletions = {};\n        this.insertions = {};\n        this.summary = {\n          changes: 0,\n          deletions: 0,\n          insertions: 0\n        };\n      }\n    };\n    PullFailedSummary = class {\n      constructor() {\n        this.remote = \"\";\n        this.hash = {\n          local: \"\",\n          remote: \"\"\n        };\n        this.branch = {\n          local: \"\",\n          remote: \"\"\n        };\n        this.message = \"\";\n      }\n      toString() {\n        return this.message;\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-remote-objects.ts\nfunction objectEnumerationResult(remoteMessages) {\n  return remoteMessages.objects = remoteMessages.objects || {\n    compressing: 0,\n    counting: 0,\n    enumerating: 0,\n    packReused: 0,\n    reused: { count: 0, delta: 0 },\n    total: { count: 0, delta: 0 }\n  };\n}\nfunction asObjectCount(source) {\n  const count = /^\\s*(\\d+)/.exec(source);\n  const delta = /delta (\\d+)/i.exec(source);\n  return {\n    count: asNumber(count && count[1] || \"0\"),\n    delta: asNumber(delta && delta[1] || \"0\")\n  };\n}\nvar remoteMessagesObjectParsers;\nvar init_parse_remote_objects = __esm({\n  \"src/lib/parsers/parse-remote-objects.ts\"() {\n    \"use strict\";\n    init_utils();\n    remoteMessagesObjectParsers = [\n      new RemoteLineParser(\n        /^remote:\\s*(enumerating|counting|compressing) objects: (\\d+),/i,\n        (result, [action, count]) => {\n          const key = action.toLowerCase();\n          const enumeration = objectEnumerationResult(result.remoteMessages);\n          Object.assign(enumeration, { [key]: asNumber(count) });\n        }\n      ),\n      new RemoteLineParser(\n        /^remote:\\s*(enumerating|counting|compressing) objects: \\d+% \\(\\d+\\/(\\d+)\\),/i,\n        (result, [action, count]) => {\n          const key = action.toLowerCase();\n          const enumeration = objectEnumerationResult(result.remoteMessages);\n          Object.assign(enumeration, { [key]: asNumber(count) });\n        }\n      ),\n      new RemoteLineParser(\n        /total ([^,]+), reused ([^,]+), pack-reused (\\d+)/i,\n        (result, [total, reused, packReused]) => {\n          const objects = objectEnumerationResult(result.remoteMessages);\n          objects.total = asObjectCount(total);\n          objects.reused = asObjectCount(reused);\n          objects.packReused = asNumber(packReused);\n        }\n      )\n    ];\n  }\n});\n\n// src/lib/parsers/parse-remote-messages.ts\nfunction parseRemoteMessages(_stdOut, stdErr) {\n  return parseStringResponse({ remoteMessages: new RemoteMessageSummary() }, parsers2, stdErr);\n}\nvar parsers2, RemoteMessageSummary;\nvar init_parse_remote_messages = __esm({\n  \"src/lib/parsers/parse-remote-messages.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_parse_remote_objects();\n    parsers2 = [\n      new RemoteLineParser(/^remote:\\s*(.+)$/, (result, [text]) => {\n        result.remoteMessages.all.push(text.trim());\n        return false;\n      }),\n      ...remoteMessagesObjectParsers,\n      new RemoteLineParser(\n        [/create a (?:pull|merge) request/i, /\\s(https?:\\/\\/\\S+)$/],\n        (result, [pullRequestUrl]) => {\n          result.remoteMessages.pullRequestUrl = pullRequestUrl;\n        }\n      ),\n      new RemoteLineParser(\n        [/found (\\d+) vulnerabilities.+\\(([^)]+)\\)/i, /\\s(https?:\\/\\/\\S+)$/],\n        (result, [count, summary, url]) => {\n          result.remoteMessages.vulnerabilities = {\n            count: asNumber(count),\n            summary,\n            url\n          };\n        }\n      )\n    ];\n    RemoteMessageSummary = class {\n      constructor() {\n        this.all = [];\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-pull.ts\nfunction parsePullErrorResult(stdOut, stdErr) {\n  const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);\n  return pullError.message && pullError;\n}\nvar FILE_UPDATE_REGEX, SUMMARY_REGEX, ACTION_REGEX, parsers3, errorParsers, parsePullDetail, parsePullResult;\nvar init_parse_pull = __esm({\n  \"src/lib/parsers/parse-pull.ts\"() {\n    \"use strict\";\n    init_PullSummary();\n    init_utils();\n    init_parse_remote_messages();\n    FILE_UPDATE_REGEX = /^\\s*(.+?)\\s+\\|\\s+\\d+\\s*(\\+*)(-*)/;\n    SUMMARY_REGEX = /(\\d+)\\D+((\\d+)\\D+\\(\\+\\))?(\\D+(\\d+)\\D+\\(-\\))?/;\n    ACTION_REGEX = /^(create|delete) mode \\d+ (.+)/;\n    parsers3 = [\n      new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {\n        result.files.push(file);\n        if (insertions) {\n          result.insertions[file] = insertions.length;\n        }\n        if (deletions) {\n          result.deletions[file] = deletions.length;\n        }\n      }),\n      new LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {\n        if (insertions !== void 0 || deletions !== void 0) {\n          result.summary.changes = +changes || 0;\n          result.summary.insertions = +insertions || 0;\n          result.summary.deletions = +deletions || 0;\n          return true;\n        }\n        return false;\n      }),\n      new LineParser(ACTION_REGEX, (result, [action, file]) => {\n        append(result.files, file);\n        append(action === \"create\" ? result.created : result.deleted, file);\n      })\n    ];\n    errorParsers = [\n      new LineParser(/^from\\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),\n      new LineParser(/^fatal:\\s(.+)$/, (result, [message]) => void (result.message = message)),\n      new LineParser(\n        /([a-z0-9]+)\\.\\.([a-z0-9]+)\\s+(\\S+)\\s+->\\s+(\\S+)$/,\n        (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {\n          result.branch.local = branchLocal;\n          result.hash.local = hashLocal;\n          result.branch.remote = branchRemote;\n          result.hash.remote = hashRemote;\n        }\n      )\n    ];\n    parsePullDetail = (stdOut, stdErr) => {\n      return parseStringResponse(new PullSummary(), parsers3, [stdOut, stdErr]);\n    };\n    parsePullResult = (stdOut, stdErr) => {\n      return Object.assign(\n        new PullSummary(),\n        parsePullDetail(stdOut, stdErr),\n        parseRemoteMessages(stdOut, stdErr)\n      );\n    };\n  }\n});\n\n// src/lib/parsers/parse-merge.ts\nvar parsers4, parseMergeResult, parseMergeDetail;\nvar init_parse_merge = __esm({\n  \"src/lib/parsers/parse-merge.ts\"() {\n    \"use strict\";\n    init_MergeSummary();\n    init_utils();\n    init_parse_pull();\n    parsers4 = [\n      new LineParser(/^Auto-merging\\s+(.+)$/, (summary, [autoMerge]) => {\n        summary.merges.push(autoMerge);\n      }),\n      new LineParser(/^CONFLICT\\s+\\((.+)\\): Merge conflict in (.+)$/, (summary, [reason, file]) => {\n        summary.conflicts.push(new MergeSummaryConflict(reason, file));\n      }),\n      new LineParser(\n        /^CONFLICT\\s+\\((.+\\/delete)\\): (.+) deleted in (.+) and/,\n        (summary, [reason, file, deleteRef]) => {\n          summary.conflicts.push(new MergeSummaryConflict(reason, file, { deleteRef }));\n        }\n      ),\n      new LineParser(/^CONFLICT\\s+\\((.+)\\):/, (summary, [reason]) => {\n        summary.conflicts.push(new MergeSummaryConflict(reason, null));\n      }),\n      new LineParser(/^Automatic merge failed;\\s+(.+)$/, (summary, [result]) => {\n        summary.result = result;\n      })\n    ];\n    parseMergeResult = (stdOut, stdErr) => {\n      return Object.assign(parseMergeDetail(stdOut, stdErr), parsePullResult(stdOut, stdErr));\n    };\n    parseMergeDetail = (stdOut) => {\n      return parseStringResponse(new MergeSummaryDetail(), parsers4, stdOut);\n    };\n  }\n});\n\n// src/lib/tasks/merge.ts\nfunction mergeTask(customArgs) {\n  if (!customArgs.length) {\n    return configurationErrorTask(\"Git.merge requires at least one option\");\n  }\n  return {\n    commands: [\"merge\", ...customArgs],\n    format: \"utf-8\",\n    parser(stdOut, stdErr) {\n      const merge = parseMergeResult(stdOut, stdErr);\n      if (merge.failed) {\n        throw new GitResponseError(merge);\n      }\n      return merge;\n    }\n  };\n}\nvar init_merge = __esm({\n  \"src/lib/tasks/merge.ts\"() {\n    \"use strict\";\n    init_git_response_error();\n    init_parse_merge();\n    init_task();\n  }\n});\n\n// src/lib/parsers/parse-push.ts\nfunction pushResultPushedItem(local, remote, status) {\n  const deleted = status.includes(\"deleted\");\n  const tag = status.includes(\"tag\") || /^refs\\/tags/.test(local);\n  const alreadyUpdated = !status.includes(\"new\");\n  return {\n    deleted,\n    tag,\n    branch: !tag,\n    new: !alreadyUpdated,\n    alreadyUpdated,\n    local,\n    remote\n  };\n}\nvar parsers5, parsePushResult, parsePushDetail;\nvar init_parse_push = __esm({\n  \"src/lib/parsers/parse-push.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_parse_remote_messages();\n    parsers5 = [\n      new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {\n        result.repo = repo;\n      }),\n      new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {\n        result.ref = __spreadProps(__spreadValues({}, result.ref || {}), {\n          local\n        });\n      }),\n      new LineParser(/^[=*-]\\s+([^:]+):(\\S+)\\s+\\[(.+)]$/, (result, [local, remote, type]) => {\n        result.pushed.push(pushResultPushedItem(local, remote, type));\n      }),\n      new LineParser(\n        /^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/,\n        (result, [local, remote, remoteName]) => {\n          result.branch = __spreadProps(__spreadValues({}, result.branch || {}), {\n            local,\n            remote,\n            remoteName\n          });\n        }\n      ),\n      new LineParser(\n        /^([^:]+):(\\S+)\\s+([a-z0-9]+)\\.\\.([a-z0-9]+)$/,\n        (result, [local, remote, from, to]) => {\n          result.update = {\n            head: {\n              local,\n              remote\n            },\n            hash: {\n              from,\n              to\n            }\n          };\n        }\n      )\n    ];\n    parsePushResult = (stdOut, stdErr) => {\n      const pushDetail = parsePushDetail(stdOut, stdErr);\n      const responseDetail = parseRemoteMessages(stdOut, stdErr);\n      return __spreadValues(__spreadValues({}, pushDetail), responseDetail);\n    };\n    parsePushDetail = (stdOut, stdErr) => {\n      return parseStringResponse({ pushed: [] }, parsers5, [stdOut, stdErr]);\n    };\n  }\n});\n\n// src/lib/tasks/push.ts\nvar push_exports = {};\n__export(push_exports, {\n  pushTagsTask: () => pushTagsTask,\n  pushTask: () => pushTask\n});\nfunction pushTagsTask(ref = {}, customArgs) {\n  append(customArgs, \"--tags\");\n  return pushTask(ref, customArgs);\n}\nfunction pushTask(ref = {}, customArgs) {\n  const commands = [\"push\", ...customArgs];\n  if (ref.branch) {\n    commands.splice(1, 0, ref.branch);\n  }\n  if (ref.remote) {\n    commands.splice(1, 0, ref.remote);\n  }\n  remove(commands, \"-v\");\n  append(commands, \"--verbose\");\n  append(commands, \"--porcelain\");\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: parsePushResult\n  };\n}\nvar init_push = __esm({\n  \"src/lib/tasks/push.ts\"() {\n    \"use strict\";\n    init_parse_push();\n    init_utils();\n  }\n});\n\n// src/lib/tasks/show.ts\nfunction show_default() {\n  return {\n    showBuffer() {\n      const commands = [\"show\", ...getTrailingOptions(arguments, 1)];\n      if (!commands.includes(\"--binary\")) {\n        commands.splice(1, 0, \"--binary\");\n      }\n      return this._runTask(\n        straightThroughBufferTask(commands),\n        trailingFunctionArgument(arguments)\n      );\n    },\n    show() {\n      const commands = [\"show\", ...getTrailingOptions(arguments, 1)];\n      return this._runTask(\n        straightThroughStringTask(commands),\n        trailingFunctionArgument(arguments)\n      );\n    }\n  };\n}\nvar init_show = __esm({\n  \"src/lib/tasks/show.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_task();\n  }\n});\n\n// src/lib/responses/FileStatusSummary.ts\nvar fromPathRegex, FileStatusSummary;\nvar init_FileStatusSummary = __esm({\n  \"src/lib/responses/FileStatusSummary.ts\"() {\n    \"use strict\";\n    fromPathRegex = /^(.+)\\0(.+)$/;\n    FileStatusSummary = class {\n      constructor(path, index, working_dir) {\n        this.path = path;\n        this.index = index;\n        this.working_dir = working_dir;\n        if (index === \"R\" || working_dir === \"R\") {\n          const detail = fromPathRegex.exec(path) || [null, path, path];\n          this.from = detail[2] || \"\";\n          this.path = detail[1] || \"\";\n        }\n      }\n    };\n  }\n});\n\n// src/lib/responses/StatusSummary.ts\nfunction renamedFile(line) {\n  const [to, from] = line.split(NULL);\n  return {\n    from: from || to,\n    to\n  };\n}\nfunction parser3(indexX, indexY, handler) {\n  return [`${indexX}${indexY}`, handler];\n}\nfunction conflicts(indexX, ...indexY) {\n  return indexY.map((y) => parser3(indexX, y, (result, file) => append(result.conflicted, file)));\n}\nfunction splitLine(result, lineStr) {\n  const trimmed2 = lineStr.trim();\n  switch (\" \") {\n    case trimmed2.charAt(2):\n      return data(trimmed2.charAt(0), trimmed2.charAt(1), trimmed2.substr(3));\n    case trimmed2.charAt(1):\n      return data(\" \" /* NONE */, trimmed2.charAt(0), trimmed2.substr(2));\n    default:\n      return;\n  }\n  function data(index, workingDir, path) {\n    const raw = `${index}${workingDir}`;\n    const handler = parsers6.get(raw);\n    if (handler) {\n      handler(result, path);\n    }\n    if (raw !== \"##\" && raw !== \"!!\") {\n      result.files.push(new FileStatusSummary(path, index, workingDir));\n    }\n  }\n}\nvar StatusSummary, parsers6, parseStatusSummary;\nvar init_StatusSummary = __esm({\n  \"src/lib/responses/StatusSummary.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_FileStatusSummary();\n    StatusSummary = class {\n      constructor() {\n        this.not_added = [];\n        this.conflicted = [];\n        this.created = [];\n        this.deleted = [];\n        this.ignored = void 0;\n        this.modified = [];\n        this.renamed = [];\n        this.files = [];\n        this.staged = [];\n        this.ahead = 0;\n        this.behind = 0;\n        this.current = null;\n        this.tracking = null;\n        this.detached = false;\n        this.isClean = () => {\n          return !this.files.length;\n        };\n      }\n    };\n    parsers6 = new Map([\n      parser3(\n        \" \" /* NONE */,\n        \"A\" /* ADDED */,\n        (result, file) => append(result.created, file)\n      ),\n      parser3(\n        \" \" /* NONE */,\n        \"D\" /* DELETED */,\n        (result, file) => append(result.deleted, file)\n      ),\n      parser3(\n        \" \" /* NONE */,\n        \"M\" /* MODIFIED */,\n        (result, file) => append(result.modified, file)\n      ),\n      parser3(\n        \"A\" /* ADDED */,\n        \" \" /* NONE */,\n        (result, file) => append(result.created, file) && append(result.staged, file)\n      ),\n      parser3(\n        \"A\" /* ADDED */,\n        \"M\" /* MODIFIED */,\n        (result, file) => append(result.created, file) && append(result.staged, file) && append(result.modified, file)\n      ),\n      parser3(\n        \"D\" /* DELETED */,\n        \" \" /* NONE */,\n        (result, file) => append(result.deleted, file) && append(result.staged, file)\n      ),\n      parser3(\n        \"M\" /* MODIFIED */,\n        \" \" /* NONE */,\n        (result, file) => append(result.modified, file) && append(result.staged, file)\n      ),\n      parser3(\n        \"M\" /* MODIFIED */,\n        \"M\" /* MODIFIED */,\n        (result, file) => append(result.modified, file) && append(result.staged, file)\n      ),\n      parser3(\"R\" /* RENAMED */, \" \" /* NONE */, (result, file) => {\n        append(result.renamed, renamedFile(file));\n      }),\n      parser3(\"R\" /* RENAMED */, \"M\" /* MODIFIED */, (result, file) => {\n        const renamed = renamedFile(file);\n        append(result.renamed, renamed);\n        append(result.modified, renamed.to);\n      }),\n      parser3(\"!\" /* IGNORED */, \"!\" /* IGNORED */, (_result, _file) => {\n        append(_result.ignored = _result.ignored || [], _file);\n      }),\n      parser3(\n        \"?\" /* UNTRACKED */,\n        \"?\" /* UNTRACKED */,\n        (result, file) => append(result.not_added, file)\n      ),\n      ...conflicts(\"A\" /* ADDED */, \"A\" /* ADDED */, \"U\" /* UNMERGED */),\n      ...conflicts(\n        \"D\" /* DELETED */,\n        \"D\" /* DELETED */,\n        \"U\" /* UNMERGED */\n      ),\n      ...conflicts(\n        \"U\" /* UNMERGED */,\n        \"A\" /* ADDED */,\n        \"D\" /* DELETED */,\n        \"U\" /* UNMERGED */\n      ),\n      [\n        \"##\",\n        (result, line) => {\n          const aheadReg = /ahead (\\d+)/;\n          const behindReg = /behind (\\d+)/;\n          const currentReg = /^(.+?(?=(?:\\.{3}|\\s|$)))/;\n          const trackingReg = /\\.{3}(\\S*)/;\n          const onEmptyBranchReg = /\\son\\s([\\S]+)$/;\n          let regexResult;\n          regexResult = aheadReg.exec(line);\n          result.ahead = regexResult && +regexResult[1] || 0;\n          regexResult = behindReg.exec(line);\n          result.behind = regexResult && +regexResult[1] || 0;\n          regexResult = currentReg.exec(line);\n          result.current = regexResult && regexResult[1];\n          regexResult = trackingReg.exec(line);\n          result.tracking = regexResult && regexResult[1];\n          regexResult = onEmptyBranchReg.exec(line);\n          result.current = regexResult && regexResult[1] || result.current;\n          result.detached = /\\(no branch\\)/.test(line);\n        }\n      ]\n    ]);\n    parseStatusSummary = function(text) {\n      const lines = text.split(NULL);\n      const status = new StatusSummary();\n      for (let i = 0, l = lines.length; i < l; ) {\n        let line = lines[i++].trim();\n        if (!line) {\n          continue;\n        }\n        if (line.charAt(0) === \"R\" /* RENAMED */) {\n          line += NULL + (lines[i++] || \"\");\n        }\n        splitLine(status, line);\n      }\n      return status;\n    };\n  }\n});\n\n// src/lib/tasks/status.ts\nfunction statusTask(customArgs) {\n  const commands = [\n    \"status\",\n    \"--porcelain\",\n    \"-b\",\n    \"-u\",\n    \"--null\",\n    ...customArgs.filter((arg) => !ignoredOptions.includes(arg))\n  ];\n  return {\n    format: \"utf-8\",\n    commands,\n    parser(text) {\n      return parseStatusSummary(text);\n    }\n  };\n}\nvar ignoredOptions;\nvar init_status = __esm({\n  \"src/lib/tasks/status.ts\"() {\n    \"use strict\";\n    init_StatusSummary();\n    ignoredOptions = [\"--null\", \"-z\"];\n  }\n});\n\n// src/lib/tasks/version.ts\nfunction versionResponse(major = 0, minor = 0, patch = 0, agent = \"\", installed = true) {\n  return Object.defineProperty(\n    {\n      major,\n      minor,\n      patch,\n      agent,\n      installed\n    },\n    \"toString\",\n    {\n      value() {\n        return `${this.major}.${this.minor}.${this.patch}`;\n      },\n      configurable: false,\n      enumerable: false\n    }\n  );\n}\nfunction notInstalledResponse() {\n  return versionResponse(0, 0, 0, \"\", false);\n}\nfunction version_default() {\n  return {\n    version() {\n      return this._runTask({\n        commands: [\"--version\"],\n        format: \"utf-8\",\n        parser: versionParser,\n        onError(result, error, done, fail) {\n          if (result.exitCode === -2 /* NOT_FOUND */) {\n            return done(Buffer.from(NOT_INSTALLED));\n          }\n          fail(error);\n        }\n      });\n    }\n  };\n}\nfunction versionParser(stdOut) {\n  if (stdOut === NOT_INSTALLED) {\n    return notInstalledResponse();\n  }\n  return parseStringResponse(versionResponse(0, 0, 0, stdOut), parsers7, stdOut);\n}\nvar NOT_INSTALLED, parsers7;\nvar init_version = __esm({\n  \"src/lib/tasks/version.ts\"() {\n    \"use strict\";\n    init_utils();\n    NOT_INSTALLED = \"installed=false\";\n    parsers7 = [\n      new LineParser(\n        /version (\\d+)\\.(\\d+)\\.(\\d+)(?:\\s*\\((.+)\\))?/,\n        (result, [major, minor, patch, agent = \"\"]) => {\n          Object.assign(\n            result,\n            versionResponse(asNumber(major), asNumber(minor), asNumber(patch), agent)\n          );\n        }\n      ),\n      new LineParser(\n        /version (\\d+)\\.(\\d+)\\.(\\D+)(.+)?$/,\n        (result, [major, minor, patch, agent = \"\"]) => {\n          Object.assign(result, versionResponse(asNumber(major), asNumber(minor), patch, agent));\n        }\n      )\n    ];\n  }\n});\n\n// src/lib/simple-git-api.ts\nvar simple_git_api_exports = {};\n__export(simple_git_api_exports, {\n  SimpleGitApi: () => SimpleGitApi\n});\nvar SimpleGitApi;\nvar init_simple_git_api = __esm({\n  \"src/lib/simple-git-api.ts\"() {\n    \"use strict\";\n    init_task_callback();\n    init_change_working_directory();\n    init_checkout();\n    init_count_objects();\n    init_commit();\n    init_config();\n    init_first_commit();\n    init_grep();\n    init_hash_object();\n    init_init();\n    init_log();\n    init_merge();\n    init_push();\n    init_show();\n    init_status();\n    init_task();\n    init_version();\n    init_utils();\n    SimpleGitApi = class {\n      constructor(_executor) {\n        this._executor = _executor;\n      }\n      _runTask(task, then) {\n        const chain = this._executor.chain();\n        const promise = chain.push(task);\n        if (then) {\n          taskCallback(task, promise, then);\n        }\n        return Object.create(this, {\n          then: { value: promise.then.bind(promise) },\n          catch: { value: promise.catch.bind(promise) },\n          _executor: { value: chain }\n        });\n      }\n      add(files) {\n        return this._runTask(\n          straightThroughStringTask([\"add\", ...asArray(files)]),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      cwd(directory) {\n        const next = trailingFunctionArgument(arguments);\n        if (typeof directory === \"string\") {\n          return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);\n        }\n        if (typeof (directory == null ? void 0 : directory.path) === \"string\") {\n          return this._runTask(\n            changeWorkingDirectoryTask(\n              directory.path,\n              directory.root && this._executor || void 0\n            ),\n            next\n          );\n        }\n        return this._runTask(\n          configurationErrorTask(\"Git.cwd: workingDirectory must be supplied as a string\"),\n          next\n        );\n      }\n      hashObject(path, write) {\n        return this._runTask(\n          hashObjectTask(path, write === true),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      init(bare) {\n        return this._runTask(\n          initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      merge() {\n        return this._runTask(\n          mergeTask(getTrailingOptions(arguments)),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      mergeFromTo(remote, branch) {\n        if (!(filterString(remote) && filterString(branch))) {\n          return this._runTask(\n            configurationErrorTask(\n              `Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`\n            )\n          );\n        }\n        return this._runTask(\n          mergeTask([remote, branch, ...getTrailingOptions(arguments)]),\n          trailingFunctionArgument(arguments, false)\n        );\n      }\n      outputHandler(handler) {\n        this._executor.outputHandler = handler;\n        return this;\n      }\n      push() {\n        const task = pushTask(\n          {\n            remote: filterType(arguments[0], filterString),\n            branch: filterType(arguments[1], filterString)\n          },\n          getTrailingOptions(arguments)\n        );\n        return this._runTask(task, trailingFunctionArgument(arguments));\n      }\n      stash() {\n        return this._runTask(\n          straightThroughStringTask([\"stash\", ...getTrailingOptions(arguments)]),\n          trailingFunctionArgument(arguments)\n        );\n      }\n      status() {\n        return this._runTask(\n          statusTask(getTrailingOptions(arguments)),\n          trailingFunctionArgument(arguments)\n        );\n      }\n    };\n    Object.assign(\n      SimpleGitApi.prototype,\n      checkout_default(),\n      commit_default(),\n      config_default(),\n      count_objects_default(),\n      first_commit_default(),\n      grep_default(),\n      log_default(),\n      show_default(),\n      version_default()\n    );\n  }\n});\n\n// src/lib/runners/scheduler.ts\nvar scheduler_exports = {};\n__export(scheduler_exports, {\n  Scheduler: () => Scheduler\n});\n\nvar createScheduledTask, Scheduler;\nvar init_scheduler = __esm({\n  \"src/lib/runners/scheduler.ts\"() {\n    \"use strict\";\n    init_utils();\n    init_git_logger();\n    createScheduledTask = (() => {\n      let id = 0;\n      return () => {\n        id++;\n        const { promise, done } = (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_3__.createDeferred)();\n        return {\n          promise,\n          done,\n          id\n        };\n      };\n    })();\n    Scheduler = class {\n      constructor(concurrency = 2) {\n        this.concurrency = concurrency;\n        this.logger = createLogger(\"\", \"scheduler\");\n        this.pending = [];\n        this.running = [];\n        this.logger(`Constructed, concurrency=%s`, concurrency);\n      }\n      schedule() {\n        if (!this.pending.length || this.running.length >= this.concurrency) {\n          this.logger(\n            `Schedule attempt ignored, pending=%s running=%s concurrency=%s`,\n            this.pending.length,\n            this.running.length,\n            this.concurrency\n          );\n          return;\n        }\n        const task = append(this.running, this.pending.shift());\n        this.logger(`Attempting id=%s`, task.id);\n        task.done(() => {\n          this.logger(`Completing id=`, task.id);\n          remove(this.running, task);\n          this.schedule();\n        });\n      }\n      next() {\n        const { promise, id } = append(this.pending, createScheduledTask());\n        this.logger(`Scheduling id=%s`, id);\n        this.schedule();\n        return promise;\n      }\n    };\n  }\n});\n\n// src/lib/tasks/apply-patch.ts\nvar apply_patch_exports = {};\n__export(apply_patch_exports, {\n  applyPatchTask: () => applyPatchTask\n});\nfunction applyPatchTask(patches, customArgs) {\n  return straightThroughStringTask([\"apply\", ...customArgs, ...patches]);\n}\nvar init_apply_patch = __esm({\n  \"src/lib/tasks/apply-patch.ts\"() {\n    \"use strict\";\n    init_task();\n  }\n});\n\n// src/lib/responses/BranchDeleteSummary.ts\nfunction branchDeletionSuccess(branch, hash) {\n  return {\n    branch,\n    hash,\n    success: true\n  };\n}\nfunction branchDeletionFailure(branch) {\n  return {\n    branch,\n    hash: null,\n    success: false\n  };\n}\nvar BranchDeletionBatch;\nvar init_BranchDeleteSummary = __esm({\n  \"src/lib/responses/BranchDeleteSummary.ts\"() {\n    \"use strict\";\n    BranchDeletionBatch = class {\n      constructor() {\n        this.all = [];\n        this.branches = {};\n        this.errors = [];\n      }\n      get success() {\n        return !this.errors.length;\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-branch-delete.ts\nfunction hasBranchDeletionError(data, processExitCode) {\n  return processExitCode === 1 /* ERROR */ && deleteErrorRegex.test(data);\n}\nvar deleteSuccessRegex, deleteErrorRegex, parsers8, parseBranchDeletions;\nvar init_parse_branch_delete = __esm({\n  \"src/lib/parsers/parse-branch-delete.ts\"() {\n    \"use strict\";\n    init_BranchDeleteSummary();\n    init_utils();\n    deleteSuccessRegex = /(\\S+)\\s+\\(\\S+\\s([^)]+)\\)/;\n    deleteErrorRegex = /^error[^']+'([^']+)'/m;\n    parsers8 = [\n      new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {\n        const deletion = branchDeletionSuccess(branch, hash);\n        result.all.push(deletion);\n        result.branches[branch] = deletion;\n      }),\n      new LineParser(deleteErrorRegex, (result, [branch]) => {\n        const deletion = branchDeletionFailure(branch);\n        result.errors.push(deletion);\n        result.all.push(deletion);\n        result.branches[branch] = deletion;\n      })\n    ];\n    parseBranchDeletions = (stdOut, stdErr) => {\n      return parseStringResponse(new BranchDeletionBatch(), parsers8, [stdOut, stdErr]);\n    };\n  }\n});\n\n// src/lib/responses/BranchSummary.ts\nvar BranchSummaryResult;\nvar init_BranchSummary = __esm({\n  \"src/lib/responses/BranchSummary.ts\"() {\n    \"use strict\";\n    BranchSummaryResult = class {\n      constructor() {\n        this.all = [];\n        this.branches = {};\n        this.current = \"\";\n        this.detached = false;\n      }\n      push(status, detached, name, commit, label) {\n        if (status === \"*\" /* CURRENT */) {\n          this.detached = detached;\n          this.current = name;\n        }\n        this.all.push(name);\n        this.branches[name] = {\n          current: status === \"*\" /* CURRENT */,\n          linkedWorkTree: status === \"+\" /* LINKED */,\n          name,\n          commit,\n          label\n        };\n      }\n    };\n  }\n});\n\n// src/lib/parsers/parse-branch.ts\nfunction branchStatus(input) {\n  return input ? input.charAt(0) : \"\";\n}\nfunction parseBranchSummary(stdOut) {\n  return parseStringResponse(new BranchSummaryResult(), parsers9, stdOut);\n}\nvar parsers9;\nvar init_parse_branch = __esm({\n  \"src/lib/parsers/parse-branch.ts\"() {\n    \"use strict\";\n    init_BranchSummary();\n    init_utils();\n    parsers9 = [\n      new LineParser(\n        /^([*+]\\s)?\\((?:HEAD )?detached (?:from|at) (\\S+)\\)\\s+([a-z0-9]+)\\s(.*)$/,\n        (result, [current, name, commit, label]) => {\n          result.push(branchStatus(current), true, name, commit, label);\n        }\n      ),\n      new LineParser(\n        new RegExp(\"^([*+]\\\\s)?(\\\\S+)\\\\s+([a-z0-9]+)\\\\s?(.*)$\", \"s\"),\n        (result, [current, name, commit, label]) => {\n          result.push(branchStatus(current), false, name, commit, label);\n        }\n      )\n    ];\n  }\n});\n\n// src/lib/tasks/branch.ts\nvar branch_exports = {};\n__export(branch_exports, {\n  branchLocalTask: () => branchLocalTask,\n  branchTask: () => branchTask,\n  containsDeleteBranchCommand: () => containsDeleteBranchCommand,\n  deleteBranchTask: () => deleteBranchTask,\n  deleteBranchesTask: () => deleteBranchesTask\n});\nfunction containsDeleteBranchCommand(commands) {\n  const deleteCommands = [\"-d\", \"-D\", \"--delete\"];\n  return commands.some((command) => deleteCommands.includes(command));\n}\nfunction branchTask(customArgs) {\n  const isDelete = containsDeleteBranchCommand(customArgs);\n  const commands = [\"branch\", ...customArgs];\n  if (commands.length === 1) {\n    commands.push(\"-a\");\n  }\n  if (!commands.includes(\"-v\")) {\n    commands.splice(1, 0, \"-v\");\n  }\n  return {\n    format: \"utf-8\",\n    commands,\n    parser(stdOut, stdErr) {\n      if (isDelete) {\n        return parseBranchDeletions(stdOut, stdErr).all[0];\n      }\n      return parseBranchSummary(stdOut);\n    }\n  };\n}\nfunction branchLocalTask() {\n  const parser4 = parseBranchSummary;\n  return {\n    format: \"utf-8\",\n    commands: [\"branch\", \"-v\"],\n    parser: parser4\n  };\n}\nfunction deleteBranchesTask(branches, forceDelete = false) {\n  return {\n    format: \"utf-8\",\n    commands: [\"branch\", \"-v\", forceDelete ? \"-D\" : \"-d\", ...branches],\n    parser(stdOut, stdErr) {\n      return parseBranchDeletions(stdOut, stdErr);\n    },\n    onError({ exitCode, stdOut }, error, done, fail) {\n      if (!hasBranchDeletionError(String(error), exitCode)) {\n        return fail(error);\n      }\n      done(stdOut);\n    }\n  };\n}\nfunction deleteBranchTask(branch, forceDelete = false) {\n  const task = {\n    format: \"utf-8\",\n    commands: [\"branch\", \"-v\", forceDelete ? \"-D\" : \"-d\", branch],\n    parser(stdOut, stdErr) {\n      return parseBranchDeletions(stdOut, stdErr).branches[branch];\n    },\n    onError({ exitCode, stdErr, stdOut }, error, _, fail) {\n      if (!hasBranchDeletionError(String(error), exitCode)) {\n        return fail(error);\n      }\n      throw new GitResponseError(\n        task.parser(bufferToString(stdOut), bufferToString(stdErr)),\n        String(error)\n      );\n    }\n  };\n  return task;\n}\nvar init_branch = __esm({\n  \"src/lib/tasks/branch.ts\"() {\n    \"use strict\";\n    init_git_response_error();\n    init_parse_branch_delete();\n    init_parse_branch();\n    init_utils();\n  }\n});\n\n// src/lib/responses/CheckIgnore.ts\nvar parseCheckIgnore;\nvar init_CheckIgnore = __esm({\n  \"src/lib/responses/CheckIgnore.ts\"() {\n    \"use strict\";\n    parseCheckIgnore = (text) => {\n      return text.split(/\\n/g).map((line) => line.trim()).filter((file) => !!file);\n    };\n  }\n});\n\n// src/lib/tasks/check-ignore.ts\nvar check_ignore_exports = {};\n__export(check_ignore_exports, {\n  checkIgnoreTask: () => checkIgnoreTask\n});\nfunction checkIgnoreTask(paths) {\n  return {\n    commands: [\"check-ignore\", ...paths],\n    format: \"utf-8\",\n    parser: parseCheckIgnore\n  };\n}\nvar init_check_ignore = __esm({\n  \"src/lib/tasks/check-ignore.ts\"() {\n    \"use strict\";\n    init_CheckIgnore();\n  }\n});\n\n// src/lib/tasks/clone.ts\nvar clone_exports = {};\n__export(clone_exports, {\n  cloneMirrorTask: () => cloneMirrorTask,\n  cloneTask: () => cloneTask\n});\nfunction disallowedCommand(command) {\n  return /^--upload-pack(=|$)/.test(command);\n}\nfunction cloneTask(repo, directory, customArgs) {\n  const commands = [\"clone\", ...customArgs];\n  filterString(repo) && commands.push(repo);\n  filterString(directory) && commands.push(directory);\n  const banned = commands.find(disallowedCommand);\n  if (banned) {\n    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n  }\n  return straightThroughStringTask(commands);\n}\nfunction cloneMirrorTask(repo, directory, customArgs) {\n  append(customArgs, \"--mirror\");\n  return cloneTask(repo, directory, customArgs);\n}\nvar init_clone = __esm({\n  \"src/lib/tasks/clone.ts\"() {\n    \"use strict\";\n    init_task();\n    init_utils();\n  }\n});\n\n// src/lib/parsers/parse-fetch.ts\nfunction parseFetchResult(stdOut, stdErr) {\n  const result = {\n    raw: stdOut,\n    remote: null,\n    branches: [],\n    tags: [],\n    updated: [],\n    deleted: []\n  };\n  return parseStringResponse(result, parsers10, [stdOut, stdErr]);\n}\nvar parsers10;\nvar init_parse_fetch = __esm({\n  \"src/lib/parsers/parse-fetch.ts\"() {\n    \"use strict\";\n    init_utils();\n    parsers10 = [\n      new LineParser(/From (.+)$/, (result, [remote]) => {\n        result.remote = remote;\n      }),\n      new LineParser(/\\* \\[new branch]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) => {\n        result.branches.push({\n          name,\n          tracking\n        });\n      }),\n      new LineParser(/\\* \\[new tag]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) => {\n        result.tags.push({\n          name,\n          tracking\n        });\n      }),\n      new LineParser(/- \\[deleted]\\s+\\S+\\s*-> (.+)$/, (result, [tracking]) => {\n        result.deleted.push({\n          tracking\n        });\n      }),\n      new LineParser(\n        /\\s*([^.]+)\\.\\.(\\S+)\\s+(\\S+)\\s*-> (.+)$/,\n        (result, [from, to, name, tracking]) => {\n          result.updated.push({\n            name,\n            tracking,\n            to,\n            from\n          });\n        }\n      )\n    ];\n  }\n});\n\n// src/lib/tasks/fetch.ts\nvar fetch_exports = {};\n__export(fetch_exports, {\n  fetchTask: () => fetchTask\n});\nfunction disallowedCommand2(command) {\n  return /^--upload-pack(=|$)/.test(command);\n}\nfunction fetchTask(remote, branch, customArgs) {\n  const commands = [\"fetch\", ...customArgs];\n  if (remote && branch) {\n    commands.push(remote, branch);\n  }\n  const banned = commands.find(disallowedCommand2);\n  if (banned) {\n    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: parseFetchResult\n  };\n}\nvar init_fetch = __esm({\n  \"src/lib/tasks/fetch.ts\"() {\n    \"use strict\";\n    init_parse_fetch();\n    init_task();\n  }\n});\n\n// src/lib/parsers/parse-move.ts\nfunction parseMoveResult(stdOut) {\n  return parseStringResponse({ moves: [] }, parsers11, stdOut);\n}\nvar parsers11;\nvar init_parse_move = __esm({\n  \"src/lib/parsers/parse-move.ts\"() {\n    \"use strict\";\n    init_utils();\n    parsers11 = [\n      new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {\n        result.moves.push({ from, to });\n      })\n    ];\n  }\n});\n\n// src/lib/tasks/move.ts\nvar move_exports = {};\n__export(move_exports, {\n  moveTask: () => moveTask\n});\nfunction moveTask(from, to) {\n  return {\n    commands: [\"mv\", \"-v\", ...asArray(from), to],\n    format: \"utf-8\",\n    parser: parseMoveResult\n  };\n}\nvar init_move = __esm({\n  \"src/lib/tasks/move.ts\"() {\n    \"use strict\";\n    init_parse_move();\n    init_utils();\n  }\n});\n\n// src/lib/tasks/pull.ts\nvar pull_exports = {};\n__export(pull_exports, {\n  pullTask: () => pullTask\n});\nfunction pullTask(remote, branch, customArgs) {\n  const commands = [\"pull\", ...customArgs];\n  if (remote && branch) {\n    commands.splice(1, 0, remote, branch);\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser(stdOut, stdErr) {\n      return parsePullResult(stdOut, stdErr);\n    },\n    onError(result, _error, _done, fail) {\n      const pullError = parsePullErrorResult(\n        bufferToString(result.stdOut),\n        bufferToString(result.stdErr)\n      );\n      if (pullError) {\n        return fail(new GitResponseError(pullError));\n      }\n      fail(_error);\n    }\n  };\n}\nvar init_pull = __esm({\n  \"src/lib/tasks/pull.ts\"() {\n    \"use strict\";\n    init_git_response_error();\n    init_parse_pull();\n    init_utils();\n  }\n});\n\n// src/lib/responses/GetRemoteSummary.ts\nfunction parseGetRemotes(text) {\n  const remotes = {};\n  forEach(text, ([name]) => remotes[name] = { name });\n  return Object.values(remotes);\n}\nfunction parseGetRemotesVerbose(text) {\n  const remotes = {};\n  forEach(text, ([name, url, purpose]) => {\n    if (!remotes.hasOwnProperty(name)) {\n      remotes[name] = {\n        name,\n        refs: { fetch: \"\", push: \"\" }\n      };\n    }\n    if (purpose && url) {\n      remotes[name].refs[purpose.replace(/[^a-z]/g, \"\")] = url;\n    }\n  });\n  return Object.values(remotes);\n}\nfunction forEach(text, handler) {\n  forEachLineWithContent(text, (line) => handler(line.split(/\\s+/)));\n}\nvar init_GetRemoteSummary = __esm({\n  \"src/lib/responses/GetRemoteSummary.ts\"() {\n    \"use strict\";\n    init_utils();\n  }\n});\n\n// src/lib/tasks/remote.ts\nvar remote_exports = {};\n__export(remote_exports, {\n  addRemoteTask: () => addRemoteTask,\n  getRemotesTask: () => getRemotesTask,\n  listRemotesTask: () => listRemotesTask,\n  remoteTask: () => remoteTask,\n  removeRemoteTask: () => removeRemoteTask\n});\nfunction addRemoteTask(remoteName, remoteRepo, customArgs) {\n  return straightThroughStringTask([\"remote\", \"add\", ...customArgs, remoteName, remoteRepo]);\n}\nfunction getRemotesTask(verbose) {\n  const commands = [\"remote\"];\n  if (verbose) {\n    commands.push(\"-v\");\n  }\n  return {\n    commands,\n    format: \"utf-8\",\n    parser: verbose ? parseGetRemotesVerbose : parseGetRemotes\n  };\n}\nfunction listRemotesTask(customArgs) {\n  const commands = [...customArgs];\n  if (commands[0] !== \"ls-remote\") {\n    commands.unshift(\"ls-remote\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction remoteTask(customArgs) {\n  const commands = [...customArgs];\n  if (commands[0] !== \"remote\") {\n    commands.unshift(\"remote\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction removeRemoteTask(remoteName) {\n  return straightThroughStringTask([\"remote\", \"remove\", remoteName]);\n}\nvar init_remote = __esm({\n  \"src/lib/tasks/remote.ts\"() {\n    \"use strict\";\n    init_GetRemoteSummary();\n    init_task();\n  }\n});\n\n// src/lib/tasks/stash-list.ts\nvar stash_list_exports = {};\n__export(stash_list_exports, {\n  stashListTask: () => stashListTask\n});\nfunction stashListTask(opt = {}, customArgs) {\n  const options = parseLogOptions(opt);\n  const commands = [\"stash\", \"list\", ...options.commands, ...customArgs];\n  const parser4 = createListLogSummaryParser(\n    options.splitter,\n    options.fields,\n    logFormatFromCommand(commands)\n  );\n  return validateLogFormatConfig(commands) || {\n    commands,\n    format: \"utf-8\",\n    parser: parser4\n  };\n}\nvar init_stash_list = __esm({\n  \"src/lib/tasks/stash-list.ts\"() {\n    \"use strict\";\n    init_log_format();\n    init_parse_list_log_summary();\n    init_diff();\n    init_log();\n  }\n});\n\n// src/lib/tasks/sub-module.ts\nvar sub_module_exports = {};\n__export(sub_module_exports, {\n  addSubModuleTask: () => addSubModuleTask,\n  initSubModuleTask: () => initSubModuleTask,\n  subModuleTask: () => subModuleTask,\n  updateSubModuleTask: () => updateSubModuleTask\n});\nfunction addSubModuleTask(repo, path) {\n  return subModuleTask([\"add\", repo, path]);\n}\nfunction initSubModuleTask(customArgs) {\n  return subModuleTask([\"init\", ...customArgs]);\n}\nfunction subModuleTask(customArgs) {\n  const commands = [...customArgs];\n  if (commands[0] !== \"submodule\") {\n    commands.unshift(\"submodule\");\n  }\n  return straightThroughStringTask(commands);\n}\nfunction updateSubModuleTask(customArgs) {\n  return subModuleTask([\"update\", ...customArgs]);\n}\nvar init_sub_module = __esm({\n  \"src/lib/tasks/sub-module.ts\"() {\n    \"use strict\";\n    init_task();\n  }\n});\n\n// src/lib/responses/TagList.ts\nfunction singleSorted(a, b) {\n  const aIsNum = isNaN(a);\n  const bIsNum = isNaN(b);\n  if (aIsNum !== bIsNum) {\n    return aIsNum ? 1 : -1;\n  }\n  return aIsNum ? sorted(a, b) : 0;\n}\nfunction sorted(a, b) {\n  return a === b ? 0 : a > b ? 1 : -1;\n}\nfunction trimmed(input) {\n  return input.trim();\n}\nfunction toNumber(input) {\n  if (typeof input === \"string\") {\n    return parseInt(input.replace(/^\\D+/g, \"\"), 10) || 0;\n  }\n  return 0;\n}\nvar TagList, parseTagList;\nvar init_TagList = __esm({\n  \"src/lib/responses/TagList.ts\"() {\n    \"use strict\";\n    TagList = class {\n      constructor(all, latest) {\n        this.all = all;\n        this.latest = latest;\n      }\n    };\n    parseTagList = function(data, customSort = false) {\n      const tags = data.split(\"\\n\").map(trimmed).filter(Boolean);\n      if (!customSort) {\n        tags.sort(function(tagA, tagB) {\n          const partsA = tagA.split(\".\");\n          const partsB = tagB.split(\".\");\n          if (partsA.length === 1 || partsB.length === 1) {\n            return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));\n          }\n          for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {\n            const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));\n            if (diff) {\n              return diff;\n            }\n          }\n          return 0;\n        });\n      }\n      const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf(\".\") >= 0);\n      return new TagList(tags, latest);\n    };\n  }\n});\n\n// src/lib/tasks/tag.ts\nvar tag_exports = {};\n__export(tag_exports, {\n  addAnnotatedTagTask: () => addAnnotatedTagTask,\n  addTagTask: () => addTagTask,\n  tagListTask: () => tagListTask\n});\nfunction tagListTask(customArgs = []) {\n  const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));\n  return {\n    format: \"utf-8\",\n    commands: [\"tag\", \"-l\", ...customArgs],\n    parser(text) {\n      return parseTagList(text, hasCustomSort);\n    }\n  };\n}\nfunction addTagTask(name) {\n  return {\n    format: \"utf-8\",\n    commands: [\"tag\", name],\n    parser() {\n      return { name };\n    }\n  };\n}\nfunction addAnnotatedTagTask(name, tagMessage) {\n  return {\n    format: \"utf-8\",\n    commands: [\"tag\", \"-a\", \"-m\", tagMessage, name],\n    parser() {\n      return { name };\n    }\n  };\n}\nvar init_tag = __esm({\n  \"src/lib/tasks/tag.ts\"() {\n    \"use strict\";\n    init_TagList();\n  }\n});\n\n// src/git.js\nvar require_git = __commonJS({\n  \"src/git.js\"(exports, module) {\n    \"use strict\";\n    var { GitExecutor: GitExecutor2 } = (init_git_executor(), __toCommonJS(git_executor_exports));\n    var { SimpleGitApi: SimpleGitApi2 } = (init_simple_git_api(), __toCommonJS(simple_git_api_exports));\n    var { Scheduler: Scheduler2 } = (init_scheduler(), __toCommonJS(scheduler_exports));\n    var { configurationErrorTask: configurationErrorTask2 } = (init_task(), __toCommonJS(task_exports));\n    var {\n      asArray: asArray2,\n      filterArray: filterArray2,\n      filterPrimitives: filterPrimitives2,\n      filterString: filterString2,\n      filterStringOrStringArray: filterStringOrStringArray2,\n      filterType: filterType2,\n      getTrailingOptions: getTrailingOptions2,\n      trailingFunctionArgument: trailingFunctionArgument2,\n      trailingOptionsArgument: trailingOptionsArgument2\n    } = (init_utils(), __toCommonJS(utils_exports));\n    var { applyPatchTask: applyPatchTask2 } = (init_apply_patch(), __toCommonJS(apply_patch_exports));\n    var {\n      branchTask: branchTask2,\n      branchLocalTask: branchLocalTask2,\n      deleteBranchesTask: deleteBranchesTask2,\n      deleteBranchTask: deleteBranchTask2\n    } = (init_branch(), __toCommonJS(branch_exports));\n    var { checkIgnoreTask: checkIgnoreTask2 } = (init_check_ignore(), __toCommonJS(check_ignore_exports));\n    var { checkIsRepoTask: checkIsRepoTask2 } = (init_check_is_repo(), __toCommonJS(check_is_repo_exports));\n    var { cloneTask: cloneTask2, cloneMirrorTask: cloneMirrorTask2 } = (init_clone(), __toCommonJS(clone_exports));\n    var { cleanWithOptionsTask: cleanWithOptionsTask2, isCleanOptionsArray: isCleanOptionsArray2 } = (init_clean(), __toCommonJS(clean_exports));\n    var { diffSummaryTask: diffSummaryTask2 } = (init_diff(), __toCommonJS(diff_exports));\n    var { fetchTask: fetchTask2 } = (init_fetch(), __toCommonJS(fetch_exports));\n    var { moveTask: moveTask2 } = (init_move(), __toCommonJS(move_exports));\n    var { pullTask: pullTask2 } = (init_pull(), __toCommonJS(pull_exports));\n    var { pushTagsTask: pushTagsTask2 } = (init_push(), __toCommonJS(push_exports));\n    var {\n      addRemoteTask: addRemoteTask2,\n      getRemotesTask: getRemotesTask2,\n      listRemotesTask: listRemotesTask2,\n      remoteTask: remoteTask2,\n      removeRemoteTask: removeRemoteTask2\n    } = (init_remote(), __toCommonJS(remote_exports));\n    var { getResetMode: getResetMode2, resetTask: resetTask2 } = (init_reset(), __toCommonJS(reset_exports));\n    var { stashListTask: stashListTask2 } = (init_stash_list(), __toCommonJS(stash_list_exports));\n    var {\n      addSubModuleTask: addSubModuleTask2,\n      initSubModuleTask: initSubModuleTask2,\n      subModuleTask: subModuleTask2,\n      updateSubModuleTask: updateSubModuleTask2\n    } = (init_sub_module(), __toCommonJS(sub_module_exports));\n    var { addAnnotatedTagTask: addAnnotatedTagTask2, addTagTask: addTagTask2, tagListTask: tagListTask2 } = (init_tag(), __toCommonJS(tag_exports));\n    var { straightThroughBufferTask: straightThroughBufferTask2, straightThroughStringTask: straightThroughStringTask2 } = (init_task(), __toCommonJS(task_exports));\n    function Git2(options, plugins) {\n      this._plugins = plugins;\n      this._executor = new GitExecutor2(\n        options.baseDir,\n        new Scheduler2(options.maxConcurrentProcesses),\n        plugins\n      );\n      this._trimmed = options.trimmed;\n    }\n    (Git2.prototype = Object.create(SimpleGitApi2.prototype)).constructor = Git2;\n    Git2.prototype.customBinary = function(command) {\n      this._plugins.reconfigure(\"binary\", command);\n      return this;\n    };\n    Git2.prototype.env = function(name, value) {\n      if (arguments.length === 1 && typeof name === \"object\") {\n        this._executor.env = name;\n      } else {\n        (this._executor.env = this._executor.env || {})[name] = value;\n      }\n      return this;\n    };\n    Git2.prototype.stashList = function(options) {\n      return this._runTask(\n        stashListTask2(\n          trailingOptionsArgument2(arguments) || {},\n          filterArray2(options) && options || []\n        ),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    function createCloneTask(api, task, repoPath, localPath) {\n      if (typeof repoPath !== \"string\") {\n        return configurationErrorTask2(`git.${api}() requires a string 'repoPath'`);\n      }\n      return task(repoPath, filterType2(localPath, filterString2), getTrailingOptions2(arguments));\n    }\n    Git2.prototype.clone = function() {\n      return this._runTask(\n        createCloneTask(\"clone\", cloneTask2, ...arguments),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.mirror = function() {\n      return this._runTask(\n        createCloneTask(\"mirror\", cloneMirrorTask2, ...arguments),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.mv = function(from, to) {\n      return this._runTask(moveTask2(from, to), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.checkoutLatestTag = function(then) {\n      var git = this;\n      return this.pull(function() {\n        git.tags(function(err, tags) {\n          git.checkout(tags.latest, then);\n        });\n      });\n    };\n    Git2.prototype.pull = function(remote, branch, options, then) {\n      return this._runTask(\n        pullTask2(\n          filterType2(remote, filterString2),\n          filterType2(branch, filterString2),\n          getTrailingOptions2(arguments)\n        ),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.fetch = function(remote, branch) {\n      return this._runTask(\n        fetchTask2(\n          filterType2(remote, filterString2),\n          filterType2(branch, filterString2),\n          getTrailingOptions2(arguments)\n        ),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.silent = function(silence) {\n      console.warn(\n        \"simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3\"\n      );\n      return this;\n    };\n    Git2.prototype.tags = function(options, then) {\n      return this._runTask(\n        tagListTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.rebase = function() {\n      return this._runTask(\n        straightThroughStringTask2([\"rebase\", ...getTrailingOptions2(arguments)]),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.reset = function(mode) {\n      return this._runTask(\n        resetTask2(getResetMode2(mode), getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.revert = function(commit) {\n      const next = trailingFunctionArgument2(arguments);\n      if (typeof commit !== \"string\") {\n        return this._runTask(configurationErrorTask2(\"Commit must be a string\"), next);\n      }\n      return this._runTask(\n        straightThroughStringTask2([\"revert\", ...getTrailingOptions2(arguments, 0, true), commit]),\n        next\n      );\n    };\n    Git2.prototype.addTag = function(name) {\n      const task = typeof name === \"string\" ? addTagTask2(name) : configurationErrorTask2(\"Git.addTag requires a tag name\");\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.addAnnotatedTag = function(tagName, tagMessage) {\n      return this._runTask(\n        addAnnotatedTagTask2(tagName, tagMessage),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.deleteLocalBranch = function(branchName, forceDelete, then) {\n      return this._runTask(\n        deleteBranchTask2(branchName, typeof forceDelete === \"boolean\" ? forceDelete : false),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.deleteLocalBranches = function(branchNames, forceDelete, then) {\n      return this._runTask(\n        deleteBranchesTask2(branchNames, typeof forceDelete === \"boolean\" ? forceDelete : false),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.branch = function(options, then) {\n      return this._runTask(\n        branchTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.branchLocal = function(then) {\n      return this._runTask(branchLocalTask2(), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.raw = function(commands) {\n      const createRestCommands = !Array.isArray(commands);\n      const command = [].slice.call(createRestCommands ? arguments : commands, 0);\n      for (let i = 0; i < command.length && createRestCommands; i++) {\n        if (!filterPrimitives2(command[i])) {\n          command.splice(i, command.length - i);\n          break;\n        }\n      }\n      command.push(...getTrailingOptions2(arguments, 0, true));\n      var next = trailingFunctionArgument2(arguments);\n      if (!command.length) {\n        return this._runTask(\n          configurationErrorTask2(\"Raw: must supply one or more command to execute\"),\n          next\n        );\n      }\n      return this._runTask(straightThroughStringTask2(command, this._trimmed), next);\n    };\n    Git2.prototype.submoduleAdd = function(repo, path, then) {\n      return this._runTask(addSubModuleTask2(repo, path), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.submoduleUpdate = function(args, then) {\n      return this._runTask(\n        updateSubModuleTask2(getTrailingOptions2(arguments, true)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.submoduleInit = function(args, then) {\n      return this._runTask(\n        initSubModuleTask2(getTrailingOptions2(arguments, true)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.subModule = function(options, then) {\n      return this._runTask(\n        subModuleTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.listRemote = function() {\n      return this._runTask(\n        listRemotesTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.addRemote = function(remoteName, remoteRepo, then) {\n      return this._runTask(\n        addRemoteTask2(remoteName, remoteRepo, getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.removeRemote = function(remoteName, then) {\n      return this._runTask(removeRemoteTask2(remoteName), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.getRemotes = function(verbose, then) {\n      return this._runTask(getRemotesTask2(verbose === true), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.remote = function(options, then) {\n      return this._runTask(\n        remoteTask2(getTrailingOptions2(arguments)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.tag = function(options, then) {\n      const command = getTrailingOptions2(arguments);\n      if (command[0] !== \"tag\") {\n        command.unshift(\"tag\");\n      }\n      return this._runTask(straightThroughStringTask2(command), trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.updateServerInfo = function(then) {\n      return this._runTask(\n        straightThroughStringTask2([\"update-server-info\"]),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.pushTags = function(remote, then) {\n      const task = pushTagsTask2(\n        { remote: filterType2(remote, filterString2) },\n        getTrailingOptions2(arguments)\n      );\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.rm = function(files) {\n      return this._runTask(\n        straightThroughStringTask2([\"rm\", \"-f\", ...asArray2(files)]),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.rmKeepLocal = function(files) {\n      return this._runTask(\n        straightThroughStringTask2([\"rm\", \"--cached\", ...asArray2(files)]),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.catFile = function(options, then) {\n      return this._catFile(\"utf-8\", arguments);\n    };\n    Git2.prototype.binaryCatFile = function() {\n      return this._catFile(\"buffer\", arguments);\n    };\n    Git2.prototype._catFile = function(format, args) {\n      var handler = trailingFunctionArgument2(args);\n      var command = [\"cat-file\"];\n      var options = args[0];\n      if (typeof options === \"string\") {\n        return this._runTask(\n          configurationErrorTask2(\"Git.catFile: options must be supplied as an array of strings\"),\n          handler\n        );\n      }\n      if (Array.isArray(options)) {\n        command.push.apply(command, options);\n      }\n      const task = format === \"buffer\" ? straightThroughBufferTask2(command) : straightThroughStringTask2(command);\n      return this._runTask(task, handler);\n    };\n    Git2.prototype.diff = function(options, then) {\n      const task = filterString2(options) ? configurationErrorTask2(\n        \"git.diff: supplying options as a single string is no longer supported, switch to an array of strings\"\n      ) : straightThroughStringTask2([\"diff\", ...getTrailingOptions2(arguments)]);\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.diffSummary = function() {\n      return this._runTask(\n        diffSummaryTask2(getTrailingOptions2(arguments, 1)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.applyPatch = function(patches) {\n      const task = !filterStringOrStringArray2(patches) ? configurationErrorTask2(\n        `git.applyPatch requires one or more string patches as the first argument`\n      ) : applyPatchTask2(asArray2(patches), getTrailingOptions2([].slice.call(arguments, 1)));\n      return this._runTask(task, trailingFunctionArgument2(arguments));\n    };\n    Git2.prototype.revparse = function() {\n      const commands = [\"rev-parse\", ...getTrailingOptions2(arguments, true)];\n      return this._runTask(\n        straightThroughStringTask2(commands, true),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.clean = function(mode, options, then) {\n      const usingCleanOptionsArray = isCleanOptionsArray2(mode);\n      const cleanMode = usingCleanOptionsArray && mode.join(\"\") || filterType2(mode, filterString2) || \"\";\n      const customArgs = getTrailingOptions2([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));\n      return this._runTask(\n        cleanWithOptionsTask2(cleanMode, customArgs),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.exec = function(then) {\n      const task = {\n        commands: [],\n        format: \"utf-8\",\n        parser() {\n          if (typeof then === \"function\") {\n            then();\n          }\n        }\n      };\n      return this._runTask(task);\n    };\n    Git2.prototype.clearQueue = function() {\n      return this;\n    };\n    Git2.prototype.checkIgnore = function(pathnames, then) {\n      return this._runTask(\n        checkIgnoreTask2(asArray2(filterType2(pathnames, filterStringOrStringArray2, []))),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    Git2.prototype.checkIsRepo = function(checkType, then) {\n      return this._runTask(\n        checkIsRepoTask2(filterType2(checkType, filterString2)),\n        trailingFunctionArgument2(arguments)\n      );\n    };\n    module.exports = Git2;\n  }\n});\n\n// src/lib/api.ts\ninit_pathspec();\n\n// src/lib/errors/git-construct-error.ts\ninit_git_error();\nvar GitConstructError = class extends GitError {\n  constructor(config, message) {\n    super(void 0, message);\n    this.config = config;\n  }\n};\n\n// src/lib/api.ts\ninit_git_error();\n\n// src/lib/errors/git-plugin-error.ts\ninit_git_error();\nvar GitPluginError = class extends GitError {\n  constructor(task, plugin, message) {\n    super(task, message);\n    this.task = task;\n    this.plugin = plugin;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n};\n\n// src/lib/api.ts\ninit_git_response_error();\ninit_task_configuration_error();\ninit_check_is_repo();\ninit_clean();\ninit_config();\ninit_diff_name_status();\ninit_grep();\ninit_reset();\n\n// src/lib/plugins/abort-plugin.ts\nfunction abortPlugin(signal) {\n  if (!signal) {\n    return;\n  }\n  const onSpawnAfter = {\n    type: \"spawn.after\",\n    action(_data, context) {\n      function kill() {\n        context.kill(new GitPluginError(void 0, \"abort\", \"Abort signal received\"));\n      }\n      signal.addEventListener(\"abort\", kill);\n      context.spawned.on(\"close\", () => signal.removeEventListener(\"abort\", kill));\n    }\n  };\n  const onSpawnBefore = {\n    type: \"spawn.before\",\n    action(_data, context) {\n      if (signal.aborted) {\n        context.kill(new GitPluginError(void 0, \"abort\", \"Abort already signaled\"));\n      }\n    }\n  };\n  return [onSpawnBefore, onSpawnAfter];\n}\n\n// src/lib/plugins/block-unsafe-operations-plugin.ts\nfunction isConfigSwitch(arg) {\n  return typeof arg === \"string\" && arg.trim().toLowerCase() === \"-c\";\n}\nfunction preventProtocolOverride(arg, next) {\n  if (!isConfigSwitch(arg)) {\n    return;\n  }\n  if (!/^\\s*protocol(.[a-z]+)?.allow/.test(next)) {\n    return;\n  }\n  throw new GitPluginError(\n    void 0,\n    \"unsafe\",\n    \"Configuring protocol.allow is not permitted without enabling allowUnsafeExtProtocol\"\n  );\n}\nfunction preventUploadPack(arg, method) {\n  if (/^\\s*--(upload|receive)-pack/.test(arg)) {\n    throw new GitPluginError(\n      void 0,\n      \"unsafe\",\n      `Use of --upload-pack or --receive-pack is not permitted without enabling allowUnsafePack`\n    );\n  }\n  if (method === \"clone\" && /^\\s*-u\\b/.test(arg)) {\n    throw new GitPluginError(\n      void 0,\n      \"unsafe\",\n      `Use of clone with option -u is not permitted without enabling allowUnsafePack`\n    );\n  }\n  if (method === \"push\" && /^\\s*--exec\\b/.test(arg)) {\n    throw new GitPluginError(\n      void 0,\n      \"unsafe\",\n      `Use of push with option --exec is not permitted without enabling allowUnsafePack`\n    );\n  }\n}\nfunction blockUnsafeOperationsPlugin({\n  allowUnsafeProtocolOverride = false,\n  allowUnsafePack = false\n} = {}) {\n  return {\n    type: \"spawn.args\",\n    action(args, context) {\n      args.forEach((current, index) => {\n        const next = index < args.length ? args[index + 1] : \"\";\n        allowUnsafeProtocolOverride || preventProtocolOverride(current, next);\n        allowUnsafePack || preventUploadPack(current, context.method);\n      });\n      return args;\n    }\n  };\n}\n\n// src/lib/plugins/command-config-prefixing-plugin.ts\ninit_utils();\nfunction commandConfigPrefixingPlugin(configuration) {\n  const prefix = prefixedArray(configuration, \"-c\");\n  return {\n    type: \"spawn.args\",\n    action(data) {\n      return [...prefix, ...data];\n    }\n  };\n}\n\n// src/lib/plugins/completion-detection.plugin.ts\ninit_utils();\n\nvar never = (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_3__.deferred)().promise;\nfunction completionDetectionPlugin({\n  onClose = true,\n  onExit = 50\n} = {}) {\n  function createEvents() {\n    let exitCode = -1;\n    const events = {\n      close: (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_3__.deferred)(),\n      closeTimeout: (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_3__.deferred)(),\n      exit: (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_3__.deferred)(),\n      exitTimeout: (0,_kwsites_promise_deferred__WEBPACK_IMPORTED_MODULE_3__.deferred)()\n    };\n    const result = Promise.race([\n      onClose === false ? never : events.closeTimeout.promise,\n      onExit === false ? never : events.exitTimeout.promise\n    ]);\n    configureTimeout(onClose, events.close, events.closeTimeout);\n    configureTimeout(onExit, events.exit, events.exitTimeout);\n    return {\n      close(code) {\n        exitCode = code;\n        events.close.done();\n      },\n      exit(code) {\n        exitCode = code;\n        events.exit.done();\n      },\n      get exitCode() {\n        return exitCode;\n      },\n      result\n    };\n  }\n  function configureTimeout(flag, event, timeout) {\n    if (flag === false) {\n      return;\n    }\n    (flag === true ? event.promise : event.promise.then(() => delay(flag))).then(timeout.done);\n  }\n  return {\n    type: \"spawn.after\",\n    action(_0, _1) {\n      return __async(this, arguments, function* (_data, { spawned, close }) {\n        var _a3, _b;\n        const events = createEvents();\n        let deferClose = true;\n        let quickClose = () => void (deferClose = false);\n        (_a3 = spawned.stdout) == null ? void 0 : _a3.on(\"data\", quickClose);\n        (_b = spawned.stderr) == null ? void 0 : _b.on(\"data\", quickClose);\n        spawned.on(\"error\", quickClose);\n        spawned.on(\"close\", (code) => events.close(code));\n        spawned.on(\"exit\", (code) => events.exit(code));\n        try {\n          yield events.result;\n          if (deferClose) {\n            yield delay(50);\n          }\n          close(events.exitCode);\n        } catch (err) {\n          close(events.exitCode, err);\n        }\n      });\n    }\n  };\n}\n\n// src/lib/plugins/custom-binary.plugin.ts\ninit_utils();\nvar WRONG_NUMBER_ERR = `Invalid value supplied for custom binary, requires a single string or an array containing either one or two strings`;\nvar WRONG_CHARS_ERR = `Invalid value supplied for custom binary, restricted characters must be removed or supply the unsafe.allowUnsafeCustomBinary option`;\nfunction isBadArgument(arg) {\n  return !arg || !/^([a-z]:)?([a-z0-9/.\\\\_-]+)$/i.test(arg);\n}\nfunction toBinaryConfig(input, allowUnsafe) {\n  if (input.length < 1 || input.length > 2) {\n    throw new GitPluginError(void 0, \"binary\", WRONG_NUMBER_ERR);\n  }\n  const isBad = input.some(isBadArgument);\n  if (isBad) {\n    if (allowUnsafe) {\n      console.warn(WRONG_CHARS_ERR);\n    } else {\n      throw new GitPluginError(void 0, \"binary\", WRONG_CHARS_ERR);\n    }\n  }\n  const [binary, prefix] = input;\n  return {\n    binary,\n    prefix\n  };\n}\nfunction customBinaryPlugin(plugins, input = [\"git\"], allowUnsafe = false) {\n  let config = toBinaryConfig(asArray(input), allowUnsafe);\n  plugins.on(\"binary\", (input2) => {\n    config = toBinaryConfig(asArray(input2), allowUnsafe);\n  });\n  plugins.append(\"spawn.binary\", () => {\n    return config.binary;\n  });\n  plugins.append(\"spawn.args\", (data) => {\n    return config.prefix ? [config.prefix, ...data] : data;\n  });\n}\n\n// src/lib/plugins/error-detection.plugin.ts\ninit_git_error();\nfunction isTaskError(result) {\n  return !!(result.exitCode && result.stdErr.length);\n}\nfunction getErrorMessage(result) {\n  return Buffer.concat([...result.stdOut, ...result.stdErr]);\n}\nfunction errorDetectionHandler(overwrite = false, isError = isTaskError, errorMessage = getErrorMessage) {\n  return (error, result) => {\n    if (!overwrite && error || !isError(result)) {\n      return error;\n    }\n    return errorMessage(result);\n  };\n}\nfunction errorDetectionPlugin(config) {\n  return {\n    type: \"task.error\",\n    action(data, context) {\n      const error = config(data.error, {\n        stdErr: context.stdErr,\n        stdOut: context.stdOut,\n        exitCode: context.exitCode\n      });\n      if (Buffer.isBuffer(error)) {\n        return { error: new GitError(void 0, error.toString(\"utf-8\")) };\n      }\n      return {\n        error\n      };\n    }\n  };\n}\n\n// src/lib/plugins/plugin-store.ts\ninit_utils();\n\nvar PluginStore = class {\n  constructor() {\n    this.plugins = /* @__PURE__ */ new Set();\n    this.events = new node_events__WEBPACK_IMPORTED_MODULE_4__.EventEmitter();\n  }\n  on(type, listener) {\n    this.events.on(type, listener);\n  }\n  reconfigure(type, data) {\n    this.events.emit(type, data);\n  }\n  append(type, action) {\n    const plugin = append(this.plugins, { type, action });\n    return () => this.plugins.delete(plugin);\n  }\n  add(plugin) {\n    const plugins = [];\n    asArray(plugin).forEach((plugin2) => plugin2 && this.plugins.add(append(plugins, plugin2)));\n    return () => {\n      plugins.forEach((plugin2) => this.plugins.delete(plugin2));\n    };\n  }\n  exec(type, data, context) {\n    let output = data;\n    const contextual = Object.freeze(Object.create(context));\n    for (const plugin of this.plugins) {\n      if (plugin.type === type) {\n        output = plugin.action(output, contextual);\n      }\n    }\n    return output;\n  }\n};\n\n// src/lib/plugins/progress-monitor-plugin.ts\ninit_utils();\nfunction progressMonitorPlugin(progress) {\n  const progressCommand = \"--progress\";\n  const progressMethods = [\"checkout\", \"clone\", \"fetch\", \"pull\", \"push\"];\n  const onProgress = {\n    type: \"spawn.after\",\n    action(_data, context) {\n      var _a2;\n      if (!context.commands.includes(progressCommand)) {\n        return;\n      }\n      (_a2 = context.spawned.stderr) == null ? void 0 : _a2.on(\"data\", (chunk) => {\n        const message = /^([\\s\\S]+?):\\s*(\\d+)% \\((\\d+)\\/(\\d+)\\)/.exec(chunk.toString(\"utf8\"));\n        if (!message) {\n          return;\n        }\n        progress({\n          method: context.method,\n          stage: progressEventStage(message[1]),\n          progress: asNumber(message[2]),\n          processed: asNumber(message[3]),\n          total: asNumber(message[4])\n        });\n      });\n    }\n  };\n  const onArgs = {\n    type: \"spawn.args\",\n    action(args, context) {\n      if (!progressMethods.includes(context.method)) {\n        return args;\n      }\n      return including(args, progressCommand);\n    }\n  };\n  return [onArgs, onProgress];\n}\nfunction progressEventStage(input) {\n  return String(input.toLowerCase().split(\" \", 1)) || \"unknown\";\n}\n\n// src/lib/plugins/spawn-options-plugin.ts\ninit_utils();\nfunction spawnOptionsPlugin(spawnOptions) {\n  const options = pick(spawnOptions, [\"uid\", \"gid\"]);\n  return {\n    type: \"spawn.options\",\n    action(data) {\n      return __spreadValues(__spreadValues({}, options), data);\n    }\n  };\n}\n\n// src/lib/plugins/timout-plugin.ts\nfunction timeoutPlugin({\n  block,\n  stdErr = true,\n  stdOut = true\n}) {\n  if (block > 0) {\n    return {\n      type: \"spawn.after\",\n      action(_data, context) {\n        var _a2, _b;\n        let timeout;\n        function wait() {\n          timeout && clearTimeout(timeout);\n          timeout = setTimeout(kill, block);\n        }\n        function stop() {\n          var _a3, _b2;\n          (_a3 = context.spawned.stdout) == null ? void 0 : _a3.off(\"data\", wait);\n          (_b2 = context.spawned.stderr) == null ? void 0 : _b2.off(\"data\", wait);\n          context.spawned.off(\"exit\", stop);\n          context.spawned.off(\"close\", stop);\n          timeout && clearTimeout(timeout);\n        }\n        function kill() {\n          stop();\n          context.kill(new GitPluginError(void 0, \"timeout\", `block timeout reached`));\n        }\n        stdOut && ((_a2 = context.spawned.stdout) == null ? void 0 : _a2.on(\"data\", wait));\n        stdErr && ((_b = context.spawned.stderr) == null ? void 0 : _b.on(\"data\", wait));\n        context.spawned.on(\"exit\", stop);\n        context.spawned.on(\"close\", stop);\n        wait();\n      }\n    };\n  }\n}\n\n// src/lib/plugins/suffix-paths.plugin.ts\ninit_pathspec();\nfunction suffixPathsPlugin() {\n  return {\n    type: \"spawn.args\",\n    action(data) {\n      const prefix = [];\n      let suffix;\n      function append2(args) {\n        (suffix = suffix || []).push(...args);\n      }\n      for (let i = 0; i < data.length; i++) {\n        const param = data[i];\n        if (isPathSpec(param)) {\n          append2(toPaths(param));\n          continue;\n        }\n        if (param === \"--\") {\n          append2(\n            data.slice(i + 1).flatMap((item) => isPathSpec(item) && toPaths(item) || item)\n          );\n          break;\n        }\n        prefix.push(param);\n      }\n      return !suffix ? prefix : [...prefix, \"--\", ...suffix.map(String)];\n    }\n  };\n}\n\n// src/lib/git-factory.ts\ninit_utils();\nvar Git = require_git();\nfunction gitInstanceFactory(baseDir, options) {\n  var _a2;\n  const plugins = new PluginStore();\n  const config = createInstanceConfig(\n    baseDir && (typeof baseDir === \"string\" ? { baseDir } : baseDir) || {},\n    options\n  );\n  if (!folderExists(config.baseDir)) {\n    throw new GitConstructError(\n      config,\n      `Cannot use simple-git on a directory that does not exist`\n    );\n  }\n  if (Array.isArray(config.config)) {\n    plugins.add(commandConfigPrefixingPlugin(config.config));\n  }\n  plugins.add(blockUnsafeOperationsPlugin(config.unsafe));\n  plugins.add(suffixPathsPlugin());\n  plugins.add(completionDetectionPlugin(config.completion));\n  config.abort && plugins.add(abortPlugin(config.abort));\n  config.progress && plugins.add(progressMonitorPlugin(config.progress));\n  config.timeout && plugins.add(timeoutPlugin(config.timeout));\n  config.spawnOptions && plugins.add(spawnOptionsPlugin(config.spawnOptions));\n  plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));\n  config.errors && plugins.add(errorDetectionPlugin(config.errors));\n  customBinaryPlugin(plugins, config.binary, (_a2 = config.unsafe) == null ? void 0 : _a2.allowUnsafeCustomBinary);\n  return new Git(config, plugins);\n}\n\n// src/lib/runners/promise-wrapped.ts\ninit_git_response_error();\nvar functionNamesBuilderApi = [\"customBinary\", \"env\", \"outputHandler\", \"silent\"];\nvar functionNamesPromiseApi = [\n  \"add\",\n  \"addAnnotatedTag\",\n  \"addConfig\",\n  \"addRemote\",\n  \"addTag\",\n  \"applyPatch\",\n  \"binaryCatFile\",\n  \"branch\",\n  \"branchLocal\",\n  \"catFile\",\n  \"checkIgnore\",\n  \"checkIsRepo\",\n  \"checkout\",\n  \"checkoutBranch\",\n  \"checkoutLatestTag\",\n  \"checkoutLocalBranch\",\n  \"clean\",\n  \"clone\",\n  \"commit\",\n  \"cwd\",\n  \"deleteLocalBranch\",\n  \"deleteLocalBranches\",\n  \"diff\",\n  \"diffSummary\",\n  \"exec\",\n  \"fetch\",\n  \"getRemotes\",\n  \"init\",\n  \"listConfig\",\n  \"listRemote\",\n  \"log\",\n  \"merge\",\n  \"mergeFromTo\",\n  \"mirror\",\n  \"mv\",\n  \"pull\",\n  \"push\",\n  \"pushTags\",\n  \"raw\",\n  \"rebase\",\n  \"remote\",\n  \"removeRemote\",\n  \"reset\",\n  \"revert\",\n  \"revparse\",\n  \"rm\",\n  \"rmKeepLocal\",\n  \"show\",\n  \"stash\",\n  \"stashList\",\n  \"status\",\n  \"subModule\",\n  \"submoduleAdd\",\n  \"submoduleInit\",\n  \"submoduleUpdate\",\n  \"tag\",\n  \"tags\",\n  \"updateServerInfo\"\n];\nfunction gitP(...args) {\n  let git;\n  let chain = Promise.resolve();\n  try {\n    git = gitInstanceFactory(...args);\n  } catch (e) {\n    chain = Promise.reject(e);\n  }\n  function builderReturn() {\n    return promiseApi;\n  }\n  function chainReturn() {\n    return chain;\n  }\n  const promiseApi = [...functionNamesBuilderApi, ...functionNamesPromiseApi].reduce(\n    (api, name) => {\n      const isAsync = functionNamesPromiseApi.includes(name);\n      const valid = isAsync ? asyncWrapper(name, git) : syncWrapper(name, git, api);\n      const alternative = isAsync ? chainReturn : builderReturn;\n      Object.defineProperty(api, name, {\n        enumerable: false,\n        configurable: false,\n        value: git ? valid : alternative\n      });\n      return api;\n    },\n    {}\n  );\n  return promiseApi;\n  function asyncWrapper(fn, git2) {\n    return function(...args2) {\n      if (typeof args2[args2.length] === \"function\") {\n        throw new TypeError(\n          \"Promise interface requires that handlers are not supplied inline, trailing function not allowed in call to \" + fn\n        );\n      }\n      return chain.then(function() {\n        return new Promise(function(resolve, reject) {\n          const callback = (err, result) => {\n            if (err) {\n              return reject(toError(err));\n            }\n            resolve(result);\n          };\n          args2.push(callback);\n          git2[fn].apply(git2, args2);\n        });\n      });\n    };\n  }\n  function syncWrapper(fn, git2, api) {\n    return (...args2) => {\n      git2[fn](...args2);\n      return api;\n    };\n  }\n}\nfunction toError(error) {\n  if (error instanceof Error) {\n    return error;\n  }\n  if (typeof error === \"string\") {\n    return new Error(error);\n  }\n  return new GitResponseError(error);\n}\n\n// src/esm.mjs\nvar simpleGit = gitInstanceFactory;\nvar esm_default = gitInstanceFactory;\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsYUFBYTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ3NEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDREQUFNLE9BQU8sd0RBQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJEQUEyRCwrQkFBK0IsSUFBSTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGlCQUFpQjtBQUN0QjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsU0FBUztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsU0FBUztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHdCQUF3QjtBQUM3QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsVUFBVSw0QkFBNEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1GQUFtRixLQUFLO0FBQ3hGO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvQkFBb0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE1BQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0JBQXNCO0FBQzNCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0JBQXNCO0FBQzNCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE9BQU87QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGlCQUFpQjtBQUN0QjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUMwQjtBQUMxQjtBQUNBLFNBQVMsa0NBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCw0QkFBNEI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsTUFBTTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE1BQU07QUFDMUM7QUFDQSxpREFBaUQsYUFBYSxFQUFFLFdBQVc7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZDQUFnQjtBQUNwQixJQUFJLDZDQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGlCQUFpQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUssR0FBRyw2QkFBNkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0VBQW9FLE1BQU07QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLHNDQUFzQztBQUN0RDtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsNEJBQTRCLG9EQUFLO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxNQUFNLGlDQUFpQyxLQUFLO0FBQy9HO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFVBQVU7QUFDNUU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsSUFBSTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLElBQUk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0NBQW9DLFlBQVk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGdCQUFnQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZUFBZSxFQUFFLFVBQVUsRUFBRSxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUztBQUN6QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZSxFQUFFLGNBQWMsRUFBRSxhQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwwQkFBMEI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHNCQUFzQjtBQUMzQjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVUsR0FBRyxZQUFZO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHdCQUF3QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx3QkFBd0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSwrQkFBK0IsNENBQTRDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsV0FBVztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw4Q0FBOEM7QUFDOUM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxvREFBb0Qsa0JBQWtCO0FBQ3RFO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxxQkFBcUI7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU8sRUFBRSxPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNLEVBQUUsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEVBQUU7QUFDOUMsa0NBQWtDLEVBQUU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVcsR0FBRyxXQUFXLEdBQUcsV0FBVztBQUN6RCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1DQUFtQztBQUNyRCxtQkFBbUIsb0NBQW9DO0FBQ3ZELHVCQUF1QjtBQUN2QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQzBEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQixFQUFFLHlFQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYywwQkFBMEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLCtCQUErQixXQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QyxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsT0FBTztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw0QkFBNEI7QUFDdEMsVUFBVSw4QkFBOEI7QUFDeEMsVUFBVSx3QkFBd0I7QUFDbEMsVUFBVSxrREFBa0Q7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVSxrQ0FBa0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixVQUFVLG9DQUFvQztBQUM5QyxVQUFVLG9DQUFvQztBQUM5QyxVQUFVLDJEQUEyRDtBQUNyRSxVQUFVLHlGQUF5RjtBQUNuRyxVQUFVLG9DQUFvQztBQUM5QyxVQUFVLHdCQUF3QjtBQUNsQyxVQUFVLHNCQUFzQjtBQUNoQyxVQUFVLHNCQUFzQjtBQUNoQyxVQUFVLDhCQUE4QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVSxxREFBcUQ7QUFDL0QsVUFBVSxnQ0FBZ0M7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixVQUFVLGdHQUFnRztBQUMxRyxVQUFVLCtHQUErRztBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsSUFBSTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBDQUEwQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDRDQUE0QztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDcUQ7QUFDckQsWUFBWSxtRUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1FQUFRO0FBQ3JCLG9CQUFvQixtRUFBUTtBQUM1QixZQUFZLG1FQUFRO0FBQ3BCLG1CQUFtQixtRUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxnQkFBZ0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsVUFBVSxnQkFBZ0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQWlCRTtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG5hdmluXFxEb3dubG9hZHNcXEFJLVBvd2VyZWQtSW50ZWdyYXRlZC1Db2RlLUFuYWx5emVyLWZvci1FZmZpY2llbnQtRGV2ZWxvcGVyLVdvcmtGbG93XFxkb2NhaVxcbm9kZV9tb2R1bGVzXFxzaW1wbGUtZ2l0XFxkaXN0XFxlc21cXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG52YXIgX19lc20gPSAoZm4sIHJlcykgPT4gZnVuY3Rpb24gX19pbml0KCkge1xuICByZXR1cm4gZm4gJiYgKHJlcyA9ICgwLCBmbltfX2dldE93blByb3BOYW1lcyhmbilbMF1dKShmbiA9IDApKSwgcmVzO1xufTtcbnZhciBfX2NvbW1vbkpTID0gKGNiLCBtb2QpID0+IGZ1bmN0aW9uIF9fcmVxdWlyZSgpIHtcbiAgcmV0dXJuIG1vZCB8fCAoMCwgY2JbX19nZXRPd25Qcm9wTmFtZXMoY2IpWzBdXSkoKG1vZCA9IHsgZXhwb3J0czoge30gfSkuZXhwb3J0cywgbW9kKSwgbW9kLmV4cG9ydHM7XG59O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xuXG4vLyBzcmMvbGliL2FyZ3MvcGF0aHNwZWMudHNcbmZ1bmN0aW9uIHBhdGhzcGVjKC4uLnBhdGhzKSB7XG4gIGNvbnN0IGtleSA9IG5ldyBTdHJpbmcocGF0aHMpO1xuICBjYWNoZS5zZXQoa2V5LCBwYXRocyk7XG4gIHJldHVybiBrZXk7XG59XG5mdW5jdGlvbiBpc1BhdGhTcGVjKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGggaW5zdGFuY2VvZiBTdHJpbmcgJiYgY2FjaGUuaGFzKHBhdGgpO1xufVxuZnVuY3Rpb24gdG9QYXRocyhwYXRoU3BlYykge1xuICByZXR1cm4gY2FjaGUuZ2V0KHBhdGhTcGVjKSB8fCBbXTtcbn1cbnZhciBjYWNoZTtcbnZhciBpbml0X3BhdGhzcGVjID0gX19lc20oe1xuICBcInNyYy9saWIvYXJncy9wYXRoc3BlYy50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL2Vycm9ycy9naXQtZXJyb3IudHNcbnZhciBHaXRFcnJvcjtcbnZhciBpbml0X2dpdF9lcnJvciA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL2Vycm9ycy9naXQtZXJyb3IudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBHaXRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICAgICAgY29uc3RydWN0b3IodGFzaywgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy50YXNrID0gdGFzaztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9lcnJvcnMvZ2l0LXJlc3BvbnNlLWVycm9yLnRzXG52YXIgR2l0UmVzcG9uc2VFcnJvcjtcbnZhciBpbml0X2dpdF9yZXNwb25zZV9lcnJvciA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL2Vycm9ycy9naXQtcmVzcG9uc2UtZXJyb3IudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X2dpdF9lcnJvcigpO1xuICAgIEdpdFJlc3BvbnNlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEdpdEVycm9yIHtcbiAgICAgIGNvbnN0cnVjdG9yKGdpdCwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcih2b2lkIDAsIG1lc3NhZ2UgfHwgU3RyaW5nKGdpdCkpO1xuICAgICAgICB0aGlzLmdpdCA9IGdpdDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9lcnJvcnMvdGFzay1jb25maWd1cmF0aW9uLWVycm9yLnRzXG52YXIgVGFza0NvbmZpZ3VyYXRpb25FcnJvcjtcbnZhciBpbml0X3Rhc2tfY29uZmlndXJhdGlvbl9lcnJvciA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL2Vycm9ycy90YXNrLWNvbmZpZ3VyYXRpb24tZXJyb3IudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X2dpdF9lcnJvcigpO1xuICAgIFRhc2tDb25maWd1cmF0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEdpdEVycm9yIHtcbiAgICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIodm9pZCAwLCBtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi91dGlscy91dGlsLnRzXG5pbXBvcnQgeyBleGlzdHMsIEZPTERFUiB9IGZyb20gXCJAa3dzaXRlcy9maWxlLWV4aXN0c1wiO1xuZnVuY3Rpb24gYXNGdW5jdGlvbihzb3VyY2UpIHtcbiAgcmV0dXJuIHR5cGVvZiBzb3VyY2UgPT09IFwiZnVuY3Rpb25cIiA/IHNvdXJjZSA6IE5PT1A7XG59XG5mdW5jdGlvbiBpc1VzZXJGdW5jdGlvbihzb3VyY2UpIHtcbiAgcmV0dXJuIHR5cGVvZiBzb3VyY2UgPT09IFwiZnVuY3Rpb25cIiAmJiBzb3VyY2UgIT09IE5PT1A7XG59XG5mdW5jdGlvbiBzcGxpdE9uKGlucHV0LCBjaGFyKSB7XG4gIGNvbnN0IGluZGV4ID0gaW5wdXQuaW5kZXhPZihjaGFyKTtcbiAgaWYgKGluZGV4IDw9IDApIHtcbiAgICByZXR1cm4gW2lucHV0LCBcIlwiXTtcbiAgfVxuICByZXR1cm4gW2lucHV0LnN1YnN0cigwLCBpbmRleCksIGlucHV0LnN1YnN0cihpbmRleCArIDEpXTtcbn1cbmZ1bmN0aW9uIGZpcnN0KGlucHV0LCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID4gb2Zmc2V0ID8gaW5wdXRbb2Zmc2V0XSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGxhc3QoaW5wdXQsIG9mZnNldCA9IDApIHtcbiAgaWYgKGlzQXJyYXlMaWtlKGlucHV0KSAmJiBpbnB1dC5sZW5ndGggPiBvZmZzZXQpIHtcbiAgICByZXR1cm4gaW5wdXRbaW5wdXQubGVuZ3RoIC0gMSAtIG9mZnNldF07XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKGlucHV0KSB7XG4gIHJldHVybiAhIShpbnB1dCAmJiB0eXBlb2YgaW5wdXQubGVuZ3RoID09PSBcIm51bWJlclwiKTtcbn1cbmZ1bmN0aW9uIHRvTGluZXNXaXRoQ29udGVudChpbnB1dCA9IFwiXCIsIHRyaW1tZWQyID0gdHJ1ZSwgc2VwYXJhdG9yID0gXCJcXG5cIikge1xuICByZXR1cm4gaW5wdXQuc3BsaXQoc2VwYXJhdG9yKS5yZWR1Y2UoKG91dHB1dCwgbGluZSkgPT4ge1xuICAgIGNvbnN0IGxpbmVDb250ZW50ID0gdHJpbW1lZDIgPyBsaW5lLnRyaW0oKSA6IGxpbmU7XG4gICAgaWYgKGxpbmVDb250ZW50KSB7XG4gICAgICBvdXRwdXQucHVzaChsaW5lQ29udGVudCk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0sIFtdKTtcbn1cbmZ1bmN0aW9uIGZvckVhY2hMaW5lV2l0aENvbnRlbnQoaW5wdXQsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0b0xpbmVzV2l0aENvbnRlbnQoaW5wdXQsIHRydWUpLm1hcCgobGluZSkgPT4gY2FsbGJhY2sobGluZSkpO1xufVxuZnVuY3Rpb24gZm9sZGVyRXhpc3RzKHBhdGgpIHtcbiAgcmV0dXJuIGV4aXN0cyhwYXRoLCBGT0xERVIpO1xufVxuZnVuY3Rpb24gYXBwZW5kKHRhcmdldCwgaXRlbSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgaWYgKCF0YXJnZXQuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICAgIHRhcmdldC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuYWRkKGl0ZW0pO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuZnVuY3Rpb24gaW5jbHVkaW5nKHRhcmdldCwgaXRlbSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmICF0YXJnZXQuaW5jbHVkZXMoaXRlbSkpIHtcbiAgICB0YXJnZXQucHVzaChpdGVtKTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gcmVtb3ZlKHRhcmdldCwgaXRlbSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgY29uc3QgaW5kZXggPSB0YXJnZXQuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGFyZ2V0LnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5kZWxldGUoaXRlbSk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5mdW5jdGlvbiBhc0FycmF5KHNvdXJjZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogW3NvdXJjZV07XG59XG5mdW5jdGlvbiBhc0NhbWVsQ2FzZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFxzLV0rKC4pL2csIChfYWxsLCBjaHIpID0+IHtcbiAgICByZXR1cm4gY2hyLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gYXNTdHJpbmdBcnJheShzb3VyY2UpIHtcbiAgcmV0dXJuIGFzQXJyYXkoc291cmNlKS5tYXAoU3RyaW5nKTtcbn1cbmZ1bmN0aW9uIGFzTnVtYmVyKHNvdXJjZSwgb25OYU4gPSAwKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkge1xuICAgIHJldHVybiBvbk5hTjtcbiAgfVxuICBjb25zdCBudW0gPSBwYXJzZUludChzb3VyY2UsIDEwKTtcbiAgcmV0dXJuIGlzTmFOKG51bSkgPyBvbk5hTiA6IG51bTtcbn1cbmZ1bmN0aW9uIHByZWZpeGVkQXJyYXkoaW5wdXQsIHByZWZpeCkge1xuICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIG1heCA9IGlucHV0Lmxlbmd0aDsgaSA8IG1heDsgaSsrKSB7XG4gICAgb3V0cHV0LnB1c2gocHJlZml4LCBpbnB1dFtpXSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cbmZ1bmN0aW9uIGJ1ZmZlclRvU3RyaW5nKGlucHV0KSB7XG4gIHJldHVybiAoQXJyYXkuaXNBcnJheShpbnB1dCkgPyBCdWZmZXIuY29uY2F0KGlucHV0KSA6IGlucHV0KS50b1N0cmluZyhcInV0Zi04XCIpO1xufVxuZnVuY3Rpb24gcGljayhzb3VyY2UsIHByb3BlcnRpZXMpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAge30sXG4gICAgLi4ucHJvcGVydGllcy5tYXAoKHByb3BlcnR5KSA9PiBwcm9wZXJ0eSBpbiBzb3VyY2UgPyB7IFtwcm9wZXJ0eV06IHNvdXJjZVtwcm9wZXJ0eV0gfSA6IHt9KVxuICApO1xufVxuZnVuY3Rpb24gZGVsYXkoZHVyYXRpb24gPSAwKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgoZG9uZSkgPT4gc2V0VGltZW91dChkb25lLCBkdXJhdGlvbikpO1xufVxuZnVuY3Rpb24gb3JWb2lkKGlucHV0KSB7XG4gIGlmIChpbnB1dCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBpbnB1dDtcbn1cbnZhciBOVUxMLCBOT09QLCBvYmplY3RUb1N0cmluZztcbnZhciBpbml0X3V0aWwgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi91dGlscy91dGlsLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgTlVMTCA9IFwiXFwwXCI7XG4gICAgTk9PUCA9ICgpID0+IHtcbiAgICB9O1xuICAgIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3V0aWxzL2FyZ3VtZW50LWZpbHRlcnMudHNcbmZ1bmN0aW9uIGZpbHRlclR5cGUoaW5wdXQsIGZpbHRlciwgZGVmKSB7XG4gIGlmIChmaWx0ZXIoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGRlZiA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGZpbHRlclByaW1pdGl2ZXMoaW5wdXQsIG9taXQpIHtcbiAgY29uc3QgdHlwZSA9IGlzUGF0aFNwZWMoaW5wdXQpID8gXCJzdHJpbmdcIiA6IHR5cGVvZiBpbnB1dDtcbiAgcmV0dXJuIC9udW1iZXJ8c3RyaW5nfGJvb2xlYW4vLnRlc3QodHlwZSkgJiYgKCFvbWl0IHx8ICFvbWl0LmluY2x1ZGVzKHR5cGUpKTtcbn1cbmZ1bmN0aW9uIGZpbHRlclBsYWluT2JqZWN0KGlucHV0KSB7XG4gIHJldHVybiAhIWlucHV0ICYmIG9iamVjdFRvU3RyaW5nKGlucHV0KSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbn1cbmZ1bmN0aW9uIGZpbHRlckZ1bmN0aW9uKGlucHV0KSB7XG4gIHJldHVybiB0eXBlb2YgaW5wdXQgPT09IFwiZnVuY3Rpb25cIjtcbn1cbnZhciBmaWx0ZXJBcnJheSwgZmlsdGVyU3RyaW5nLCBmaWx0ZXJTdHJpbmdBcnJheSwgZmlsdGVyU3RyaW5nT3JTdHJpbmdBcnJheSwgZmlsdGVySGFzTGVuZ3RoO1xudmFyIGluaXRfYXJndW1lbnRfZmlsdGVycyA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3V0aWxzL2FyZ3VtZW50LWZpbHRlcnMudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWwoKTtcbiAgICBpbml0X3BhdGhzcGVjKCk7XG4gICAgZmlsdGVyQXJyYXkgPSAoaW5wdXQpID0+IHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0KTtcbiAgICB9O1xuICAgIGZpbHRlclN0cmluZyA9IChpbnB1dCkgPT4ge1xuICAgICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIjtcbiAgICB9O1xuICAgIGZpbHRlclN0cmluZ0FycmF5ID0gKGlucHV0KSA9PiB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dCkgJiYgaW5wdXQuZXZlcnkoZmlsdGVyU3RyaW5nKTtcbiAgICB9O1xuICAgIGZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXkgPSAoaW5wdXQpID0+IHtcbiAgICAgIHJldHVybiBmaWx0ZXJTdHJpbmcoaW5wdXQpIHx8IEFycmF5LmlzQXJyYXkoaW5wdXQpICYmIGlucHV0LmV2ZXJ5KGZpbHRlclN0cmluZyk7XG4gICAgfTtcbiAgICBmaWx0ZXJIYXNMZW5ndGggPSAoaW5wdXQpID0+IHtcbiAgICAgIGlmIChpbnB1dCA9PSBudWxsIHx8IFwibnVtYmVyfGJvb2xlYW58ZnVuY3Rpb25cIi5pbmNsdWRlcyh0eXBlb2YgaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0KSB8fCB0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGlucHV0Lmxlbmd0aCA9PT0gXCJudW1iZXJcIjtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi91dGlscy9leGl0LWNvZGVzLnRzXG52YXIgRXhpdENvZGVzO1xudmFyIGluaXRfZXhpdF9jb2RlcyA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3V0aWxzL2V4aXQtY29kZXMudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBFeGl0Q29kZXMgPSAvKiBAX19QVVJFX18gKi8gKChFeGl0Q29kZXMyKSA9PiB7XG4gICAgICBFeGl0Q29kZXMyW0V4aXRDb2RlczJbXCJTVUNDRVNTXCJdID0gMF0gPSBcIlNVQ0NFU1NcIjtcbiAgICAgIEV4aXRDb2RlczJbRXhpdENvZGVzMltcIkVSUk9SXCJdID0gMV0gPSBcIkVSUk9SXCI7XG4gICAgICBFeGl0Q29kZXMyW0V4aXRDb2RlczJbXCJOT1RfRk9VTkRcIl0gPSAtMl0gPSBcIk5PVF9GT1VORFwiO1xuICAgICAgRXhpdENvZGVzMltFeGl0Q29kZXMyW1wiVU5DTEVBTlwiXSA9IDEyOF0gPSBcIlVOQ0xFQU5cIjtcbiAgICAgIHJldHVybiBFeGl0Q29kZXMyO1xuICAgIH0pKEV4aXRDb2RlcyB8fCB7fSk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3V0aWxzL2dpdC1vdXRwdXQtc3RyZWFtcy50c1xudmFyIEdpdE91dHB1dFN0cmVhbXM7XG52YXIgaW5pdF9naXRfb3V0cHV0X3N0cmVhbXMgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi91dGlscy9naXQtb3V0cHV0LXN0cmVhbXMudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBHaXRPdXRwdXRTdHJlYW1zID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3Ioc3RkT3V0LCBzdGRFcnIpIHtcbiAgICAgICAgdGhpcy5zdGRPdXQgPSBzdGRPdXQ7XG4gICAgICAgIHRoaXMuc3RkRXJyID0gc3RkRXJyO1xuICAgICAgfVxuICAgICAgYXNTdHJpbmdzKCkge1xuICAgICAgICByZXR1cm4gbmV3IEdpdE91dHB1dFN0cmVhbXModGhpcy5zdGRPdXQudG9TdHJpbmcoXCJ1dGY4XCIpLCB0aGlzLnN0ZEVyci50b1N0cmluZyhcInV0ZjhcIikpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3V0aWxzL2xpbmUtcGFyc2VyLnRzXG52YXIgTGluZVBhcnNlciwgUmVtb3RlTGluZVBhcnNlcjtcbnZhciBpbml0X2xpbmVfcGFyc2VyID0gX19lc20oe1xuICBcInNyYy9saWIvdXRpbHMvbGluZS1wYXJzZXIudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBMaW5lUGFyc2VyID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IocmVnRXhwLCB1c2VNYXRjaGVzKSB7XG4gICAgICAgIHRoaXMubWF0Y2hlcyA9IFtdO1xuICAgICAgICB0aGlzLnBhcnNlID0gKGxpbmUsIHRhcmdldCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRNYXRjaGVzKCk7XG4gICAgICAgICAgaWYgKCF0aGlzLl9yZWdFeHAuZXZlcnkoKHJlZywgaW5kZXgpID0+IHRoaXMuYWRkTWF0Y2gocmVnLCBpbmRleCwgbGluZShpbmRleCkpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy51c2VNYXRjaGVzKHRhcmdldCwgdGhpcy5wcmVwYXJlTWF0Y2hlcygpKSAhPT0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3JlZ0V4cCA9IEFycmF5LmlzQXJyYXkocmVnRXhwKSA/IHJlZ0V4cCA6IFtyZWdFeHBdO1xuICAgICAgICBpZiAodXNlTWF0Y2hlcykge1xuICAgICAgICAgIHRoaXMudXNlTWF0Y2hlcyA9IHVzZU1hdGNoZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHVzZU1hdGNoZXModGFyZ2V0LCBtYXRjaCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmVQYXJzZXI6dXNlTWF0Y2hlcyBub3QgaW1wbGVtZW50ZWRgKTtcbiAgICAgIH1cbiAgICAgIHJlc2V0TWF0Y2hlcygpIHtcbiAgICAgICAgdGhpcy5tYXRjaGVzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICBwcmVwYXJlTWF0Y2hlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hlcztcbiAgICAgIH1cbiAgICAgIGFkZE1hdGNoKHJlZywgaW5kZXgsIGxpbmUpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlZCA9IGxpbmUgJiYgcmVnLmV4ZWMobGluZSk7XG4gICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgdGhpcy5wdXNoTWF0Y2goaW5kZXgsIG1hdGNoZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIW1hdGNoZWQ7XG4gICAgICB9XG4gICAgICBwdXNoTWF0Y2goX2luZGV4LCBtYXRjaGVkKSB7XG4gICAgICAgIHRoaXMubWF0Y2hlcy5wdXNoKC4uLm1hdGNoZWQuc2xpY2UoMSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgUmVtb3RlTGluZVBhcnNlciA9IGNsYXNzIGV4dGVuZHMgTGluZVBhcnNlciB7XG4gICAgICBhZGRNYXRjaChyZWcsIGluZGV4LCBsaW5lKSB7XG4gICAgICAgIHJldHVybiAvXnJlbW90ZTpcXHMvLnRlc3QoU3RyaW5nKGxpbmUpKSAmJiBzdXBlci5hZGRNYXRjaChyZWcsIGluZGV4LCBsaW5lKTtcbiAgICAgIH1cbiAgICAgIHB1c2hNYXRjaChpbmRleCwgbWF0Y2hlZCkge1xuICAgICAgICBpZiAoaW5kZXggPiAwIHx8IG1hdGNoZWQubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHN1cGVyLnB1c2hNYXRjaChpbmRleCwgbWF0Y2hlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi91dGlscy9zaW1wbGUtZ2l0LW9wdGlvbnMudHNcbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlQ29uZmlnKC4uLm9wdGlvbnMpIHtcbiAgY29uc3QgYmFzZURpciA9IHByb2Nlc3MuY3dkKCk7XG4gIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oXG4gICAgX19zcHJlYWRWYWx1ZXMoeyBiYXNlRGlyIH0sIGRlZmF1bHRPcHRpb25zKSxcbiAgICAuLi5vcHRpb25zLmZpbHRlcigobykgPT4gdHlwZW9mIG8gPT09IFwib2JqZWN0XCIgJiYgbylcbiAgKTtcbiAgY29uZmlnLmJhc2VEaXIgPSBjb25maWcuYmFzZURpciB8fCBiYXNlRGlyO1xuICBjb25maWcudHJpbW1lZCA9IGNvbmZpZy50cmltbWVkID09PSB0cnVlO1xuICByZXR1cm4gY29uZmlnO1xufVxudmFyIGRlZmF1bHRPcHRpb25zO1xudmFyIGluaXRfc2ltcGxlX2dpdF9vcHRpb25zID0gX19lc20oe1xuICBcInNyYy9saWIvdXRpbHMvc2ltcGxlLWdpdC1vcHRpb25zLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBiaW5hcnk6IFwiZ2l0XCIsXG4gICAgICBtYXhDb25jdXJyZW50UHJvY2Vzc2VzOiA1LFxuICAgICAgY29uZmlnOiBbXSxcbiAgICAgIHRyaW1tZWQ6IGZhbHNlXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdXRpbHMvdGFzay1vcHRpb25zLnRzXG5mdW5jdGlvbiBhcHBlbmRUYXNrT3B0aW9ucyhvcHRpb25zLCBjb21tYW5kcyA9IFtdKSB7XG4gIGlmICghZmlsdGVyUGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICByZXR1cm4gY29tbWFuZHM7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9wdGlvbnMpLnJlZHVjZSgoY29tbWFuZHMyLCBrZXkpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnNba2V5XTtcbiAgICBpZiAoaXNQYXRoU3BlYyh2YWx1ZSkpIHtcbiAgICAgIGNvbW1hbmRzMi5wdXNoKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGZpbHRlclByaW1pdGl2ZXModmFsdWUsIFtcImJvb2xlYW5cIl0pKSB7XG4gICAgICBjb21tYW5kczIucHVzaChrZXkgKyBcIj1cIiArIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWFuZHMyLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbW1hbmRzMjtcbiAgfSwgY29tbWFuZHMpO1xufVxuZnVuY3Rpb24gZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3MsIGluaXRpYWxQcmltaXRpdmUgPSAwLCBvYmplY3RPbmx5ID0gZmFsc2UpIHtcbiAgY29uc3QgY29tbWFuZCA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgbWF4ID0gaW5pdGlhbFByaW1pdGl2ZSA8IDAgPyBhcmdzLmxlbmd0aCA6IGluaXRpYWxQcmltaXRpdmU7IGkgPCBtYXg7IGkrKykge1xuICAgIGlmIChcInN0cmluZ3xudW1iZXJcIi5pbmNsdWRlcyh0eXBlb2YgYXJnc1tpXSkpIHtcbiAgICAgIGNvbW1hbmQucHVzaChTdHJpbmcoYXJnc1tpXSkpO1xuICAgIH1cbiAgfVxuICBhcHBlbmRUYXNrT3B0aW9ucyh0cmFpbGluZ09wdGlvbnNBcmd1bWVudChhcmdzKSwgY29tbWFuZCk7XG4gIGlmICghb2JqZWN0T25seSkge1xuICAgIGNvbW1hbmQucHVzaCguLi50cmFpbGluZ0FycmF5QXJndW1lbnQoYXJncykpO1xuICB9XG4gIHJldHVybiBjb21tYW5kO1xufVxuZnVuY3Rpb24gdHJhaWxpbmdBcnJheUFyZ3VtZW50KGFyZ3MpIHtcbiAgY29uc3QgaGFzVHJhaWxpbmdDYWxsYmFjayA9IHR5cGVvZiBsYXN0KGFyZ3MpID09PSBcImZ1bmN0aW9uXCI7XG4gIHJldHVybiBmaWx0ZXJUeXBlKGxhc3QoYXJncywgaGFzVHJhaWxpbmdDYWxsYmFjayA/IDEgOiAwKSwgZmlsdGVyQXJyYXksIFtdKTtcbn1cbmZ1bmN0aW9uIHRyYWlsaW5nT3B0aW9uc0FyZ3VtZW50KGFyZ3MpIHtcbiAgY29uc3QgaGFzVHJhaWxpbmdDYWxsYmFjayA9IGZpbHRlckZ1bmN0aW9uKGxhc3QoYXJncykpO1xuICByZXR1cm4gZmlsdGVyVHlwZShsYXN0KGFyZ3MsIGhhc1RyYWlsaW5nQ2FsbGJhY2sgPyAxIDogMCksIGZpbHRlclBsYWluT2JqZWN0KTtcbn1cbmZ1bmN0aW9uIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmdzLCBpbmNsdWRlTm9vcCA9IHRydWUpIHtcbiAgY29uc3QgY2FsbGJhY2sgPSBhc0Z1bmN0aW9uKGxhc3QoYXJncykpO1xuICByZXR1cm4gaW5jbHVkZU5vb3AgfHwgaXNVc2VyRnVuY3Rpb24oY2FsbGJhY2spID8gY2FsbGJhY2sgOiB2b2lkIDA7XG59XG52YXIgaW5pdF90YXNrX29wdGlvbnMgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi91dGlscy90YXNrLW9wdGlvbnMudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X2FyZ3VtZW50X2ZpbHRlcnMoKTtcbiAgICBpbml0X3V0aWwoKTtcbiAgICBpbml0X3BhdGhzcGVjKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3V0aWxzL3Rhc2stcGFyc2VyLnRzXG5mdW5jdGlvbiBjYWxsVGFza1BhcnNlcihwYXJzZXI0LCBzdHJlYW1zKSB7XG4gIHJldHVybiBwYXJzZXI0KHN0cmVhbXMuc3RkT3V0LCBzdHJlYW1zLnN0ZEVycik7XG59XG5mdW5jdGlvbiBwYXJzZVN0cmluZ1Jlc3BvbnNlKHJlc3VsdCwgcGFyc2VyczEyLCB0ZXh0cywgdHJpbSA9IHRydWUpIHtcbiAgYXNBcnJheSh0ZXh0cykuZm9yRWFjaCgodGV4dCkgPT4ge1xuICAgIGZvciAobGV0IGxpbmVzID0gdG9MaW5lc1dpdGhDb250ZW50KHRleHQsIHRyaW0pLCBpID0gMCwgbWF4ID0gbGluZXMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmUgPSAob2Zmc2V0ID0gMCkgPT4ge1xuICAgICAgICBpZiAoaSArIG9mZnNldCA+PSBtYXgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVzW2kgKyBvZmZzZXRdO1xuICAgICAgfTtcbiAgICAgIHBhcnNlcnMxMi5zb21lKCh7IHBhcnNlIH0pID0+IHBhcnNlKGxpbmUsIHJlc3VsdCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgaW5pdF90YXNrX3BhcnNlciA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3V0aWxzL3Rhc2stcGFyc2VyLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlsKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3V0aWxzL2luZGV4LnRzXG52YXIgdXRpbHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodXRpbHNfZXhwb3J0cywge1xuICBFeGl0Q29kZXM6ICgpID0+IEV4aXRDb2RlcyxcbiAgR2l0T3V0cHV0U3RyZWFtczogKCkgPT4gR2l0T3V0cHV0U3RyZWFtcyxcbiAgTGluZVBhcnNlcjogKCkgPT4gTGluZVBhcnNlcixcbiAgTk9PUDogKCkgPT4gTk9PUCxcbiAgTlVMTDogKCkgPT4gTlVMTCxcbiAgUmVtb3RlTGluZVBhcnNlcjogKCkgPT4gUmVtb3RlTGluZVBhcnNlcixcbiAgYXBwZW5kOiAoKSA9PiBhcHBlbmQsXG4gIGFwcGVuZFRhc2tPcHRpb25zOiAoKSA9PiBhcHBlbmRUYXNrT3B0aW9ucyxcbiAgYXNBcnJheTogKCkgPT4gYXNBcnJheSxcbiAgYXNDYW1lbENhc2U6ICgpID0+IGFzQ2FtZWxDYXNlLFxuICBhc0Z1bmN0aW9uOiAoKSA9PiBhc0Z1bmN0aW9uLFxuICBhc051bWJlcjogKCkgPT4gYXNOdW1iZXIsXG4gIGFzU3RyaW5nQXJyYXk6ICgpID0+IGFzU3RyaW5nQXJyYXksXG4gIGJ1ZmZlclRvU3RyaW5nOiAoKSA9PiBidWZmZXJUb1N0cmluZyxcbiAgY2FsbFRhc2tQYXJzZXI6ICgpID0+IGNhbGxUYXNrUGFyc2VyLFxuICBjcmVhdGVJbnN0YW5jZUNvbmZpZzogKCkgPT4gY3JlYXRlSW5zdGFuY2VDb25maWcsXG4gIGRlbGF5OiAoKSA9PiBkZWxheSxcbiAgZmlsdGVyQXJyYXk6ICgpID0+IGZpbHRlckFycmF5LFxuICBmaWx0ZXJGdW5jdGlvbjogKCkgPT4gZmlsdGVyRnVuY3Rpb24sXG4gIGZpbHRlckhhc0xlbmd0aDogKCkgPT4gZmlsdGVySGFzTGVuZ3RoLFxuICBmaWx0ZXJQbGFpbk9iamVjdDogKCkgPT4gZmlsdGVyUGxhaW5PYmplY3QsXG4gIGZpbHRlclByaW1pdGl2ZXM6ICgpID0+IGZpbHRlclByaW1pdGl2ZXMsXG4gIGZpbHRlclN0cmluZzogKCkgPT4gZmlsdGVyU3RyaW5nLFxuICBmaWx0ZXJTdHJpbmdBcnJheTogKCkgPT4gZmlsdGVyU3RyaW5nQXJyYXksXG4gIGZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXk6ICgpID0+IGZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXksXG4gIGZpbHRlclR5cGU6ICgpID0+IGZpbHRlclR5cGUsXG4gIGZpcnN0OiAoKSA9PiBmaXJzdCxcbiAgZm9sZGVyRXhpc3RzOiAoKSA9PiBmb2xkZXJFeGlzdHMsXG4gIGZvckVhY2hMaW5lV2l0aENvbnRlbnQ6ICgpID0+IGZvckVhY2hMaW5lV2l0aENvbnRlbnQsXG4gIGdldFRyYWlsaW5nT3B0aW9uczogKCkgPT4gZ2V0VHJhaWxpbmdPcHRpb25zLFxuICBpbmNsdWRpbmc6ICgpID0+IGluY2x1ZGluZyxcbiAgaXNVc2VyRnVuY3Rpb246ICgpID0+IGlzVXNlckZ1bmN0aW9uLFxuICBsYXN0OiAoKSA9PiBsYXN0LFxuICBvYmplY3RUb1N0cmluZzogKCkgPT4gb2JqZWN0VG9TdHJpbmcsXG4gIG9yVm9pZDogKCkgPT4gb3JWb2lkLFxuICBwYXJzZVN0cmluZ1Jlc3BvbnNlOiAoKSA9PiBwYXJzZVN0cmluZ1Jlc3BvbnNlLFxuICBwaWNrOiAoKSA9PiBwaWNrLFxuICBwcmVmaXhlZEFycmF5OiAoKSA9PiBwcmVmaXhlZEFycmF5LFxuICByZW1vdmU6ICgpID0+IHJlbW92ZSxcbiAgc3BsaXRPbjogKCkgPT4gc3BsaXRPbixcbiAgdG9MaW5lc1dpdGhDb250ZW50OiAoKSA9PiB0b0xpbmVzV2l0aENvbnRlbnQsXG4gIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDogKCkgPT4gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50LFxuICB0cmFpbGluZ09wdGlvbnNBcmd1bWVudDogKCkgPT4gdHJhaWxpbmdPcHRpb25zQXJndW1lbnRcbn0pO1xudmFyIGluaXRfdXRpbHMgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi91dGlscy9pbmRleC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfYXJndW1lbnRfZmlsdGVycygpO1xuICAgIGluaXRfZXhpdF9jb2RlcygpO1xuICAgIGluaXRfZ2l0X291dHB1dF9zdHJlYW1zKCk7XG4gICAgaW5pdF9saW5lX3BhcnNlcigpO1xuICAgIGluaXRfc2ltcGxlX2dpdF9vcHRpb25zKCk7XG4gICAgaW5pdF90YXNrX29wdGlvbnMoKTtcbiAgICBpbml0X3Rhc2tfcGFyc2VyKCk7XG4gICAgaW5pdF91dGlsKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL2NoZWNrLWlzLXJlcG8udHNcbnZhciBjaGVja19pc19yZXBvX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGNoZWNrX2lzX3JlcG9fZXhwb3J0cywge1xuICBDaGVja1JlcG9BY3Rpb25zOiAoKSA9PiBDaGVja1JlcG9BY3Rpb25zLFxuICBjaGVja0lzQmFyZVJlcG9UYXNrOiAoKSA9PiBjaGVja0lzQmFyZVJlcG9UYXNrLFxuICBjaGVja0lzUmVwb1Jvb3RUYXNrOiAoKSA9PiBjaGVja0lzUmVwb1Jvb3RUYXNrLFxuICBjaGVja0lzUmVwb1Rhc2s6ICgpID0+IGNoZWNrSXNSZXBvVGFza1xufSk7XG5mdW5jdGlvbiBjaGVja0lzUmVwb1Rhc2soYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgY2FzZSBcImJhcmVcIiAvKiBCQVJFICovOlxuICAgICAgcmV0dXJuIGNoZWNrSXNCYXJlUmVwb1Rhc2soKTtcbiAgICBjYXNlIFwicm9vdFwiIC8qIElTX1JFUE9fUk9PVCAqLzpcbiAgICAgIHJldHVybiBjaGVja0lzUmVwb1Jvb3RUYXNrKCk7XG4gIH1cbiAgY29uc3QgY29tbWFuZHMgPSBbXCJyZXYtcGFyc2VcIiwgXCItLWlzLWluc2lkZS13b3JrLXRyZWVcIl07XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHMsXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgb25FcnJvcixcbiAgICBwYXJzZXJcbiAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrSXNSZXBvUm9vdFRhc2soKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wicmV2LXBhcnNlXCIsIFwiLS1naXQtZGlyXCJdO1xuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIG9uRXJyb3IsXG4gICAgcGFyc2VyKHBhdGgpIHtcbiAgICAgIHJldHVybiAvXlxcLihnaXQpPyQvLnRlc3QocGF0aC50cmltKCkpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrSXNCYXJlUmVwb1Rhc2soKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wicmV2LXBhcnNlXCIsIFwiLS1pcy1iYXJlLXJlcG9zaXRvcnlcIl07XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHMsXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgb25FcnJvcixcbiAgICBwYXJzZXJcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzTm90UmVwb01lc3NhZ2UoZXJyb3IpIHtcbiAgcmV0dXJuIC8oTm90IGEgZ2l0IHJlcG9zaXRvcnl8S2VpbiBHaXQtUmVwb3NpdG9yeSkvaS50ZXN0KFN0cmluZyhlcnJvcikpO1xufVxudmFyIENoZWNrUmVwb0FjdGlvbnMsIG9uRXJyb3IsIHBhcnNlcjtcbnZhciBpbml0X2NoZWNrX2lzX3JlcG8gPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9jaGVjay1pcy1yZXBvLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlscygpO1xuICAgIENoZWNrUmVwb0FjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gKChDaGVja1JlcG9BY3Rpb25zMikgPT4ge1xuICAgICAgQ2hlY2tSZXBvQWN0aW9uczJbXCJCQVJFXCJdID0gXCJiYXJlXCI7XG4gICAgICBDaGVja1JlcG9BY3Rpb25zMltcIklOX1RSRUVcIl0gPSBcInRyZWVcIjtcbiAgICAgIENoZWNrUmVwb0FjdGlvbnMyW1wiSVNfUkVQT19ST09UXCJdID0gXCJyb290XCI7XG4gICAgICByZXR1cm4gQ2hlY2tSZXBvQWN0aW9uczI7XG4gICAgfSkoQ2hlY2tSZXBvQWN0aW9ucyB8fCB7fSk7XG4gICAgb25FcnJvciA9ICh7IGV4aXRDb2RlIH0sIGVycm9yLCBkb25lLCBmYWlsKSA9PiB7XG4gICAgICBpZiAoZXhpdENvZGUgPT09IDEyOCAvKiBVTkNMRUFOICovICYmIGlzTm90UmVwb01lc3NhZ2UoZXJyb3IpKSB7XG4gICAgICAgIHJldHVybiBkb25lKEJ1ZmZlci5mcm9tKFwiZmFsc2VcIikpO1xuICAgICAgfVxuICAgICAgZmFpbChlcnJvcik7XG4gICAgfTtcbiAgICBwYXJzZXIgPSAodGV4dCkgPT4ge1xuICAgICAgcmV0dXJuIHRleHQudHJpbSgpID09PSBcInRydWVcIjtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9yZXNwb25zZXMvQ2xlYW5TdW1tYXJ5LnRzXG5mdW5jdGlvbiBjbGVhblN1bW1hcnlQYXJzZXIoZHJ5UnVuLCB0ZXh0KSB7XG4gIGNvbnN0IHN1bW1hcnkgPSBuZXcgQ2xlYW5SZXNwb25zZShkcnlSdW4pO1xuICBjb25zdCByZWdleHAgPSBkcnlSdW4gPyBkcnlSdW5SZW1vdmFsUmVnZXhwIDogcmVtb3ZhbFJlZ2V4cDtcbiAgdG9MaW5lc1dpdGhDb250ZW50KHRleHQpLmZvckVhY2goKGxpbmUpID0+IHtcbiAgICBjb25zdCByZW1vdmVkID0gbGluZS5yZXBsYWNlKHJlZ2V4cCwgXCJcIik7XG4gICAgc3VtbWFyeS5wYXRocy5wdXNoKHJlbW92ZWQpO1xuICAgIChpc0ZvbGRlclJlZ2V4cC50ZXN0KHJlbW92ZWQpID8gc3VtbWFyeS5mb2xkZXJzIDogc3VtbWFyeS5maWxlcykucHVzaChyZW1vdmVkKTtcbiAgfSk7XG4gIHJldHVybiBzdW1tYXJ5O1xufVxudmFyIENsZWFuUmVzcG9uc2UsIHJlbW92YWxSZWdleHAsIGRyeVJ1blJlbW92YWxSZWdleHAsIGlzRm9sZGVyUmVnZXhwO1xudmFyIGluaXRfQ2xlYW5TdW1tYXJ5ID0gX19lc20oe1xuICBcInNyYy9saWIvcmVzcG9uc2VzL0NsZWFuU3VtbWFyeS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBDbGVhblJlc3BvbnNlID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoZHJ5UnVuKSB7XG4gICAgICAgIHRoaXMuZHJ5UnVuID0gZHJ5UnVuO1xuICAgICAgICB0aGlzLnBhdGhzID0gW107XG4gICAgICAgIHRoaXMuZmlsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5mb2xkZXJzID0gW107XG4gICAgICB9XG4gICAgfTtcbiAgICByZW1vdmFsUmVnZXhwID0gL15bYS16XStcXHMqL2k7XG4gICAgZHJ5UnVuUmVtb3ZhbFJlZ2V4cCA9IC9eW2Etel0rXFxzK1thLXpdK1xccyovaTtcbiAgICBpc0ZvbGRlclJlZ2V4cCA9IC9cXC8kLztcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvdGFzay50c1xudmFyIHRhc2tfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodGFza19leHBvcnRzLCB7XG4gIEVNUFRZX0NPTU1BTkRTOiAoKSA9PiBFTVBUWV9DT01NQU5EUyxcbiAgYWRob2NFeGVjVGFzazogKCkgPT4gYWRob2NFeGVjVGFzayxcbiAgY29uZmlndXJhdGlvbkVycm9yVGFzazogKCkgPT4gY29uZmlndXJhdGlvbkVycm9yVGFzayxcbiAgaXNCdWZmZXJUYXNrOiAoKSA9PiBpc0J1ZmZlclRhc2ssXG4gIGlzRW1wdHlUYXNrOiAoKSA9PiBpc0VtcHR5VGFzayxcbiAgc3RyYWlnaHRUaHJvdWdoQnVmZmVyVGFzazogKCkgPT4gc3RyYWlnaHRUaHJvdWdoQnVmZmVyVGFzayxcbiAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzazogKCkgPT4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFza1xufSk7XG5mdW5jdGlvbiBhZGhvY0V4ZWNUYXNrKHBhcnNlcjQpIHtcbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kczogRU1QVFlfQ09NTUFORFMsXG4gICAgZm9ybWF0OiBcImVtcHR5XCIsXG4gICAgcGFyc2VyOiBwYXJzZXI0XG4gIH07XG59XG5mdW5jdGlvbiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHM6IEVNUFRZX0NPTU1BTkRTLFxuICAgIGZvcm1hdDogXCJlbXB0eVwiLFxuICAgIHBhcnNlcigpIHtcbiAgICAgIHRocm93IHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIiA/IG5ldyBUYXNrQ29uZmlndXJhdGlvbkVycm9yKGVycm9yKSA6IGVycm9yO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMsIHRyaW1tZWQyID0gZmFsc2UpIHtcbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXIodGV4dCkge1xuICAgICAgcmV0dXJuIHRyaW1tZWQyID8gU3RyaW5nKHRleHQpLnRyaW0oKSA6IHRleHQ7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gc3RyYWlnaHRUaHJvdWdoQnVmZmVyVGFzayhjb21tYW5kcykge1xuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzLFxuICAgIGZvcm1hdDogXCJidWZmZXJcIixcbiAgICBwYXJzZXIoYnVmZmVyKSB7XG4gICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQnVmZmVyVGFzayh0YXNrKSB7XG4gIHJldHVybiB0YXNrLmZvcm1hdCA9PT0gXCJidWZmZXJcIjtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlUYXNrKHRhc2spIHtcbiAgcmV0dXJuIHRhc2suZm9ybWF0ID09PSBcImVtcHR5XCIgfHwgIXRhc2suY29tbWFuZHMubGVuZ3RoO1xufVxudmFyIEVNUFRZX0NPTU1BTkRTO1xudmFyIGluaXRfdGFzayA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL3Rhc2sudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3Rhc2tfY29uZmlndXJhdGlvbl9lcnJvcigpO1xuICAgIEVNUFRZX0NPTU1BTkRTID0gW107XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL2NsZWFuLnRzXG52YXIgY2xlYW5fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoY2xlYW5fZXhwb3J0cywge1xuICBDT05GSUdfRVJST1JfSU5URVJBQ1RJVkVfTU9ERTogKCkgPT4gQ09ORklHX0VSUk9SX0lOVEVSQUNUSVZFX01PREUsXG4gIENPTkZJR19FUlJPUl9NT0RFX1JFUVVJUkVEOiAoKSA9PiBDT05GSUdfRVJST1JfTU9ERV9SRVFVSVJFRCxcbiAgQ09ORklHX0VSUk9SX1VOS05PV05fT1BUSU9OOiAoKSA9PiBDT05GSUdfRVJST1JfVU5LTk9XTl9PUFRJT04sXG4gIENsZWFuT3B0aW9uczogKCkgPT4gQ2xlYW5PcHRpb25zLFxuICBjbGVhblRhc2s6ICgpID0+IGNsZWFuVGFzayxcbiAgY2xlYW5XaXRoT3B0aW9uc1Rhc2s6ICgpID0+IGNsZWFuV2l0aE9wdGlvbnNUYXNrLFxuICBpc0NsZWFuT3B0aW9uc0FycmF5OiAoKSA9PiBpc0NsZWFuT3B0aW9uc0FycmF5XG59KTtcbmZ1bmN0aW9uIGNsZWFuV2l0aE9wdGlvbnNUYXNrKG1vZGUsIGN1c3RvbUFyZ3MpIHtcbiAgY29uc3QgeyBjbGVhbk1vZGUsIG9wdGlvbnMsIHZhbGlkIH0gPSBnZXRDbGVhbk9wdGlvbnMobW9kZSk7XG4gIGlmICghY2xlYW5Nb2RlKSB7XG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soQ09ORklHX0VSUk9SX01PREVfUkVRVUlSRUQpO1xuICB9XG4gIGlmICghdmFsaWQub3B0aW9ucykge1xuICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKENPTkZJR19FUlJPUl9VTktOT1dOX09QVElPTiArIEpTT04uc3RyaW5naWZ5KG1vZGUpKTtcbiAgfVxuICBvcHRpb25zLnB1c2goLi4uY3VzdG9tQXJncyk7XG4gIGlmIChvcHRpb25zLnNvbWUoaXNJbnRlcmFjdGl2ZU1vZGUpKSB7XG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soQ09ORklHX0VSUk9SX0lOVEVSQUNUSVZFX01PREUpO1xuICB9XG4gIHJldHVybiBjbGVhblRhc2soY2xlYW5Nb2RlLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGNsZWFuVGFzayhtb2RlLCBjdXN0b21BcmdzKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wiY2xlYW5cIiwgYC0ke21vZGV9YCwgLi4uY3VzdG9tQXJnc107XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHMsXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyKHRleHQpIHtcbiAgICAgIHJldHVybiBjbGVhblN1bW1hcnlQYXJzZXIobW9kZSA9PT0gXCJuXCIgLyogRFJZX1JVTiAqLywgdGV4dCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaXNDbGVhbk9wdGlvbnNBcnJheShpbnB1dCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dCkgJiYgaW5wdXQuZXZlcnkoKHRlc3QpID0+IENsZWFuT3B0aW9uVmFsdWVzLmhhcyh0ZXN0KSk7XG59XG5mdW5jdGlvbiBnZXRDbGVhbk9wdGlvbnMoaW5wdXQpIHtcbiAgbGV0IGNsZWFuTW9kZTtcbiAgbGV0IG9wdGlvbnMgPSBbXTtcbiAgbGV0IHZhbGlkID0geyBjbGVhbk1vZGU6IGZhbHNlLCBvcHRpb25zOiB0cnVlIH07XG4gIGlucHV0LnJlcGxhY2UoL1teYS16XWkvZywgXCJcIikuc3BsaXQoXCJcIikuZm9yRWFjaCgoY2hhcikgPT4ge1xuICAgIGlmIChpc0NsZWFuTW9kZShjaGFyKSkge1xuICAgICAgY2xlYW5Nb2RlID0gY2hhcjtcbiAgICAgIHZhbGlkLmNsZWFuTW9kZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkLm9wdGlvbnMgPSB2YWxpZC5vcHRpb25zICYmIGlzS25vd25PcHRpb24ob3B0aW9uc1tvcHRpb25zLmxlbmd0aF0gPSBgLSR7Y2hhcn1gKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGNsZWFuTW9kZSxcbiAgICBvcHRpb25zLFxuICAgIHZhbGlkXG4gIH07XG59XG5mdW5jdGlvbiBpc0NsZWFuTW9kZShjbGVhbk1vZGUpIHtcbiAgcmV0dXJuIGNsZWFuTW9kZSA9PT0gXCJmXCIgLyogRk9SQ0UgKi8gfHwgY2xlYW5Nb2RlID09PSBcIm5cIiAvKiBEUllfUlVOICovO1xufVxuZnVuY3Rpb24gaXNLbm93bk9wdGlvbihvcHRpb24pIHtcbiAgcmV0dXJuIC9eLVthLXpdJC9pLnRlc3Qob3B0aW9uKSAmJiBDbGVhbk9wdGlvblZhbHVlcy5oYXMob3B0aW9uLmNoYXJBdCgxKSk7XG59XG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlTW9kZShvcHRpb24pIHtcbiAgaWYgKC9eLVteXFwtXS8udGVzdChvcHRpb24pKSB7XG4gICAgcmV0dXJuIG9wdGlvbi5pbmRleE9mKFwiaVwiKSA+IDA7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbiA9PT0gXCItLWludGVyYWN0aXZlXCI7XG59XG52YXIgQ09ORklHX0VSUk9SX0lOVEVSQUNUSVZFX01PREUsIENPTkZJR19FUlJPUl9NT0RFX1JFUVVJUkVELCBDT05GSUdfRVJST1JfVU5LTk9XTl9PUFRJT04sIENsZWFuT3B0aW9ucywgQ2xlYW5PcHRpb25WYWx1ZXM7XG52YXIgaW5pdF9jbGVhbiA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2NsZWFuLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9DbGVhblN1bW1hcnkoKTtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF90YXNrKCk7XG4gICAgQ09ORklHX0VSUk9SX0lOVEVSQUNUSVZFX01PREUgPSBcIkdpdCBjbGVhbiBpbnRlcmFjdGl2ZSBtb2RlIGlzIG5vdCBzdXBwb3J0ZWRcIjtcbiAgICBDT05GSUdfRVJST1JfTU9ERV9SRVFVSVJFRCA9ICdHaXQgY2xlYW4gbW9kZSBwYXJhbWV0ZXIgKFwiblwiIG9yIFwiZlwiKSBpcyByZXF1aXJlZCc7XG4gICAgQ09ORklHX0VSUk9SX1VOS05PV05fT1BUSU9OID0gXCJHaXQgY2xlYW4gdW5rbm93biBvcHRpb24gZm91bmQgaW46IFwiO1xuICAgIENsZWFuT3B0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyAoKENsZWFuT3B0aW9uczIpID0+IHtcbiAgICAgIENsZWFuT3B0aW9uczJbXCJEUllfUlVOXCJdID0gXCJuXCI7XG4gICAgICBDbGVhbk9wdGlvbnMyW1wiRk9SQ0VcIl0gPSBcImZcIjtcbiAgICAgIENsZWFuT3B0aW9uczJbXCJJR05PUkVEX0lOQ0xVREVEXCJdID0gXCJ4XCI7XG4gICAgICBDbGVhbk9wdGlvbnMyW1wiSUdOT1JFRF9PTkxZXCJdID0gXCJYXCI7XG4gICAgICBDbGVhbk9wdGlvbnMyW1wiRVhDTFVESU5HXCJdID0gXCJlXCI7XG4gICAgICBDbGVhbk9wdGlvbnMyW1wiUVVJRVRcIl0gPSBcInFcIjtcbiAgICAgIENsZWFuT3B0aW9uczJbXCJSRUNVUlNJVkVcIl0gPSBcImRcIjtcbiAgICAgIHJldHVybiBDbGVhbk9wdGlvbnMyO1xuICAgIH0pKENsZWFuT3B0aW9ucyB8fCB7fSk7XG4gICAgQ2xlYW5PcHRpb25WYWx1ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gICAgICBcImlcIixcbiAgICAgIC4uLmFzU3RyaW5nQXJyYXkoT2JqZWN0LnZhbHVlcyhDbGVhbk9wdGlvbnMpKVxuICAgIF0pO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9yZXNwb25zZXMvQ29uZmlnTGlzdC50c1xuZnVuY3Rpb24gY29uZmlnTGlzdFBhcnNlcih0ZXh0KSB7XG4gIGNvbnN0IGNvbmZpZyA9IG5ldyBDb25maWdMaXN0KCk7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBjb25maWdQYXJzZXIodGV4dCkpIHtcbiAgICBjb25maWcuYWRkVmFsdWUoaXRlbS5maWxlLCBTdHJpbmcoaXRlbS5rZXkpLCBpdGVtLnZhbHVlKTtcbiAgfVxuICByZXR1cm4gY29uZmlnO1xufVxuZnVuY3Rpb24gY29uZmlnR2V0UGFyc2VyKHRleHQsIGtleSkge1xuICBsZXQgdmFsdWUgPSBudWxsO1xuICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgY29uc3Qgc2NvcGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBpdGVtIG9mIGNvbmZpZ1BhcnNlcih0ZXh0LCBrZXkpKSB7XG4gICAgaWYgKGl0ZW0ua2V5ICE9PSBrZXkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YWx1ZXMucHVzaCh2YWx1ZSA9IGl0ZW0udmFsdWUpO1xuICAgIGlmICghc2NvcGVzLmhhcyhpdGVtLmZpbGUpKSB7XG4gICAgICBzY29wZXMuc2V0KGl0ZW0uZmlsZSwgW10pO1xuICAgIH1cbiAgICBzY29wZXMuZ2V0KGl0ZW0uZmlsZSkucHVzaCh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBrZXksXG4gICAgcGF0aHM6IEFycmF5LmZyb20oc2NvcGVzLmtleXMoKSksXG4gICAgc2NvcGVzLFxuICAgIHZhbHVlLFxuICAgIHZhbHVlc1xuICB9O1xufVxuZnVuY3Rpb24gY29uZmlnRmlsZVBhdGgoZmlsZVBhdGgpIHtcbiAgcmV0dXJuIGZpbGVQYXRoLnJlcGxhY2UoL14oZmlsZSk6LywgXCJcIik7XG59XG5mdW5jdGlvbiogY29uZmlnUGFyc2VyKHRleHQsIHJlcXVlc3RlZEtleSA9IG51bGwpIHtcbiAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KFwiXFwwXCIpO1xuICBmb3IgKGxldCBpID0gMCwgbWF4ID0gbGluZXMubGVuZ3RoIC0gMTsgaSA8IG1heDsgKSB7XG4gICAgY29uc3QgZmlsZSA9IGNvbmZpZ0ZpbGVQYXRoKGxpbmVzW2krK10pO1xuICAgIGxldCB2YWx1ZSA9IGxpbmVzW2krK107XG4gICAgbGV0IGtleSA9IHJlcXVlc3RlZEtleTtcbiAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBzcGxpdE9uKHZhbHVlLCBcIlxcblwiKTtcbiAgICAgIGtleSA9IGxpbmVbMF07XG4gICAgICB2YWx1ZSA9IGxpbmVbMV07XG4gICAgfVxuICAgIHlpZWxkIHsgZmlsZSwga2V5LCB2YWx1ZSB9O1xuICB9XG59XG52YXIgQ29uZmlnTGlzdDtcbnZhciBpbml0X0NvbmZpZ0xpc3QgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9yZXNwb25zZXMvQ29uZmlnTGlzdC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBDb25maWdMaXN0ID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZmlsZXMgPSBbXTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIGdldCBhbGwoKSB7XG4gICAgICAgIGlmICghdGhpcy5fYWxsKSB7XG4gICAgICAgICAgdGhpcy5fYWxsID0gdGhpcy5maWxlcy5yZWR1Y2UoKGFsbCwgZmlsZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWxsLCB0aGlzLnZhbHVlc1tmaWxlXSk7XG4gICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGw7XG4gICAgICB9XG4gICAgICBhZGRGaWxlKGZpbGUpIHtcbiAgICAgICAgaWYgKCEoZmlsZSBpbiB0aGlzLnZhbHVlcykpIHtcbiAgICAgICAgICBjb25zdCBsYXRlc3QgPSBsYXN0KHRoaXMuZmlsZXMpO1xuICAgICAgICAgIHRoaXMudmFsdWVzW2ZpbGVdID0gbGF0ZXN0ID8gT2JqZWN0LmNyZWF0ZSh0aGlzLnZhbHVlc1tsYXRlc3RdKSA6IHt9O1xuICAgICAgICAgIHRoaXMuZmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbZmlsZV07XG4gICAgICB9XG4gICAgICBhZGRWYWx1ZShmaWxlLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuYWRkRmlsZShmaWxlKTtcbiAgICAgICAgaWYgKCF2YWx1ZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhbHVlc1trZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXNba2V5XSkpIHtcbiAgICAgICAgICB2YWx1ZXNba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZXNba2V5XSA9IFt2YWx1ZXNba2V5XSwgdmFsdWVdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FsbCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9jb25maWcudHNcbmZ1bmN0aW9uIGFzQ29uZmlnU2NvcGUoc2NvcGUsIGZhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygc2NvcGUgPT09IFwic3RyaW5nXCIgJiYgR2l0Q29uZmlnU2NvcGUuaGFzT3duUHJvcGVydHkoc2NvcGUpKSB7XG4gICAgcmV0dXJuIHNjb3BlO1xuICB9XG4gIHJldHVybiBmYWxsYmFjaztcbn1cbmZ1bmN0aW9uIGFkZENvbmZpZ1Rhc2soa2V5LCB2YWx1ZSwgYXBwZW5kMiwgc2NvcGUpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbXCJjb25maWdcIiwgYC0tJHtzY29wZX1gXTtcbiAgaWYgKGFwcGVuZDIpIHtcbiAgICBjb21tYW5kcy5wdXNoKFwiLS1hZGRcIik7XG4gIH1cbiAgY29tbWFuZHMucHVzaChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXIodGV4dCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q29uZmlnVGFzayhrZXksIHNjb3BlKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wiY29uZmlnXCIsIFwiLS1udWxsXCIsIFwiLS1zaG93LW9yaWdpblwiLCBcIi0tZ2V0LWFsbFwiLCBrZXldO1xuICBpZiAoc2NvcGUpIHtcbiAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgYC0tJHtzY29wZX1gKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIHBhcnNlcih0ZXh0KSB7XG4gICAgICByZXR1cm4gY29uZmlnR2V0UGFyc2VyKHRleHQsIGtleSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbGlzdENvbmZpZ1Rhc2soc2NvcGUpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbXCJjb25maWdcIiwgXCItLWxpc3RcIiwgXCItLXNob3ctb3JpZ2luXCIsIFwiLS1udWxsXCJdO1xuICBpZiAoc2NvcGUpIHtcbiAgICBjb21tYW5kcy5wdXNoKGAtLSR7c2NvcGV9YCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXIodGV4dCkge1xuICAgICAgcmV0dXJuIGNvbmZpZ0xpc3RQYXJzZXIodGV4dCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY29uZmlnX2RlZmF1bHQoKSB7XG4gIHJldHVybiB7XG4gICAgYWRkQ29uZmlnKGtleSwgdmFsdWUsIC4uLnJlc3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBhZGRDb25maWdUYXNrKFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICByZXN0WzBdID09PSB0cnVlLFxuICAgICAgICAgIGFzQ29uZmlnU2NvcGUocmVzdFsxXSwgXCJsb2NhbFwiIC8qIGxvY2FsICovKVxuICAgICAgICApLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGdldENvbmZpZyhrZXksIHNjb3BlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgZ2V0Q29uZmlnVGFzayhrZXksIGFzQ29uZmlnU2NvcGUoc2NvcGUsIHZvaWQgMCkpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGxpc3RDb25maWcoLi4ucmVzdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGxpc3RDb25maWdUYXNrKGFzQ29uZmlnU2NvcGUocmVzdFswXSwgdm9pZCAwKSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cbnZhciBHaXRDb25maWdTY29wZTtcbnZhciBpbml0X2NvbmZpZyA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2NvbmZpZy50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfQ29uZmlnTGlzdCgpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBHaXRDb25maWdTY29wZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEdpdENvbmZpZ1Njb3BlMikgPT4ge1xuICAgICAgR2l0Q29uZmlnU2NvcGUyW1wic3lzdGVtXCJdID0gXCJzeXN0ZW1cIjtcbiAgICAgIEdpdENvbmZpZ1Njb3BlMltcImdsb2JhbFwiXSA9IFwiZ2xvYmFsXCI7XG4gICAgICBHaXRDb25maWdTY29wZTJbXCJsb2NhbFwiXSA9IFwibG9jYWxcIjtcbiAgICAgIEdpdENvbmZpZ1Njb3BlMltcIndvcmt0cmVlXCJdID0gXCJ3b3JrdHJlZVwiO1xuICAgICAgcmV0dXJuIEdpdENvbmZpZ1Njb3BlMjtcbiAgICB9KShHaXRDb25maWdTY29wZSB8fCB7fSk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL2RpZmYtbmFtZS1zdGF0dXMudHNcbmZ1bmN0aW9uIGlzRGlmZk5hbWVTdGF0dXMoaW5wdXQpIHtcbiAgcmV0dXJuIGRpZmZOYW1lU3RhdHVzLmhhcyhpbnB1dCk7XG59XG52YXIgRGlmZk5hbWVTdGF0dXMsIGRpZmZOYW1lU3RhdHVzO1xudmFyIGluaXRfZGlmZl9uYW1lX3N0YXR1cyA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2RpZmYtbmFtZS1zdGF0dXMudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBEaWZmTmFtZVN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKERpZmZOYW1lU3RhdHVzMikgPT4ge1xuICAgICAgRGlmZk5hbWVTdGF0dXMyW1wiQURERURcIl0gPSBcIkFcIjtcbiAgICAgIERpZmZOYW1lU3RhdHVzMltcIkNPUElFRFwiXSA9IFwiQ1wiO1xuICAgICAgRGlmZk5hbWVTdGF0dXMyW1wiREVMRVRFRFwiXSA9IFwiRFwiO1xuICAgICAgRGlmZk5hbWVTdGF0dXMyW1wiTU9ESUZJRURcIl0gPSBcIk1cIjtcbiAgICAgIERpZmZOYW1lU3RhdHVzMltcIlJFTkFNRURcIl0gPSBcIlJcIjtcbiAgICAgIERpZmZOYW1lU3RhdHVzMltcIkNIQU5HRURcIl0gPSBcIlRcIjtcbiAgICAgIERpZmZOYW1lU3RhdHVzMltcIlVOTUVSR0VEXCJdID0gXCJVXCI7XG4gICAgICBEaWZmTmFtZVN0YXR1czJbXCJVTktOT1dOXCJdID0gXCJYXCI7XG4gICAgICBEaWZmTmFtZVN0YXR1czJbXCJCUk9LRU5cIl0gPSBcIkJcIjtcbiAgICAgIHJldHVybiBEaWZmTmFtZVN0YXR1czI7XG4gICAgfSkoRGlmZk5hbWVTdGF0dXMgfHwge30pO1xuICAgIGRpZmZOYW1lU3RhdHVzID0gbmV3IFNldChPYmplY3QudmFsdWVzKERpZmZOYW1lU3RhdHVzKSk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL2dyZXAudHNcbmZ1bmN0aW9uIGdyZXBRdWVyeUJ1aWxkZXIoLi4ucGFyYW1zKSB7XG4gIHJldHVybiBuZXcgR3JlcFF1ZXJ5KCkucGFyYW0oLi4ucGFyYW1zKTtcbn1cbmZ1bmN0aW9uIHBhcnNlR3JlcChncmVwKSB7XG4gIGNvbnN0IHBhdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgcmVzdWx0cyA9IHt9O1xuICBmb3JFYWNoTGluZVdpdGhDb250ZW50KGdyZXAsIChpbnB1dCkgPT4ge1xuICAgIGNvbnN0IFtwYXRoLCBsaW5lLCBwcmV2aWV3XSA9IGlucHV0LnNwbGl0KE5VTEwpO1xuICAgIHBhdGhzLmFkZChwYXRoKTtcbiAgICAocmVzdWx0c1twYXRoXSA9IHJlc3VsdHNbcGF0aF0gfHwgW10pLnB1c2goe1xuICAgICAgbGluZTogYXNOdW1iZXIobGluZSksXG4gICAgICBwYXRoLFxuICAgICAgcHJldmlld1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwYXRocyxcbiAgICByZXN1bHRzXG4gIH07XG59XG5mdW5jdGlvbiBncmVwX2RlZmF1bHQoKSB7XG4gIHJldHVybiB7XG4gICAgZ3JlcChzZWFyY2hUZXJtKSB7XG4gICAgICBjb25zdCB0aGVuID0gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cyk7XG4gICAgICBjb25zdCBvcHRpb25zID0gZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cyk7XG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBkaXNhbGxvd2VkT3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5pbmNsdWRlcyhvcHRpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBjb25maWd1cmF0aW9uRXJyb3JUYXNrKGBnaXQuZ3JlcDogdXNlIG9mIFwiJHtvcHRpb259XCIgaXMgbm90IHN1cHBvcnRlZC5gKSxcbiAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHNlYXJjaFRlcm0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc2VhcmNoVGVybSA9IGdyZXBRdWVyeUJ1aWxkZXIoKS5wYXJhbShzZWFyY2hUZXJtKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbW1hbmRzID0gW1wiZ3JlcFwiLCBcIi0tbnVsbFwiLCBcIi1uXCIsIFwiLS1mdWxsLW5hbWVcIiwgLi4ub3B0aW9ucywgLi4uc2VhcmNoVGVybV07XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAge1xuICAgICAgICAgIGNvbW1hbmRzLFxuICAgICAgICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgICAgICAgIHBhcnNlcihzdGRPdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUdyZXAoc3RkT3V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRoZW5cbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxudmFyIGRpc2FsbG93ZWRPcHRpb25zLCBRdWVyeSwgX2EsIEdyZXBRdWVyeTtcbnZhciBpbml0X2dyZXAgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9ncmVwLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlscygpO1xuICAgIGluaXRfdGFzaygpO1xuICAgIGRpc2FsbG93ZWRPcHRpb25zID0gW1wiLWhcIl07XG4gICAgUXVlcnkgPSBTeW1ib2woXCJncmVwUXVlcnlcIik7XG4gICAgR3JlcFF1ZXJ5ID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXNbX2FdID0gW107XG4gICAgICB9XG4gICAgICAqWyhfYSA9IFF1ZXJ5LCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBxdWVyeSBvZiB0aGlzW1F1ZXJ5XSkge1xuICAgICAgICAgIHlpZWxkIHF1ZXJ5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhbmQoLi4uYW5kKSB7XG4gICAgICAgIGFuZC5sZW5ndGggJiYgdGhpc1tRdWVyeV0ucHVzaChcIi0tYW5kXCIsIFwiKFwiLCAuLi5wcmVmaXhlZEFycmF5KGFuZCwgXCItZVwiKSwgXCIpXCIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHBhcmFtKC4uLnBhcmFtKSB7XG4gICAgICAgIHRoaXNbUXVlcnldLnB1c2goLi4ucHJlZml4ZWRBcnJheShwYXJhbSwgXCItZVwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL3Jlc2V0LnRzXG52YXIgcmVzZXRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocmVzZXRfZXhwb3J0cywge1xuICBSZXNldE1vZGU6ICgpID0+IFJlc2V0TW9kZSxcbiAgZ2V0UmVzZXRNb2RlOiAoKSA9PiBnZXRSZXNldE1vZGUsXG4gIHJlc2V0VGFzazogKCkgPT4gcmVzZXRUYXNrXG59KTtcbmZ1bmN0aW9uIHJlc2V0VGFzayhtb2RlLCBjdXN0b21BcmdzKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wicmVzZXRcIl07XG4gIGlmIChpc1ZhbGlkUmVzZXRNb2RlKG1vZGUpKSB7XG4gICAgY29tbWFuZHMucHVzaChgLS0ke21vZGV9YCk7XG4gIH1cbiAgY29tbWFuZHMucHVzaCguLi5jdXN0b21BcmdzKTtcbiAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpO1xufVxuZnVuY3Rpb24gZ2V0UmVzZXRNb2RlKG1vZGUpIHtcbiAgaWYgKGlzVmFsaWRSZXNldE1vZGUobW9kZSkpIHtcbiAgICByZXR1cm4gbW9kZTtcbiAgfVxuICBzd2l0Y2ggKHR5cGVvZiBtb2RlKSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgIHJldHVybiBcInNvZnRcIiAvKiBTT0ZUICovO1xuICB9XG4gIHJldHVybjtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRSZXNldE1vZGUobW9kZSkge1xuICByZXR1cm4gUmVzZXRNb2Rlcy5pbmNsdWRlcyhtb2RlKTtcbn1cbnZhciBSZXNldE1vZGUsIFJlc2V0TW9kZXM7XG52YXIgaW5pdF9yZXNldCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL3Jlc2V0LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF90YXNrKCk7XG4gICAgUmVzZXRNb2RlID0gLyogQF9fUFVSRV9fICovICgoUmVzZXRNb2RlMikgPT4ge1xuICAgICAgUmVzZXRNb2RlMltcIk1JWEVEXCJdID0gXCJtaXhlZFwiO1xuICAgICAgUmVzZXRNb2RlMltcIlNPRlRcIl0gPSBcInNvZnRcIjtcbiAgICAgIFJlc2V0TW9kZTJbXCJIQVJEXCJdID0gXCJoYXJkXCI7XG4gICAgICBSZXNldE1vZGUyW1wiTUVSR0VcIl0gPSBcIm1lcmdlXCI7XG4gICAgICBSZXNldE1vZGUyW1wiS0VFUFwiXSA9IFwia2VlcFwiO1xuICAgICAgcmV0dXJuIFJlc2V0TW9kZTI7XG4gICAgfSkoUmVzZXRNb2RlIHx8IHt9KTtcbiAgICBSZXNldE1vZGVzID0gQXJyYXkuZnJvbShPYmplY3QudmFsdWVzKFJlc2V0TW9kZSkpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9naXQtbG9nZ2VyLnRzXG5pbXBvcnQgZGVidWcgZnJvbSBcImRlYnVnXCI7XG5mdW5jdGlvbiBjcmVhdGVMb2coKSB7XG4gIHJldHVybiBkZWJ1ZyhcInNpbXBsZS1naXRcIik7XG59XG5mdW5jdGlvbiBwcmVmaXhlZExvZ2dlcih0bywgcHJlZml4LCBmb3J3YXJkKSB7XG4gIGlmICghcHJlZml4IHx8ICFTdHJpbmcocHJlZml4KS5yZXBsYWNlKC9cXHMqLywgXCJcIikpIHtcbiAgICByZXR1cm4gIWZvcndhcmQgPyB0byA6IChtZXNzYWdlLCAuLi5hcmdzKSA9PiB7XG4gICAgICB0byhtZXNzYWdlLCAuLi5hcmdzKTtcbiAgICAgIGZvcndhcmQobWVzc2FnZSwgLi4uYXJncyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gKG1lc3NhZ2UsIC4uLmFyZ3MpID0+IHtcbiAgICB0byhgJXMgJHttZXNzYWdlfWAsIHByZWZpeCwgLi4uYXJncyk7XG4gICAgaWYgKGZvcndhcmQpIHtcbiAgICAgIGZvcndhcmQobWVzc2FnZSwgLi4uYXJncyk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY2hpbGRMb2dnZXJOYW1lKG5hbWUsIGNoaWxkRGVidWdnZXIsIHsgbmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UgfSkge1xuICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuICBjb25zdCBjaGlsZE5hbWVzcGFjZSA9IGNoaWxkRGVidWdnZXIgJiYgY2hpbGREZWJ1Z2dlci5uYW1lc3BhY2UgfHwgXCJcIjtcbiAgaWYgKGNoaWxkTmFtZXNwYWNlLnN0YXJ0c1dpdGgocGFyZW50TmFtZXNwYWNlKSkge1xuICAgIHJldHVybiBjaGlsZE5hbWVzcGFjZS5zdWJzdHIocGFyZW50TmFtZXNwYWNlLmxlbmd0aCArIDEpO1xuICB9XG4gIHJldHVybiBjaGlsZE5hbWVzcGFjZSB8fCBwYXJlbnROYW1lc3BhY2U7XG59XG5mdW5jdGlvbiBjcmVhdGVMb2dnZXIobGFiZWwsIHZlcmJvc2UsIGluaXRpYWxTdGVwLCBpbmZvRGVidWdnZXIgPSBjcmVhdGVMb2coKSkge1xuICBjb25zdCBsYWJlbFByZWZpeCA9IGxhYmVsICYmIGBbJHtsYWJlbH1dYCB8fCBcIlwiO1xuICBjb25zdCBzcGF3bmVkID0gW107XG4gIGNvbnN0IGRlYnVnRGVidWdnZXIgPSB0eXBlb2YgdmVyYm9zZSA9PT0gXCJzdHJpbmdcIiA/IGluZm9EZWJ1Z2dlci5leHRlbmQodmVyYm9zZSkgOiB2ZXJib3NlO1xuICBjb25zdCBrZXkgPSBjaGlsZExvZ2dlck5hbWUoZmlsdGVyVHlwZSh2ZXJib3NlLCBmaWx0ZXJTdHJpbmcpLCBkZWJ1Z0RlYnVnZ2VyLCBpbmZvRGVidWdnZXIpO1xuICByZXR1cm4gc3RlcChpbml0aWFsU3RlcCk7XG4gIGZ1bmN0aW9uIHNpYmxpbmcobmFtZSwgaW5pdGlhbCkge1xuICAgIHJldHVybiBhcHBlbmQoXG4gICAgICBzcGF3bmVkLFxuICAgICAgY3JlYXRlTG9nZ2VyKGxhYmVsLCBrZXkucmVwbGFjZSgvXlteOl0rLywgbmFtZSksIGluaXRpYWwsIGluZm9EZWJ1Z2dlcilcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHN0ZXAocGhhc2UpIHtcbiAgICBjb25zdCBzdGVwUHJlZml4ID0gcGhhc2UgJiYgYFske3BoYXNlfV1gIHx8IFwiXCI7XG4gICAgY29uc3QgZGVidWcyID0gZGVidWdEZWJ1Z2dlciAmJiBwcmVmaXhlZExvZ2dlcihkZWJ1Z0RlYnVnZ2VyLCBzdGVwUHJlZml4KSB8fCBOT09QO1xuICAgIGNvbnN0IGluZm8gPSBwcmVmaXhlZExvZ2dlcihpbmZvRGVidWdnZXIsIGAke2xhYmVsUHJlZml4fSAke3N0ZXBQcmVmaXh9YCwgZGVidWcyKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZWJ1Z0RlYnVnZ2VyID8gZGVidWcyIDogaW5mbywge1xuICAgICAgbGFiZWwsXG4gICAgICBzaWJsaW5nLFxuICAgICAgaW5mbyxcbiAgICAgIHN0ZXBcbiAgICB9KTtcbiAgfVxufVxudmFyIGluaXRfZ2l0X2xvZ2dlciA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL2dpdC1sb2dnZXIudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgZGVidWcuZm9ybWF0dGVycy5MID0gKHZhbHVlKSA9PiBTdHJpbmcoZmlsdGVySGFzTGVuZ3RoKHZhbHVlKSA/IHZhbHVlLmxlbmd0aCA6IFwiLVwiKTtcbiAgICBkZWJ1Zy5mb3JtYXR0ZXJzLkIgPSAodmFsdWUpID0+IHtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZyhcInV0ZjhcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3J1bm5lcnMvdGFza3MtcGVuZGluZy1xdWV1ZS50c1xudmFyIF9UYXNrc1BlbmRpbmdRdWV1ZSwgVGFza3NQZW5kaW5nUXVldWU7XG52YXIgaW5pdF90YXNrc19wZW5kaW5nX3F1ZXVlID0gX19lc20oe1xuICBcInNyYy9saWIvcnVubmVycy90YXNrcy1wZW5kaW5nLXF1ZXVlLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9naXRfZXJyb3IoKTtcbiAgICBpbml0X2dpdF9sb2dnZXIoKTtcbiAgICBfVGFza3NQZW5kaW5nUXVldWUgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3Rvcihsb2dMYWJlbCA9IFwiR2l0RXhlY3V0b3JcIikge1xuICAgICAgICB0aGlzLmxvZ0xhYmVsID0gbG9nTGFiZWw7XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIH1cbiAgICAgIHdpdGhQcm9ncmVzcyh0YXNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9xdWV1ZS5nZXQodGFzayk7XG4gICAgICB9XG4gICAgICBjcmVhdGVQcm9ncmVzcyh0YXNrKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBfVGFza3NQZW5kaW5nUXVldWUuZ2V0TmFtZSh0YXNrLmNvbW1hbmRzWzBdKTtcbiAgICAgICAgY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKHRoaXMubG9nTGFiZWwsIG5hbWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgbG9nZ2VyLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHB1c2godGFzaykge1xuICAgICAgICBjb25zdCBwcm9ncmVzcyA9IHRoaXMuY3JlYXRlUHJvZ3Jlc3ModGFzayk7XG4gICAgICAgIHByb2dyZXNzLmxvZ2dlcihcIkFkZGluZyB0YXNrIHRvIHRoZSBxdWV1ZSwgY29tbWFuZHMgPSAlb1wiLCB0YXNrLmNvbW1hbmRzKTtcbiAgICAgICAgdGhpcy5fcXVldWUuc2V0KHRhc2ssIHByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIHByb2dyZXNzO1xuICAgICAgfVxuICAgICAgZmF0YWwoZXJyKSB7XG4gICAgICAgIGZvciAoY29uc3QgW3Rhc2ssIHsgbG9nZ2VyIH1dIG9mIEFycmF5LmZyb20odGhpcy5fcXVldWUuZW50cmllcygpKSkge1xuICAgICAgICAgIGlmICh0YXNrID09PSBlcnIudGFzaykge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYEZhaWxlZCAlb2AsIGVycik7XG4gICAgICAgICAgICBsb2dnZXIoXG4gICAgICAgICAgICAgIGBGYXRhbCBleGNlcHRpb24sIGFueSBhcy15ZXQgdW4tc3RhcnRlZCB0YXNrcyBydW4gdGhyb3VnaCB0aGlzIGV4ZWN1dG9yIHdpbGwgbm90IGJlIGF0dGVtcHRlZGBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICBgQSBmYXRhbCBleGNlcHRpb24gb2NjdXJyZWQgaW4gYSBwcmV2aW91cyB0YXNrLCB0aGUgcXVldWUgaGFzIGJlZW4gcHVyZ2VkOiAlb2AsXG4gICAgICAgICAgICAgIGVyci5tZXNzYWdlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKHRhc2spO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9xdWV1ZS5zaXplICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBRdWV1ZSBzaXplIHNob3VsZCBiZSB6ZXJvIGFmdGVyIGZhdGFsOiAke3RoaXMuX3F1ZXVlLnNpemV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbXBsZXRlKHRhc2spIHtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSB0aGlzLndpdGhQcm9ncmVzcyh0YXNrKTtcbiAgICAgICAgaWYgKHByb2dyZXNzKSB7XG4gICAgICAgICAgdGhpcy5fcXVldWUuZGVsZXRlKHRhc2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhdHRlbXB0KHRhc2spIHtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSB0aGlzLndpdGhQcm9ncmVzcyh0YXNrKTtcbiAgICAgICAgaWYgKCFwcm9ncmVzcykge1xuICAgICAgICAgIHRocm93IG5ldyBHaXRFcnJvcih2b2lkIDAsIFwiVGFza3NQZW5kaW5nUXVldWU6IGF0dGVtcHQgY2FsbGVkIGZvciBhbiB1bmtub3duIHRhc2tcIik7XG4gICAgICAgIH1cbiAgICAgICAgcHJvZ3Jlc3MubG9nZ2VyKFwiU3RhcnRpbmcgdGFza1wiKTtcbiAgICAgICAgcmV0dXJuIHByb2dyZXNzO1xuICAgICAgfVxuICAgICAgc3RhdGljIGdldE5hbWUobmFtZSA9IFwiZW1wdHlcIikge1xuICAgICAgICByZXR1cm4gYHRhc2s6JHtuYW1lfTokeysrX1Rhc2tzUGVuZGluZ1F1ZXVlLmNvdW50ZXJ9YDtcbiAgICAgIH1cbiAgICB9O1xuICAgIFRhc2tzUGVuZGluZ1F1ZXVlID0gX1Rhc2tzUGVuZGluZ1F1ZXVlO1xuICAgIFRhc2tzUGVuZGluZ1F1ZXVlLmNvdW50ZXIgPSAwO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9ydW5uZXJzL2dpdC1leGVjdXRvci1jaGFpbi50c1xuaW1wb3J0IHsgc3Bhd24gfSBmcm9tIFwiY2hpbGRfcHJvY2Vzc1wiO1xuZnVuY3Rpb24gcGx1Z2luQ29udGV4dCh0YXNrLCBjb21tYW5kcykge1xuICByZXR1cm4ge1xuICAgIG1ldGhvZDogZmlyc3QodGFzay5jb21tYW5kcykgfHwgXCJcIixcbiAgICBjb21tYW5kc1xuICB9O1xufVxuZnVuY3Rpb24gb25FcnJvclJlY2VpdmVkKHRhcmdldCwgbG9nZ2VyKSB7XG4gIHJldHVybiAoZXJyKSA9PiB7XG4gICAgbG9nZ2VyKGBbRVJST1JdIGNoaWxkIHByb2Nlc3MgZXhjZXB0aW9uICVvYCwgZXJyKTtcbiAgICB0YXJnZXQucHVzaChCdWZmZXIuZnJvbShTdHJpbmcoZXJyLnN0YWNrKSwgXCJhc2NpaVwiKSk7XG4gIH07XG59XG5mdW5jdGlvbiBvbkRhdGFSZWNlaXZlZCh0YXJnZXQsIG5hbWUsIGxvZ2dlciwgb3V0cHV0KSB7XG4gIHJldHVybiAoYnVmZmVyKSA9PiB7XG4gICAgbG9nZ2VyKGAlcyByZWNlaXZlZCAlTCBieXRlc2AsIG5hbWUsIGJ1ZmZlcik7XG4gICAgb3V0cHV0KGAlQmAsIGJ1ZmZlcik7XG4gICAgdGFyZ2V0LnB1c2goYnVmZmVyKTtcbiAgfTtcbn1cbnZhciBHaXRFeGVjdXRvckNoYWluO1xudmFyIGluaXRfZ2l0X2V4ZWN1dG9yX2NoYWluID0gX19lc20oe1xuICBcInNyYy9saWIvcnVubmVycy9naXQtZXhlY3V0b3ItY2hhaW4udHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X2dpdF9lcnJvcigpO1xuICAgIGluaXRfdGFzaygpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBpbml0X3Rhc2tzX3BlbmRpbmdfcXVldWUoKTtcbiAgICBHaXRFeGVjdXRvckNoYWluID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoX2V4ZWN1dG9yLCBfc2NoZWR1bGVyLCBfcGx1Z2lucykge1xuICAgICAgICB0aGlzLl9leGVjdXRvciA9IF9leGVjdXRvcjtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVyID0gX3NjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5fcGx1Z2lucyA9IF9wbHVnaW5zO1xuICAgICAgICB0aGlzLl9jaGFpbiA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IG5ldyBUYXNrc1BlbmRpbmdRdWV1ZSgpO1xuICAgICAgfVxuICAgICAgZ2V0IGN3ZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N3ZCB8fCB0aGlzLl9leGVjdXRvci5jd2Q7XG4gICAgICB9XG4gICAgICBzZXQgY3dkKGN3ZCkge1xuICAgICAgICB0aGlzLl9jd2QgPSBjd2Q7XG4gICAgICB9XG4gICAgICBnZXQgZW52KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhlY3V0b3IuZW52O1xuICAgICAgfVxuICAgICAgZ2V0IG91dHB1dEhhbmRsZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leGVjdXRvci5vdXRwdXRIYW5kbGVyO1xuICAgICAgfVxuICAgICAgY2hhaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcHVzaCh0YXNrKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnB1c2godGFzayk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFpbiA9IHRoaXMuX2NoYWluLnRoZW4oKCkgPT4gdGhpcy5hdHRlbXB0VGFzayh0YXNrKSk7XG4gICAgICB9XG4gICAgICBhdHRlbXB0VGFzayh0YXNrKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgY29uc3Qgb25TY2hlZHVsZUNvbXBsZXRlID0geWllbGQgdGhpcy5fc2NoZWR1bGVyLm5leHQoKTtcbiAgICAgICAgICBjb25zdCBvblF1ZXVlQ29tcGxldGUgPSAoKSA9PiB0aGlzLl9xdWV1ZS5jb21wbGV0ZSh0YXNrKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBsb2dnZXIgfSA9IHRoaXMuX3F1ZXVlLmF0dGVtcHQodGFzayk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgaXNFbXB0eVRhc2sodGFzaykgPyB0aGlzLmF0dGVtcHRFbXB0eVRhc2sodGFzaywgbG9nZ2VyKSA6IHRoaXMuYXR0ZW1wdFJlbW90ZVRhc2sodGFzaywgbG9nZ2VyKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLm9uRmF0YWxFeGNlcHRpb24odGFzaywgZSk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIG9uUXVldWVDb21wbGV0ZSgpO1xuICAgICAgICAgICAgb25TY2hlZHVsZUNvbXBsZXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIG9uRmF0YWxFeGNlcHRpb24odGFzaywgZSkge1xuICAgICAgICBjb25zdCBnaXRFcnJvciA9IGUgaW5zdGFuY2VvZiBHaXRFcnJvciA/IE9iamVjdC5hc3NpZ24oZSwgeyB0YXNrIH0pIDogbmV3IEdpdEVycm9yKHRhc2ssIGUgJiYgU3RyaW5nKGUpKTtcbiAgICAgICAgdGhpcy5fY2hhaW4gPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgdGhpcy5fcXVldWUuZmF0YWwoZ2l0RXJyb3IpO1xuICAgICAgICByZXR1cm4gZ2l0RXJyb3I7XG4gICAgICB9XG4gICAgICBhdHRlbXB0UmVtb3RlVGFzayh0YXNrLCBsb2dnZXIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICBjb25zdCBiaW5hcnkgPSB0aGlzLl9wbHVnaW5zLmV4ZWMoXCJzcGF3bi5iaW5hcnlcIiwgXCJcIiwgcGx1Z2luQ29udGV4dCh0YXNrLCB0YXNrLmNvbW1hbmRzKSk7XG4gICAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuX3BsdWdpbnMuZXhlYyhcbiAgICAgICAgICAgIFwic3Bhd24uYXJnc1wiLFxuICAgICAgICAgICAgWy4uLnRhc2suY29tbWFuZHNdLFxuICAgICAgICAgICAgcGx1Z2luQ29udGV4dCh0YXNrLCB0YXNrLmNvbW1hbmRzKVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgcmF3ID0geWllbGQgdGhpcy5naXRSZXNwb25zZShcbiAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICBiaW5hcnksXG4gICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgdGhpcy5vdXRwdXRIYW5kbGVyLFxuICAgICAgICAgICAgbG9nZ2VyLnN0ZXAoXCJTUEFXTlwiKVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3Qgb3V0cHV0U3RyZWFtcyA9IHlpZWxkIHRoaXMuaGFuZGxlVGFza0RhdGEodGFzaywgYXJncywgcmF3LCBsb2dnZXIuc3RlcChcIkhBTkRMRVwiKSk7XG4gICAgICAgICAgbG9nZ2VyKGBwYXNzaW5nIHJlc3BvbnNlIHRvIHRhc2sncyBwYXJzZXIgYXMgYSAlc2AsIHRhc2suZm9ybWF0KTtcbiAgICAgICAgICBpZiAoaXNCdWZmZXJUYXNrKHRhc2spKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbFRhc2tQYXJzZXIodGFzay5wYXJzZXIsIG91dHB1dFN0cmVhbXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FsbFRhc2tQYXJzZXIodGFzay5wYXJzZXIsIG91dHB1dFN0cmVhbXMuYXNTdHJpbmdzKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGF0dGVtcHRFbXB0eVRhc2sodGFzaywgbG9nZ2VyKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgbG9nZ2VyKGBlbXB0eSB0YXNrIGJ5cGFzc2luZyBjaGlsZCBwcm9jZXNzIHRvIGNhbGwgdG8gdGFzaydzIHBhcnNlcmApO1xuICAgICAgICAgIHJldHVybiB0YXNrLnBhcnNlcih0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBoYW5kbGVUYXNrRGF0YSh0YXNrLCBhcmdzLCByZXN1bHQsIGxvZ2dlcikge1xuICAgICAgICBjb25zdCB7IGV4aXRDb2RlLCByZWplY3Rpb24sIHN0ZE91dCwgc3RkRXJyIH0gPSByZXN1bHQ7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoZG9uZSwgZmFpbCkgPT4ge1xuICAgICAgICAgIGxvZ2dlcihgUHJlcGFyaW5nIHRvIGhhbmRsZSBwcm9jZXNzIHJlc3BvbnNlIGV4aXRDb2RlPSVkIHN0ZE91dD1gLCBleGl0Q29kZSk7XG4gICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gdGhpcy5fcGx1Z2lucy5leGVjKFxuICAgICAgICAgICAgXCJ0YXNrLmVycm9yXCIsXG4gICAgICAgICAgICB7IGVycm9yOiByZWplY3Rpb24gfSxcbiAgICAgICAgICAgIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBwbHVnaW5Db250ZXh0KHRhc2ssIGFyZ3MpKSwgcmVzdWx0KVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGVycm9yICYmIHRhc2sub25FcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYGV4aXRDb2RlPSVzIGhhbmRsaW5nIHdpdGggY3VzdG9tIGVycm9yIGhhbmRsZXJgKTtcbiAgICAgICAgICAgIHJldHVybiB0YXNrLm9uRXJyb3IoXG4gICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgIChuZXdTdGRPdXQpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuaW5mbyhgY3VzdG9tIGVycm9yIGhhbmRsZXIgdHJlYXRlZCBhcyBzdWNjZXNzYCk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyKGBjdXN0b20gZXJyb3IgcmV0dXJuZWQgYSAlc2AsIG9iamVjdFRvU3RyaW5nKG5ld1N0ZE91dCkpO1xuICAgICAgICAgICAgICAgIGRvbmUoXG4gICAgICAgICAgICAgICAgICBuZXcgR2l0T3V0cHV0U3RyZWFtcyhcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShuZXdTdGRPdXQpID8gQnVmZmVyLmNvbmNhdChuZXdTdGRPdXQpIDogbmV3U3RkT3V0LFxuICAgICAgICAgICAgICAgICAgICBCdWZmZXIuY29uY2F0KHN0ZEVycilcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBmYWlsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICAgICAgICBgaGFuZGxpbmcgYXMgZXJyb3I6IGV4aXRDb2RlPSVzIHN0ZEVycj0lcyByZWplY3Rpb249JW9gLFxuICAgICAgICAgICAgICBleGl0Q29kZSxcbiAgICAgICAgICAgICAgc3RkRXJyLmxlbmd0aCxcbiAgICAgICAgICAgICAgcmVqZWN0aW9uXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2dnZXIuaW5mbyhgcmV0cmlldmluZyB0YXNrIG91dHB1dCBjb21wbGV0ZWApO1xuICAgICAgICAgIGRvbmUobmV3IEdpdE91dHB1dFN0cmVhbXMoQnVmZmVyLmNvbmNhdChzdGRPdXQpLCBCdWZmZXIuY29uY2F0KHN0ZEVycikpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBnaXRSZXNwb25zZSh0YXNrLCBjb21tYW5kLCBhcmdzLCBvdXRwdXRIYW5kbGVyLCBsb2dnZXIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICBjb25zdCBvdXRwdXRMb2dnZXIgPSBsb2dnZXIuc2libGluZyhcIm91dHB1dFwiKTtcbiAgICAgICAgICBjb25zdCBzcGF3bk9wdGlvbnMgPSB0aGlzLl9wbHVnaW5zLmV4ZWMoXG4gICAgICAgICAgICBcInNwYXduLm9wdGlvbnNcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgICAgICAgICAgZW52OiB0aGlzLmVudixcbiAgICAgICAgICAgICAgd2luZG93c0hpZGU6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwbHVnaW5Db250ZXh0KHRhc2ssIHRhc2suY29tbWFuZHMpXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKGRvbmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0ZE91dCA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgc3RkRXJyID0gW107XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgJXMgJW9gLCBjb21tYW5kLCBhcmdzKTtcbiAgICAgICAgICAgIGxvZ2dlcihcIiVPXCIsIHNwYXduT3B0aW9ucyk7XG4gICAgICAgICAgICBsZXQgcmVqZWN0aW9uID0gdGhpcy5fYmVmb3JlU3Bhd24odGFzaywgYXJncyk7XG4gICAgICAgICAgICBpZiAocmVqZWN0aW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkb25lKHtcbiAgICAgICAgICAgICAgICBzdGRPdXQsXG4gICAgICAgICAgICAgICAgc3RkRXJyLFxuICAgICAgICAgICAgICAgIGV4aXRDb2RlOiA5OTAxLFxuICAgICAgICAgICAgICAgIHJlamVjdGlvblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3BsdWdpbnMuZXhlYyhcInNwYXduLmJlZm9yZVwiLCB2b2lkIDAsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHBsdWdpbkNvbnRleHQodGFzaywgYXJncykpLCB7XG4gICAgICAgICAgICAgIGtpbGwocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0aW9uID0gcmVhc29uIHx8IHJlamVjdGlvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgY29uc3Qgc3Bhd25lZCA9IHNwYXduKGNvbW1hbmQsIGFyZ3MsIHNwYXduT3B0aW9ucyk7XG4gICAgICAgICAgICBzcGF3bmVkLnN0ZG91dC5vbihcbiAgICAgICAgICAgICAgXCJkYXRhXCIsXG4gICAgICAgICAgICAgIG9uRGF0YVJlY2VpdmVkKHN0ZE91dCwgXCJzdGRPdXRcIiwgbG9nZ2VyLCBvdXRwdXRMb2dnZXIuc3RlcChcInN0ZE91dFwiKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzcGF3bmVkLnN0ZGVyci5vbihcbiAgICAgICAgICAgICAgXCJkYXRhXCIsXG4gICAgICAgICAgICAgIG9uRGF0YVJlY2VpdmVkKHN0ZEVyciwgXCJzdGRFcnJcIiwgbG9nZ2VyLCBvdXRwdXRMb2dnZXIuc3RlcChcInN0ZEVyclwiKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzcGF3bmVkLm9uKFwiZXJyb3JcIiwgb25FcnJvclJlY2VpdmVkKHN0ZEVyciwgbG9nZ2VyKSk7XG4gICAgICAgICAgICBpZiAob3V0cHV0SGFuZGxlcikge1xuICAgICAgICAgICAgICBsb2dnZXIoYFBhc3NpbmcgY2hpbGQgcHJvY2VzcyBzdGRPdXQvc3RkRXJyIHRvIGN1c3RvbSBvdXRwdXRIYW5kbGVyYCk7XG4gICAgICAgICAgICAgIG91dHB1dEhhbmRsZXIoY29tbWFuZCwgc3Bhd25lZC5zdGRvdXQsIHNwYXduZWQuc3RkZXJyLCBbLi4uYXJnc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGx1Z2lucy5leGVjKFwic3Bhd24uYWZ0ZXJcIiwgdm9pZCAwLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwbHVnaW5Db250ZXh0KHRhc2ssIGFyZ3MpKSwge1xuICAgICAgICAgICAgICBzcGF3bmVkLFxuICAgICAgICAgICAgICBjbG9zZShleGl0Q29kZSwgcmVhc29uKSB7XG4gICAgICAgICAgICAgICAgZG9uZSh7XG4gICAgICAgICAgICAgICAgICBzdGRPdXQsXG4gICAgICAgICAgICAgICAgICBzdGRFcnIsXG4gICAgICAgICAgICAgICAgICBleGl0Q29kZSxcbiAgICAgICAgICAgICAgICAgIHJlamVjdGlvbjogcmVqZWN0aW9uIHx8IHJlYXNvblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBraWxsKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGlmIChzcGF3bmVkLmtpbGxlZCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWplY3Rpb24gPSByZWFzb247XG4gICAgICAgICAgICAgICAgc3Bhd25lZC5raWxsKFwiU0lHSU5UXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgX2JlZm9yZVNwYXduKHRhc2ssIGFyZ3MpIHtcbiAgICAgICAgbGV0IHJlamVjdGlvbjtcbiAgICAgICAgdGhpcy5fcGx1Z2lucy5leGVjKFwic3Bhd24uYmVmb3JlXCIsIHZvaWQgMCwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcGx1Z2luQ29udGV4dCh0YXNrLCBhcmdzKSksIHtcbiAgICAgICAgICBraWxsKHJlYXNvbikge1xuICAgICAgICAgICAgcmVqZWN0aW9uID0gcmVhc29uIHx8IHJlamVjdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHJlamVjdGlvbjtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9ydW5uZXJzL2dpdC1leGVjdXRvci50c1xudmFyIGdpdF9leGVjdXRvcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChnaXRfZXhlY3V0b3JfZXhwb3J0cywge1xuICBHaXRFeGVjdXRvcjogKCkgPT4gR2l0RXhlY3V0b3Jcbn0pO1xudmFyIEdpdEV4ZWN1dG9yO1xudmFyIGluaXRfZ2l0X2V4ZWN1dG9yID0gX19lc20oe1xuICBcInNyYy9saWIvcnVubmVycy9naXQtZXhlY3V0b3IudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X2dpdF9leGVjdXRvcl9jaGFpbigpO1xuICAgIEdpdEV4ZWN1dG9yID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoY3dkLCBfc2NoZWR1bGVyLCBfcGx1Z2lucykge1xuICAgICAgICB0aGlzLmN3ZCA9IGN3ZDtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVyID0gX3NjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5fcGx1Z2lucyA9IF9wbHVnaW5zO1xuICAgICAgICB0aGlzLl9jaGFpbiA9IG5ldyBHaXRFeGVjdXRvckNoYWluKHRoaXMsIHRoaXMuX3NjaGVkdWxlciwgdGhpcy5fcGx1Z2lucyk7XG4gICAgICB9XG4gICAgICBjaGFpbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHaXRFeGVjdXRvckNoYWluKHRoaXMsIHRoaXMuX3NjaGVkdWxlciwgdGhpcy5fcGx1Z2lucyk7XG4gICAgICB9XG4gICAgICBwdXNoKHRhc2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYWluLnB1c2godGFzayk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFzay1jYWxsYmFjay50c1xuZnVuY3Rpb24gdGFza0NhbGxiYWNrKHRhc2ssIHJlc3BvbnNlLCBjYWxsYmFjayA9IE5PT1ApIHtcbiAgY29uc3Qgb25TdWNjZXNzID0gKGRhdGEpID0+IHtcbiAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgfTtcbiAgY29uc3Qgb25FcnJvcjIgPSAoZXJyKSA9PiB7XG4gICAgaWYgKChlcnIgPT0gbnVsbCA/IHZvaWQgMCA6IGVyci50YXNrKSA9PT0gdGFzaykge1xuICAgICAgY2FsbGJhY2soXG4gICAgICAgIGVyciBpbnN0YW5jZW9mIEdpdFJlc3BvbnNlRXJyb3IgPyBhZGREZXByZWNhdGlvbk5vdGljZVRvRXJyb3IoZXJyKSA6IGVycixcbiAgICAgICAgdm9pZCAwXG4gICAgICApO1xuICAgIH1cbiAgfTtcbiAgcmVzcG9uc2UudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IyKTtcbn1cbmZ1bmN0aW9uIGFkZERlcHJlY2F0aW9uTm90aWNlVG9FcnJvcihlcnIpIHtcbiAgbGV0IGxvZyA9IChuYW1lKSA9PiB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYHNpbXBsZS1naXQgZGVwcmVjYXRpb24gbm90aWNlOiBhY2Nlc3NpbmcgR2l0UmVzcG9uc2VFcnJvci4ke25hbWV9IHNob3VsZCBiZSBHaXRSZXNwb25zZUVycm9yLmdpdC4ke25hbWV9LCB0aGlzIHdpbGwgbm8gbG9uZ2VyIGJlIGF2YWlsYWJsZSBpbiB2ZXJzaW9uIDNgXG4gICAgKTtcbiAgICBsb2cgPSBOT09QO1xuICB9O1xuICByZXR1cm4gT2JqZWN0LmNyZWF0ZShlcnIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVyci5naXQpLnJlZHVjZShkZXNjcmlwdG9yUmVkdWNlciwge30pKTtcbiAgZnVuY3Rpb24gZGVzY3JpcHRvclJlZHVjZXIoYWxsLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgaW4gZXJyKSB7XG4gICAgICByZXR1cm4gYWxsO1xuICAgIH1cbiAgICBhbGxbbmFtZV0gPSB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBnZXQoKSB7XG4gICAgICAgIGxvZyhuYW1lKTtcbiAgICAgICAgcmV0dXJuIGVyci5naXRbbmFtZV07XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYWxsO1xuICB9XG59XG52YXIgaW5pdF90YXNrX2NhbGxiYWNrID0gX19lc20oe1xuICBcInNyYy9saWIvdGFzay1jYWxsYmFjay50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfZ2l0X3Jlc3BvbnNlX2Vycm9yKCk7XG4gICAgaW5pdF91dGlscygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9jaGFuZ2Utd29ya2luZy1kaXJlY3RvcnkudHNcbmZ1bmN0aW9uIGNoYW5nZVdvcmtpbmdEaXJlY3RvcnlUYXNrKGRpcmVjdG9yeSwgcm9vdCkge1xuICByZXR1cm4gYWRob2NFeGVjVGFzaygoaW5zdGFuY2UpID0+IHtcbiAgICBpZiAoIWZvbGRlckV4aXN0cyhkaXJlY3RvcnkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEdpdC5jd2Q6IGNhbm5vdCBjaGFuZ2UgdG8gbm9uLWRpcmVjdG9yeSBcIiR7ZGlyZWN0b3J5fVwiYCk7XG4gICAgfVxuICAgIHJldHVybiAocm9vdCB8fCBpbnN0YW5jZSkuY3dkID0gZGlyZWN0b3J5O1xuICB9KTtcbn1cbnZhciBpbml0X2NoYW5nZV93b3JraW5nX2RpcmVjdG9yeSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2NoYW5nZS13b3JraW5nLWRpcmVjdG9yeS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBpbml0X3Rhc2soKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvY2hlY2tvdXQudHNcbmZ1bmN0aW9uIGNoZWNrb3V0VGFzayhhcmdzKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wiY2hlY2tvdXRcIiwgLi4uYXJnc107XG4gIGlmIChjb21tYW5kc1sxXSA9PT0gXCItYlwiICYmIGNvbW1hbmRzLmluY2x1ZGVzKFwiLUJcIikpIHtcbiAgICBjb21tYW5kc1sxXSA9IHJlbW92ZShjb21tYW5kcywgXCItQlwiKTtcbiAgfVxuICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcyk7XG59XG5mdW5jdGlvbiBjaGVja291dF9kZWZhdWx0KCkge1xuICByZXR1cm4ge1xuICAgIGNoZWNrb3V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGNoZWNrb3V0VGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzLCAxKSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH0sXG4gICAgY2hlY2tvdXRCcmFuY2goYnJhbmNoTmFtZSwgc3RhcnRQb2ludCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGNoZWNrb3V0VGFzayhbXCItYlwiLCBicmFuY2hOYW1lLCBzdGFydFBvaW50LCAuLi5nZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKV0pLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9LFxuICAgIGNoZWNrb3V0TG9jYWxCcmFuY2goYnJhbmNoTmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGNoZWNrb3V0VGFzayhbXCItYlwiLCBicmFuY2hOYW1lLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKV0pLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG52YXIgaW5pdF9jaGVja291dCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2NoZWNrb3V0LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlscygpO1xuICAgIGluaXRfdGFzaygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9jb3VudC1vYmplY3RzLnRzXG5mdW5jdGlvbiBjb3VudE9iamVjdHNSZXNwb25zZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBjb3VudDogMCxcbiAgICBnYXJiYWdlOiAwLFxuICAgIGluUGFjazogMCxcbiAgICBwYWNrczogMCxcbiAgICBwcnVuZVBhY2thYmxlOiAwLFxuICAgIHNpemU6IDAsXG4gICAgc2l6ZUdhcmJhZ2U6IDAsXG4gICAgc2l6ZVBhY2s6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvdW50X29iamVjdHNfZGVmYXVsdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBjb3VudE9iamVjdHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh7XG4gICAgICAgIGNvbW1hbmRzOiBbXCJjb3VudC1vYmplY3RzXCIsIFwiLS12ZXJib3NlXCJdLFxuICAgICAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICAgICAgcGFyc2VyKHN0ZE91dCkge1xuICAgICAgICAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKGNvdW50T2JqZWN0c1Jlc3BvbnNlKCksIFtwYXJzZXIyXSwgc3RkT3V0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxudmFyIHBhcnNlcjI7XG52YXIgaW5pdF9jb3VudF9vYmplY3RzID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvY291bnQtb2JqZWN0cy50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBwYXJzZXIyID0gbmV3IExpbmVQYXJzZXIoXG4gICAgICAvKFthLXotXSspOiAoXFxkKykkLyxcbiAgICAgIChyZXN1bHQsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IGFzQ2FtZWxDYXNlKGtleSk7XG4gICAgICAgIGlmIChyZXN1bHQuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgICAgcmVzdWx0W3Byb3BlcnR5XSA9IGFzTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3BhcnNlcnMvcGFyc2UtY29tbWl0LnRzXG5mdW5jdGlvbiBwYXJzZUNvbW1pdFJlc3VsdChzdGRPdXQpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGF1dGhvcjogbnVsbCxcbiAgICBicmFuY2g6IFwiXCIsXG4gICAgY29tbWl0OiBcIlwiLFxuICAgIHJvb3Q6IGZhbHNlLFxuICAgIHN1bW1hcnk6IHtcbiAgICAgIGNoYW5nZXM6IDAsXG4gICAgICBpbnNlcnRpb25zOiAwLFxuICAgICAgZGVsZXRpb25zOiAwXG4gICAgfVxuICB9O1xuICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZShyZXN1bHQsIHBhcnNlcnMsIHN0ZE91dCk7XG59XG52YXIgcGFyc2VycztcbnZhciBpbml0X3BhcnNlX2NvbW1pdCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3BhcnNlcnMvcGFyc2UtY29tbWl0LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlscygpO1xuICAgIHBhcnNlcnMgPSBbXG4gICAgICBuZXcgTGluZVBhcnNlcigvXlxcWyhbXlxcc10rKSggXFwoW14pXStcXCkpPyAoW15cXF1dKykvLCAocmVzdWx0LCBbYnJhbmNoLCByb290LCBjb21taXRdKSA9PiB7XG4gICAgICAgIHJlc3VsdC5icmFuY2ggPSBicmFuY2g7XG4gICAgICAgIHJlc3VsdC5jb21taXQgPSBjb21taXQ7XG4gICAgICAgIHJlc3VsdC5yb290ID0gISFyb290O1xuICAgICAgfSksXG4gICAgICBuZXcgTGluZVBhcnNlcigvXFxzKkF1dGhvcjpcXHMoLispL2ksIChyZXN1bHQsIFthdXRob3JdKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gYXV0aG9yLnNwbGl0KFwiPFwiKTtcbiAgICAgICAgY29uc3QgZW1haWwgPSBwYXJ0cy5wb3AoKTtcbiAgICAgICAgaWYgKCFlbWFpbCB8fCAhZW1haWwuaW5jbHVkZXMoXCJAXCIpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5hdXRob3IgPSB7XG4gICAgICAgICAgZW1haWw6IGVtYWlsLnN1YnN0cigwLCBlbWFpbC5sZW5ndGggLSAxKSxcbiAgICAgICAgICBuYW1lOiBwYXJ0cy5qb2luKFwiPFwiKS50cmltKClcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAgIC8oXFxkKylbXixdKig/OixcXHMqKFxcZCspW14sXSopKD86LFxccyooXFxkKykpL2csXG4gICAgICAgIChyZXN1bHQsIFtjaGFuZ2VzLCBpbnNlcnRpb25zLCBkZWxldGlvbnNdKSA9PiB7XG4gICAgICAgICAgcmVzdWx0LnN1bW1hcnkuY2hhbmdlcyA9IHBhcnNlSW50KGNoYW5nZXMsIDEwKSB8fCAwO1xuICAgICAgICAgIHJlc3VsdC5zdW1tYXJ5Lmluc2VydGlvbnMgPSBwYXJzZUludChpbnNlcnRpb25zLCAxMCkgfHwgMDtcbiAgICAgICAgICByZXN1bHQuc3VtbWFyeS5kZWxldGlvbnMgPSBwYXJzZUludChkZWxldGlvbnMsIDEwKSB8fCAwO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAgIC9eKFxcZCspW14sXSooPzosXFxzKihcXGQrKVteKF0rXFwoKFsrLV0pKT8vLFxuICAgICAgICAocmVzdWx0LCBbY2hhbmdlcywgbGluZXMsIGRpcmVjdGlvbl0pID0+IHtcbiAgICAgICAgICByZXN1bHQuc3VtbWFyeS5jaGFuZ2VzID0gcGFyc2VJbnQoY2hhbmdlcywgMTApIHx8IDA7XG4gICAgICAgICAgY29uc3QgY291bnQgPSBwYXJzZUludChsaW5lcywgMTApIHx8IDA7XG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdW1tYXJ5LmRlbGV0aW9ucyA9IGNvdW50O1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBcIitcIikge1xuICAgICAgICAgICAgcmVzdWx0LnN1bW1hcnkuaW5zZXJ0aW9ucyA9IGNvdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL2NvbW1pdC50c1xuZnVuY3Rpb24gY29tbWl0VGFzayhtZXNzYWdlLCBmaWxlcywgY3VzdG9tQXJncykge1xuICBjb25zdCBjb21tYW5kcyA9IFtcbiAgICBcIi1jXCIsXG4gICAgXCJjb3JlLmFiYnJldj00MFwiLFxuICAgIFwiY29tbWl0XCIsXG4gICAgLi4ucHJlZml4ZWRBcnJheShtZXNzYWdlLCBcIi1tXCIpLFxuICAgIC4uLmZpbGVzLFxuICAgIC4uLmN1c3RvbUFyZ3NcbiAgXTtcbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXI6IHBhcnNlQ29tbWl0UmVzdWx0XG4gIH07XG59XG5mdW5jdGlvbiBjb21taXRfZGVmYXVsdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBjb21taXQobWVzc2FnZSwgLi4ucmVzdCkge1xuICAgICAgY29uc3QgbmV4dCA9IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpO1xuICAgICAgY29uc3QgdGFzayA9IHJlamVjdERlcHJlY2F0ZWRTaWduYXR1cmVzKG1lc3NhZ2UpIHx8IGNvbW1pdFRhc2soXG4gICAgICAgIGFzQXJyYXkobWVzc2FnZSksXG4gICAgICAgIGFzQXJyYXkoZmlsdGVyVHlwZShyZXN0WzBdLCBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5LCBbXSkpLFxuICAgICAgICBbLi4uZmlsdGVyVHlwZShyZXN0WzFdLCBmaWx0ZXJBcnJheSwgW10pLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzLCAwLCB0cnVlKV1cbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCBuZXh0KTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIHJlamVjdERlcHJlY2F0ZWRTaWduYXR1cmVzKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gIWZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXkobWVzc2FnZSkgJiYgY29uZmlndXJhdGlvbkVycm9yVGFzayhcbiAgICAgIGBnaXQuY29tbWl0OiByZXF1aXJlcyB0aGUgY29tbWl0IG1lc3NhZ2UgdG8gYmUgc3VwcGxpZWQgYXMgYSBzdHJpbmcvc3RyaW5nW11gXG4gICAgKTtcbiAgfVxufVxudmFyIGluaXRfY29tbWl0ID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvY29tbWl0LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9wYXJzZV9jb21taXQoKTtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF90YXNrKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL2ZpcnN0LWNvbW1pdC50c1xuZnVuY3Rpb24gZmlyc3RfY29tbWl0X2RlZmF1bHQoKSB7XG4gIHJldHVybiB7XG4gICAgZmlyc3RDb21taXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbXCJyZXYtbGlzdFwiLCBcIi0tbWF4LXBhcmVudHM9MFwiLCBcIkhFQURcIl0sIHRydWUpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG52YXIgaW5pdF9maXJzdF9jb21taXQgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9maXJzdC1jb21taXQudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF90YXNrKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL2hhc2gtb2JqZWN0LnRzXG5mdW5jdGlvbiBoYXNoT2JqZWN0VGFzayhmaWxlUGF0aCwgd3JpdGUpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbXCJoYXNoLW9iamVjdFwiLCBmaWxlUGF0aF07XG4gIGlmICh3cml0ZSkge1xuICAgIGNvbW1hbmRzLnB1c2goXCItd1wiKTtcbiAgfVxuICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcywgdHJ1ZSk7XG59XG52YXIgaW5pdF9oYXNoX29iamVjdCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2hhc2gtb2JqZWN0LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF90YXNrKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Jlc3BvbnNlcy9Jbml0U3VtbWFyeS50c1xuZnVuY3Rpb24gcGFyc2VJbml0KGJhcmUsIHBhdGgsIHRleHQpIHtcbiAgY29uc3QgcmVzcG9uc2UgPSBTdHJpbmcodGV4dCkudHJpbSgpO1xuICBsZXQgcmVzdWx0O1xuICBpZiAocmVzdWx0ID0gaW5pdFJlc3BvbnNlUmVnZXguZXhlYyhyZXNwb25zZSkpIHtcbiAgICByZXR1cm4gbmV3IEluaXRTdW1tYXJ5KGJhcmUsIHBhdGgsIGZhbHNlLCByZXN1bHRbMV0pO1xuICB9XG4gIGlmIChyZXN1bHQgPSByZUluaXRSZXNwb25zZVJlZ2V4LmV4ZWMocmVzcG9uc2UpKSB7XG4gICAgcmV0dXJuIG5ldyBJbml0U3VtbWFyeShiYXJlLCBwYXRoLCB0cnVlLCByZXN1bHRbMV0pO1xuICB9XG4gIGxldCBnaXREaXIgPSBcIlwiO1xuICBjb25zdCB0b2tlbnMgPSByZXNwb25zZS5zcGxpdChcIiBcIik7XG4gIHdoaWxlICh0b2tlbnMubGVuZ3RoKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcbiAgICBpZiAodG9rZW4gPT09IFwiaW5cIikge1xuICAgICAgZ2l0RGlyID0gdG9rZW5zLmpvaW4oXCIgXCIpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgSW5pdFN1bW1hcnkoYmFyZSwgcGF0aCwgL15yZS9pLnRlc3QocmVzcG9uc2UpLCBnaXREaXIpO1xufVxudmFyIEluaXRTdW1tYXJ5LCBpbml0UmVzcG9uc2VSZWdleCwgcmVJbml0UmVzcG9uc2VSZWdleDtcbnZhciBpbml0X0luaXRTdW1tYXJ5ID0gX19lc20oe1xuICBcInNyYy9saWIvcmVzcG9uc2VzL0luaXRTdW1tYXJ5LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgSW5pdFN1bW1hcnkgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcihiYXJlLCBwYXRoLCBleGlzdGluZywgZ2l0RGlyKSB7XG4gICAgICAgIHRoaXMuYmFyZSA9IGJhcmU7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuZXhpc3RpbmcgPSBleGlzdGluZztcbiAgICAgICAgdGhpcy5naXREaXIgPSBnaXREaXI7XG4gICAgICB9XG4gICAgfTtcbiAgICBpbml0UmVzcG9uc2VSZWdleCA9IC9eSW5pdC4rIHJlcG9zaXRvcnkgaW4gKC4rKSQvO1xuICAgIHJlSW5pdFJlc3BvbnNlUmVnZXggPSAvXlJlaW4uKyBpbiAoLispJC87XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL2luaXQudHNcbmZ1bmN0aW9uIGhhc0JhcmVDb21tYW5kKGNvbW1hbmQpIHtcbiAgcmV0dXJuIGNvbW1hbmQuaW5jbHVkZXMoYmFyZUNvbW1hbmQpO1xufVxuZnVuY3Rpb24gaW5pdFRhc2soYmFyZSA9IGZhbHNlLCBwYXRoLCBjdXN0b21BcmdzKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wiaW5pdFwiLCAuLi5jdXN0b21BcmdzXTtcbiAgaWYgKGJhcmUgJiYgIWhhc0JhcmVDb21tYW5kKGNvbW1hbmRzKSkge1xuICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCBiYXJlQ29tbWFuZCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXIodGV4dCkge1xuICAgICAgcmV0dXJuIHBhcnNlSW5pdChjb21tYW5kcy5pbmNsdWRlcyhcIi0tYmFyZVwiKSwgcGF0aCwgdGV4dCk7XG4gICAgfVxuICB9O1xufVxudmFyIGJhcmVDb21tYW5kO1xudmFyIGluaXRfaW5pdCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2luaXQudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X0luaXRTdW1tYXJ5KCk7XG4gICAgYmFyZUNvbW1hbmQgPSBcIi0tYmFyZVwiO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9hcmdzL2xvZy1mb3JtYXQudHNcbmZ1bmN0aW9uIGxvZ0Zvcm1hdEZyb21Db21tYW5kKGN1c3RvbUFyZ3MpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXN0b21BcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gbG9nRm9ybWF0UmVnZXguZXhlYyhjdXN0b21BcmdzW2ldKTtcbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICByZXR1cm4gYC0tJHtmb3JtYXRbMV19YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFwiXCIgLyogTk9ORSAqLztcbn1cbmZ1bmN0aW9uIGlzTG9nRm9ybWF0KGN1c3RvbUFyZykge1xuICByZXR1cm4gbG9nRm9ybWF0UmVnZXgudGVzdChjdXN0b21BcmcpO1xufVxudmFyIGxvZ0Zvcm1hdFJlZ2V4O1xudmFyIGluaXRfbG9nX2Zvcm1hdCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL2FyZ3MvbG9nLWZvcm1hdC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGxvZ0Zvcm1hdFJlZ2V4ID0gL14tLShzdGF0fG51bXN0YXR8bmFtZS1vbmx5fG5hbWUtc3RhdHVzKSg9fCQpLztcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcmVzcG9uc2VzL0RpZmZTdW1tYXJ5LnRzXG52YXIgRGlmZlN1bW1hcnk7XG52YXIgaW5pdF9EaWZmU3VtbWFyeSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Jlc3BvbnNlcy9EaWZmU3VtbWFyeS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIERpZmZTdW1tYXJ5ID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IDA7XG4gICAgICAgIHRoaXMuZGVsZXRpb25zID0gMDtcbiAgICAgICAgdGhpcy5pbnNlcnRpb25zID0gMDtcbiAgICAgICAgdGhpcy5maWxlcyA9IFtdO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3BhcnNlcnMvcGFyc2UtZGlmZi1zdW1tYXJ5LnRzXG5mdW5jdGlvbiBnZXREaWZmUGFyc2VyKGZvcm1hdCA9IFwiXCIgLyogTk9ORSAqLykge1xuICBjb25zdCBwYXJzZXI0ID0gZGlmZlN1bW1hcnlQYXJzZXJzW2Zvcm1hdF07XG4gIHJldHVybiAoc3RkT3V0KSA9PiBwYXJzZVN0cmluZ1Jlc3BvbnNlKG5ldyBEaWZmU3VtbWFyeSgpLCBwYXJzZXI0LCBzdGRPdXQsIGZhbHNlKTtcbn1cbnZhciBzdGF0UGFyc2VyLCBudW1TdGF0UGFyc2VyLCBuYW1lT25seVBhcnNlciwgbmFtZVN0YXR1c1BhcnNlciwgZGlmZlN1bW1hcnlQYXJzZXJzO1xudmFyIGluaXRfcGFyc2VfZGlmZl9zdW1tYXJ5ID0gX19lc20oe1xuICBcInNyYy9saWIvcGFyc2Vycy9wYXJzZS1kaWZmLXN1bW1hcnkudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X2xvZ19mb3JtYXQoKTtcbiAgICBpbml0X0RpZmZTdW1tYXJ5KCk7XG4gICAgaW5pdF9kaWZmX25hbWVfc3RhdHVzKCk7XG4gICAgaW5pdF91dGlscygpO1xuICAgIHN0YXRQYXJzZXIgPSBbXG4gICAgICBuZXcgTGluZVBhcnNlcihcbiAgICAgICAgL14oLispXFxzK1xcfFxccysoXFxkKykoXFxzK1srXFwtXSspPyQvLFxuICAgICAgICAocmVzdWx0LCBbZmlsZSwgY2hhbmdlcywgYWx0ZXJhdGlvbnMgPSBcIlwiXSkgPT4ge1xuICAgICAgICAgIHJlc3VsdC5maWxlcy5wdXNoKHtcbiAgICAgICAgICAgIGZpbGU6IGZpbGUudHJpbSgpLFxuICAgICAgICAgICAgY2hhbmdlczogYXNOdW1iZXIoY2hhbmdlcyksXG4gICAgICAgICAgICBpbnNlcnRpb25zOiBhbHRlcmF0aW9ucy5yZXBsYWNlKC9bXitdL2csIFwiXCIpLmxlbmd0aCxcbiAgICAgICAgICAgIGRlbGV0aW9uczogYWx0ZXJhdGlvbnMucmVwbGFjZSgvW14tXS9nLCBcIlwiKS5sZW5ndGgsXG4gICAgICAgICAgICBiaW5hcnk6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgTGluZVBhcnNlcihcbiAgICAgICAgL14oLispIFxcfFxccytCaW4gKFswLTkuXSspIC0+IChbMC05Ll0rKSAoW2Etel0rKS8sXG4gICAgICAgIChyZXN1bHQsIFtmaWxlLCBiZWZvcmUsIGFmdGVyXSkgPT4ge1xuICAgICAgICAgIHJlc3VsdC5maWxlcy5wdXNoKHtcbiAgICAgICAgICAgIGZpbGU6IGZpbGUudHJpbSgpLFxuICAgICAgICAgICAgYmVmb3JlOiBhc051bWJlcihiZWZvcmUpLFxuICAgICAgICAgICAgYWZ0ZXI6IGFzTnVtYmVyKGFmdGVyKSxcbiAgICAgICAgICAgIGJpbmFyeTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAgIC8oXFxkKykgZmlsZXM/IGNoYW5nZWRcXHMqKCg/OiwgXFxkKyBbXixdKyl7MCwyfSkvLFxuICAgICAgICAocmVzdWx0LCBbY2hhbmdlZCwgc3VtbWFyeV0pID0+IHtcbiAgICAgICAgICBjb25zdCBpbnNlcnRlZCA9IC8oXFxkKykgaS8uZXhlYyhzdW1tYXJ5KTtcbiAgICAgICAgICBjb25zdCBkZWxldGVkID0gLyhcXGQrKSBkLy5leGVjKHN1bW1hcnkpO1xuICAgICAgICAgIHJlc3VsdC5jaGFuZ2VkID0gYXNOdW1iZXIoY2hhbmdlZCk7XG4gICAgICAgICAgcmVzdWx0Lmluc2VydGlvbnMgPSBhc051bWJlcihpbnNlcnRlZCA9PSBudWxsID8gdm9pZCAwIDogaW5zZXJ0ZWRbMV0pO1xuICAgICAgICAgIHJlc3VsdC5kZWxldGlvbnMgPSBhc051bWJlcihkZWxldGVkID09IG51bGwgPyB2b2lkIDAgOiBkZWxldGVkWzFdKTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIF07XG4gICAgbnVtU3RhdFBhcnNlciA9IFtcbiAgICAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgICAvKFxcZCspXFx0KFxcZCspXFx0KC4rKSQvLFxuICAgICAgICAocmVzdWx0LCBbY2hhbmdlc0luc2VydCwgY2hhbmdlc0RlbGV0ZSwgZmlsZV0pID0+IHtcbiAgICAgICAgICBjb25zdCBpbnNlcnRpb25zID0gYXNOdW1iZXIoY2hhbmdlc0luc2VydCk7XG4gICAgICAgICAgY29uc3QgZGVsZXRpb25zID0gYXNOdW1iZXIoY2hhbmdlc0RlbGV0ZSk7XG4gICAgICAgICAgcmVzdWx0LmNoYW5nZWQrKztcbiAgICAgICAgICByZXN1bHQuaW5zZXJ0aW9ucyArPSBpbnNlcnRpb25zO1xuICAgICAgICAgIHJlc3VsdC5kZWxldGlvbnMgKz0gZGVsZXRpb25zO1xuICAgICAgICAgIHJlc3VsdC5maWxlcy5wdXNoKHtcbiAgICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgICBjaGFuZ2VzOiBpbnNlcnRpb25zICsgZGVsZXRpb25zLFxuICAgICAgICAgICAgaW5zZXJ0aW9ucyxcbiAgICAgICAgICAgIGRlbGV0aW9ucyxcbiAgICAgICAgICAgIGJpbmFyeTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKC8tXFx0LVxcdCguKykkLywgKHJlc3VsdCwgW2ZpbGVdKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jaGFuZ2VkKys7XG4gICAgICAgIHJlc3VsdC5maWxlcy5wdXNoKHtcbiAgICAgICAgICBmaWxlLFxuICAgICAgICAgIGFmdGVyOiAwLFxuICAgICAgICAgIGJlZm9yZTogMCxcbiAgICAgICAgICBiaW5hcnk6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgIF07XG4gICAgbmFtZU9ubHlQYXJzZXIgPSBbXG4gICAgICBuZXcgTGluZVBhcnNlcigvKC4rKSQvLCAocmVzdWx0LCBbZmlsZV0pID0+IHtcbiAgICAgICAgcmVzdWx0LmNoYW5nZWQrKztcbiAgICAgICAgcmVzdWx0LmZpbGVzLnB1c2goe1xuICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgY2hhbmdlczogMCxcbiAgICAgICAgICBpbnNlcnRpb25zOiAwLFxuICAgICAgICAgIGRlbGV0aW9uczogMCxcbiAgICAgICAgICBiaW5hcnk6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICBdO1xuICAgIG5hbWVTdGF0dXNQYXJzZXIgPSBbXG4gICAgICBuZXcgTGluZVBhcnNlcihcbiAgICAgICAgLyhbQUNETVJUVVhCXSkoWzAtOV17MCwzfSlcXHQoLlteXFx0XSopKFxcdCguW15cXHRdKikpPyQvLFxuICAgICAgICAocmVzdWx0LCBbc3RhdHVzLCBzaW1pbGFyaXR5LCBmcm9tLCBfdG8sIHRvXSkgPT4ge1xuICAgICAgICAgIHJlc3VsdC5jaGFuZ2VkKys7XG4gICAgICAgICAgcmVzdWx0LmZpbGVzLnB1c2goe1xuICAgICAgICAgICAgZmlsZTogdG8gIT0gbnVsbCA/IHRvIDogZnJvbSxcbiAgICAgICAgICAgIGNoYW5nZXM6IDAsXG4gICAgICAgICAgICBpbnNlcnRpb25zOiAwLFxuICAgICAgICAgICAgZGVsZXRpb25zOiAwLFxuICAgICAgICAgICAgYmluYXJ5OiBmYWxzZSxcbiAgICAgICAgICAgIHN0YXR1czogb3JWb2lkKGlzRGlmZk5hbWVTdGF0dXMoc3RhdHVzKSAmJiBzdGF0dXMpLFxuICAgICAgICAgICAgZnJvbTogb3JWb2lkKCEhdG8gJiYgZnJvbSAhPT0gdG8gJiYgZnJvbSksXG4gICAgICAgICAgICBzaW1pbGFyaXR5OiBhc051bWJlcihzaW1pbGFyaXR5KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApXG4gICAgXTtcbiAgICBkaWZmU3VtbWFyeVBhcnNlcnMgPSB7XG4gICAgICBbXCJcIiAvKiBOT05FICovXTogc3RhdFBhcnNlcixcbiAgICAgIFtcIi0tc3RhdFwiIC8qIFNUQVQgKi9dOiBzdGF0UGFyc2VyLFxuICAgICAgW1wiLS1udW1zdGF0XCIgLyogTlVNX1NUQVQgKi9dOiBudW1TdGF0UGFyc2VyLFxuICAgICAgW1wiLS1uYW1lLXN0YXR1c1wiIC8qIE5BTUVfU1RBVFVTICovXTogbmFtZVN0YXR1c1BhcnNlcixcbiAgICAgIFtcIi0tbmFtZS1vbmx5XCIgLyogTkFNRV9PTkxZICovXTogbmFtZU9ubHlQYXJzZXJcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9wYXJzZXJzL3BhcnNlLWxpc3QtbG9nLXN1bW1hcnkudHNcbmZ1bmN0aW9uIGxpbmVCdWlsZGVyKHRva2VucywgZmllbGRzKSB7XG4gIHJldHVybiBmaWVsZHMucmVkdWNlKFxuICAgIChsaW5lLCBmaWVsZCwgaW5kZXgpID0+IHtcbiAgICAgIGxpbmVbZmllbGRdID0gdG9rZW5zW2luZGV4XSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfSxcbiAgICAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZSh7IGRpZmY6IG51bGwgfSlcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxpc3RMb2dTdW1tYXJ5UGFyc2VyKHNwbGl0dGVyID0gU1BMSVRURVIsIGZpZWxkcyA9IGRlZmF1bHRGaWVsZE5hbWVzLCBsb2dGb3JtYXQgPSBcIlwiIC8qIE5PTkUgKi8pIHtcbiAgY29uc3QgcGFyc2VEaWZmUmVzdWx0ID0gZ2V0RGlmZlBhcnNlcihsb2dGb3JtYXQpO1xuICByZXR1cm4gZnVuY3Rpb24oc3RkT3V0KSB7XG4gICAgY29uc3QgYWxsID0gdG9MaW5lc1dpdGhDb250ZW50KFxuICAgICAgc3RkT3V0LnRyaW0oKSxcbiAgICAgIGZhbHNlLFxuICAgICAgU1RBUlRfQk9VTkRBUllcbiAgICApLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICBjb25zdCBsaW5lRGV0YWlsID0gaXRlbS5zcGxpdChDT01NSVRfQk9VTkRBUlkpO1xuICAgICAgY29uc3QgbGlzdExvZ0xpbmUgPSBsaW5lQnVpbGRlcihsaW5lRGV0YWlsWzBdLnNwbGl0KHNwbGl0dGVyKSwgZmllbGRzKTtcbiAgICAgIGlmIChsaW5lRGV0YWlsLmxlbmd0aCA+IDEgJiYgISFsaW5lRGV0YWlsWzFdLnRyaW0oKSkge1xuICAgICAgICBsaXN0TG9nTGluZS5kaWZmID0gcGFyc2VEaWZmUmVzdWx0KGxpbmVEZXRhaWxbMV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpc3RMb2dMaW5lO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBhbGwsXG4gICAgICBsYXRlc3Q6IGFsbC5sZW5ndGggJiYgYWxsWzBdIHx8IG51bGwsXG4gICAgICB0b3RhbDogYWxsLmxlbmd0aFxuICAgIH07XG4gIH07XG59XG52YXIgU1RBUlRfQk9VTkRBUlksIENPTU1JVF9CT1VOREFSWSwgU1BMSVRURVIsIGRlZmF1bHRGaWVsZE5hbWVzO1xudmFyIGluaXRfcGFyc2VfbGlzdF9sb2dfc3VtbWFyeSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3BhcnNlcnMvcGFyc2UtbGlzdC1sb2ctc3VtbWFyeS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBpbml0X3BhcnNlX2RpZmZfc3VtbWFyeSgpO1xuICAgIGluaXRfbG9nX2Zvcm1hdCgpO1xuICAgIFNUQVJUX0JPVU5EQVJZID0gXCJcXHhGMlxceEYyXFx4RjJcXHhGMlxceEYyXFx4RjIgXCI7XG4gICAgQ09NTUlUX0JPVU5EQVJZID0gXCIgXFx4RjJcXHhGMlwiO1xuICAgIFNQTElUVEVSID0gXCIgXFx4RjIgXCI7XG4gICAgZGVmYXVsdEZpZWxkTmFtZXMgPSBbXCJoYXNoXCIsIFwiZGF0ZVwiLCBcIm1lc3NhZ2VcIiwgXCJyZWZzXCIsIFwiYXV0aG9yX25hbWVcIiwgXCJhdXRob3JfZW1haWxcIl07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL2RpZmYudHNcbnZhciBkaWZmX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGRpZmZfZXhwb3J0cywge1xuICBkaWZmU3VtbWFyeVRhc2s6ICgpID0+IGRpZmZTdW1tYXJ5VGFzayxcbiAgdmFsaWRhdGVMb2dGb3JtYXRDb25maWc6ICgpID0+IHZhbGlkYXRlTG9nRm9ybWF0Q29uZmlnXG59KTtcbmZ1bmN0aW9uIGRpZmZTdW1tYXJ5VGFzayhjdXN0b21BcmdzKSB7XG4gIGxldCBsb2dGb3JtYXQgPSBsb2dGb3JtYXRGcm9tQ29tbWFuZChjdXN0b21BcmdzKTtcbiAgY29uc3QgY29tbWFuZHMgPSBbXCJkaWZmXCJdO1xuICBpZiAobG9nRm9ybWF0ID09PSBcIlwiIC8qIE5PTkUgKi8pIHtcbiAgICBsb2dGb3JtYXQgPSBcIi0tc3RhdFwiIC8qIFNUQVQgKi87XG4gICAgY29tbWFuZHMucHVzaChcIi0tc3RhdD00MDk2XCIpO1xuICB9XG4gIGNvbW1hbmRzLnB1c2goLi4uY3VzdG9tQXJncyk7XG4gIHJldHVybiB2YWxpZGF0ZUxvZ0Zvcm1hdENvbmZpZyhjb21tYW5kcykgfHwge1xuICAgIGNvbW1hbmRzLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIHBhcnNlcjogZ2V0RGlmZlBhcnNlcihsb2dGb3JtYXQpXG4gIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUxvZ0Zvcm1hdENvbmZpZyhjdXN0b21BcmdzKSB7XG4gIGNvbnN0IGZsYWdzID0gY3VzdG9tQXJncy5maWx0ZXIoaXNMb2dGb3JtYXQpO1xuICBpZiAoZmxhZ3MubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFxuICAgICAgYFN1bW1hcnkgZmxhZ3MgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSAtIHBpY2sgb25lIG9mICR7ZmxhZ3Muam9pbihcIixcIil9YFxuICAgICk7XG4gIH1cbiAgaWYgKGZsYWdzLmxlbmd0aCAmJiBjdXN0b21BcmdzLmluY2x1ZGVzKFwiLXpcIikpIHtcbiAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhcbiAgICAgIGBTdW1tYXJ5IGZsYWcgJHtmbGFnc30gcGFyc2luZyBpcyBub3QgY29tcGF0aWJsZSB3aXRoIG51bGwgdGVybWluYXRpb24gb3B0aW9uICcteidgXG4gICAgKTtcbiAgfVxufVxudmFyIGluaXRfZGlmZiA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2RpZmYudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X2xvZ19mb3JtYXQoKTtcbiAgICBpbml0X3BhcnNlX2RpZmZfc3VtbWFyeSgpO1xuICAgIGluaXRfdGFzaygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9sb2cudHNcbmZ1bmN0aW9uIHByZXR0eUZvcm1hdChmb3JtYXQsIHNwbGl0dGVyKSB7XG4gIGNvbnN0IGZpZWxkcyA9IFtdO1xuICBjb25zdCBmb3JtYXRTdHIgPSBbXTtcbiAgT2JqZWN0LmtleXMoZm9ybWF0KS5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgIGZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICBmb3JtYXRTdHIucHVzaChTdHJpbmcoZm9ybWF0W2ZpZWxkXSkpO1xuICB9KTtcbiAgcmV0dXJuIFtmaWVsZHMsIGZvcm1hdFN0ci5qb2luKHNwbGl0dGVyKV07XG59XG5mdW5jdGlvbiB1c2VyT3B0aW9ucyhpbnB1dCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoaW5wdXQpLnJlZHVjZSgob3V0LCBrZXkpID0+IHtcbiAgICBpZiAoIShrZXkgaW4gZXhjbHVkZU9wdGlvbnMpKSB7XG4gICAgICBvdXRba2V5XSA9IGlucHV0W2tleV07XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlTG9nT3B0aW9ucyhvcHQgPSB7fSwgY3VzdG9tQXJncyA9IFtdKSB7XG4gIGNvbnN0IHNwbGl0dGVyID0gZmlsdGVyVHlwZShvcHQuc3BsaXR0ZXIsIGZpbHRlclN0cmluZywgU1BMSVRURVIpO1xuICBjb25zdCBmb3JtYXQgPSAhZmlsdGVyUHJpbWl0aXZlcyhvcHQuZm9ybWF0KSAmJiBvcHQuZm9ybWF0ID8gb3B0LmZvcm1hdCA6IHtcbiAgICBoYXNoOiBcIiVIXCIsXG4gICAgZGF0ZTogb3B0LnN0cmljdERhdGUgPT09IGZhbHNlID8gXCIlYWlcIiA6IFwiJWFJXCIsXG4gICAgbWVzc2FnZTogXCIlc1wiLFxuICAgIHJlZnM6IFwiJURcIixcbiAgICBib2R5OiBvcHQubXVsdGlMaW5lID8gXCIlQlwiIDogXCIlYlwiLFxuICAgIGF1dGhvcl9uYW1lOiBvcHQubWFpbE1hcCAhPT0gZmFsc2UgPyBcIiVhTlwiIDogXCIlYW5cIixcbiAgICBhdXRob3JfZW1haWw6IG9wdC5tYWlsTWFwICE9PSBmYWxzZSA/IFwiJWFFXCIgOiBcIiVhZVwiXG4gIH07XG4gIGNvbnN0IFtmaWVsZHMsIGZvcm1hdFN0cl0gPSBwcmV0dHlGb3JtYXQoZm9ybWF0LCBzcGxpdHRlcik7XG4gIGNvbnN0IHN1ZmZpeCA9IFtdO1xuICBjb25zdCBjb21tYW5kID0gW1xuICAgIGAtLXByZXR0eT1mb3JtYXQ6JHtTVEFSVF9CT1VOREFSWX0ke2Zvcm1hdFN0cn0ke0NPTU1JVF9CT1VOREFSWX1gLFxuICAgIC4uLmN1c3RvbUFyZ3NcbiAgXTtcbiAgY29uc3QgbWF4Q291bnQgPSBvcHQubiB8fCBvcHRbXCJtYXgtY291bnRcIl0gfHwgb3B0Lm1heENvdW50O1xuICBpZiAobWF4Q291bnQpIHtcbiAgICBjb21tYW5kLnB1c2goYC0tbWF4LWNvdW50PSR7bWF4Q291bnR9YCk7XG4gIH1cbiAgaWYgKG9wdC5mcm9tIHx8IG9wdC50bykge1xuICAgIGNvbnN0IHJhbmdlT3BlcmF0b3IgPSBvcHQuc3ltbWV0cmljICE9PSBmYWxzZSA/IFwiLi4uXCIgOiBcIi4uXCI7XG4gICAgc3VmZml4LnB1c2goYCR7b3B0LmZyb20gfHwgXCJcIn0ke3JhbmdlT3BlcmF0b3J9JHtvcHQudG8gfHwgXCJcIn1gKTtcbiAgfVxuICBpZiAoZmlsdGVyU3RyaW5nKG9wdC5maWxlKSkge1xuICAgIGNvbW1hbmQucHVzaChcIi0tZm9sbG93XCIsIHBhdGhzcGVjKG9wdC5maWxlKSk7XG4gIH1cbiAgYXBwZW5kVGFza09wdGlvbnModXNlck9wdGlvbnMob3B0KSwgY29tbWFuZCk7XG4gIHJldHVybiB7XG4gICAgZmllbGRzLFxuICAgIHNwbGl0dGVyLFxuICAgIGNvbW1hbmRzOiBbLi4uY29tbWFuZCwgLi4uc3VmZml4XVxuICB9O1xufVxuZnVuY3Rpb24gbG9nVGFzayhzcGxpdHRlciwgZmllbGRzLCBjdXN0b21BcmdzKSB7XG4gIGNvbnN0IHBhcnNlcjQgPSBjcmVhdGVMaXN0TG9nU3VtbWFyeVBhcnNlcihzcGxpdHRlciwgZmllbGRzLCBsb2dGb3JtYXRGcm9tQ29tbWFuZChjdXN0b21BcmdzKSk7XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHM6IFtcImxvZ1wiLCAuLi5jdXN0b21BcmdzXSxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXI6IHBhcnNlcjRcbiAgfTtcbn1cbmZ1bmN0aW9uIGxvZ19kZWZhdWx0KCkge1xuICByZXR1cm4ge1xuICAgIGxvZyguLi5yZXN0KSB7XG4gICAgICBjb25zdCBuZXh0ID0gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cyk7XG4gICAgICBjb25zdCBvcHRpb25zID0gcGFyc2VMb2dPcHRpb25zKFxuICAgICAgICB0cmFpbGluZ09wdGlvbnNBcmd1bWVudChhcmd1bWVudHMpLFxuICAgICAgICBmaWx0ZXJUeXBlKGFyZ3VtZW50c1swXSwgZmlsdGVyQXJyYXkpXG4gICAgICApO1xuICAgICAgY29uc3QgdGFzayA9IHJlamVjdERlcHJlY2F0ZWRTaWduYXR1cmVzKC4uLnJlc3QpIHx8IHZhbGlkYXRlTG9nRm9ybWF0Q29uZmlnKG9wdGlvbnMuY29tbWFuZHMpIHx8IGNyZWF0ZUxvZ1Rhc2sob3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCBuZXh0KTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGNyZWF0ZUxvZ1Rhc2sob3B0aW9ucykge1xuICAgIHJldHVybiBsb2dUYXNrKG9wdGlvbnMuc3BsaXR0ZXIsIG9wdGlvbnMuZmllbGRzLCBvcHRpb25zLmNvbW1hbmRzKTtcbiAgfVxuICBmdW5jdGlvbiByZWplY3REZXByZWNhdGVkU2lnbmF0dXJlcyhmcm9tLCB0bykge1xuICAgIHJldHVybiBmaWx0ZXJTdHJpbmcoZnJvbSkgJiYgZmlsdGVyU3RyaW5nKHRvKSAmJiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFxuICAgICAgYGdpdC5sb2coc3RyaW5nLCBzdHJpbmcpIHNob3VsZCBiZSByZXBsYWNlZCB3aXRoIGdpdC5sb2coeyBmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcgfSlgXG4gICAgKTtcbiAgfVxufVxudmFyIGV4Y2x1ZGVPcHRpb25zO1xudmFyIGluaXRfbG9nID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvbG9nLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9sb2dfZm9ybWF0KCk7XG4gICAgaW5pdF9wYXRoc3BlYygpO1xuICAgIGluaXRfcGFyc2VfbGlzdF9sb2dfc3VtbWFyeSgpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBpbml0X3Rhc2soKTtcbiAgICBpbml0X2RpZmYoKTtcbiAgICBleGNsdWRlT3B0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyAoKGV4Y2x1ZGVPcHRpb25zMikgPT4ge1xuICAgICAgZXhjbHVkZU9wdGlvbnMyW2V4Y2x1ZGVPcHRpb25zMltcIi0tcHJldHR5XCJdID0gMF0gPSBcIi0tcHJldHR5XCI7XG4gICAgICBleGNsdWRlT3B0aW9uczJbZXhjbHVkZU9wdGlvbnMyW1wibWF4LWNvdW50XCJdID0gMV0gPSBcIm1heC1jb3VudFwiO1xuICAgICAgZXhjbHVkZU9wdGlvbnMyW2V4Y2x1ZGVPcHRpb25zMltcIm1heENvdW50XCJdID0gMl0gPSBcIm1heENvdW50XCI7XG4gICAgICBleGNsdWRlT3B0aW9uczJbZXhjbHVkZU9wdGlvbnMyW1wiblwiXSA9IDNdID0gXCJuXCI7XG4gICAgICBleGNsdWRlT3B0aW9uczJbZXhjbHVkZU9wdGlvbnMyW1wiZmlsZVwiXSA9IDRdID0gXCJmaWxlXCI7XG4gICAgICBleGNsdWRlT3B0aW9uczJbZXhjbHVkZU9wdGlvbnMyW1wiZm9ybWF0XCJdID0gNV0gPSBcImZvcm1hdFwiO1xuICAgICAgZXhjbHVkZU9wdGlvbnMyW2V4Y2x1ZGVPcHRpb25zMltcImZyb21cIl0gPSA2XSA9IFwiZnJvbVwiO1xuICAgICAgZXhjbHVkZU9wdGlvbnMyW2V4Y2x1ZGVPcHRpb25zMltcInRvXCJdID0gN10gPSBcInRvXCI7XG4gICAgICBleGNsdWRlT3B0aW9uczJbZXhjbHVkZU9wdGlvbnMyW1wic3BsaXR0ZXJcIl0gPSA4XSA9IFwic3BsaXR0ZXJcIjtcbiAgICAgIGV4Y2x1ZGVPcHRpb25zMltleGNsdWRlT3B0aW9uczJbXCJzeW1tZXRyaWNcIl0gPSA5XSA9IFwic3ltbWV0cmljXCI7XG4gICAgICBleGNsdWRlT3B0aW9uczJbZXhjbHVkZU9wdGlvbnMyW1wibWFpbE1hcFwiXSA9IDEwXSA9IFwibWFpbE1hcFwiO1xuICAgICAgZXhjbHVkZU9wdGlvbnMyW2V4Y2x1ZGVPcHRpb25zMltcIm11bHRpTGluZVwiXSA9IDExXSA9IFwibXVsdGlMaW5lXCI7XG4gICAgICBleGNsdWRlT3B0aW9uczJbZXhjbHVkZU9wdGlvbnMyW1wic3RyaWN0RGF0ZVwiXSA9IDEyXSA9IFwic3RyaWN0RGF0ZVwiO1xuICAgICAgcmV0dXJuIGV4Y2x1ZGVPcHRpb25zMjtcbiAgICB9KShleGNsdWRlT3B0aW9ucyB8fCB7fSk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Jlc3BvbnNlcy9NZXJnZVN1bW1hcnkudHNcbnZhciBNZXJnZVN1bW1hcnlDb25mbGljdCwgTWVyZ2VTdW1tYXJ5RGV0YWlsO1xudmFyIGluaXRfTWVyZ2VTdW1tYXJ5ID0gX19lc20oe1xuICBcInNyYy9saWIvcmVzcG9uc2VzL01lcmdlU3VtbWFyeS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE1lcmdlU3VtbWFyeUNvbmZsaWN0ID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IocmVhc29uLCBmaWxlID0gbnVsbCwgbWV0YSkge1xuICAgICAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgdGhpcy5maWxlID0gZmlsZTtcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICAgIH1cbiAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5maWxlfToke3RoaXMucmVhc29ufWA7XG4gICAgICB9XG4gICAgfTtcbiAgICBNZXJnZVN1bW1hcnlEZXRhaWwgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb25mbGljdHMgPSBbXTtcbiAgICAgICAgdGhpcy5tZXJnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5yZXN1bHQgPSBcInN1Y2Nlc3NcIjtcbiAgICAgIH1cbiAgICAgIGdldCBmYWlsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZsaWN0cy5sZW5ndGggPiAwO1xuICAgICAgfVxuICAgICAgZ2V0IHJlYXNvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgICAgfVxuICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZsaWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gYENPTkZMSUNUUzogJHt0aGlzLmNvbmZsaWN0cy5qb2luKFwiLCBcIil9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJPS1wiO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Jlc3BvbnNlcy9QdWxsU3VtbWFyeS50c1xudmFyIFB1bGxTdW1tYXJ5LCBQdWxsRmFpbGVkU3VtbWFyeTtcbnZhciBpbml0X1B1bGxTdW1tYXJ5ID0gX19lc20oe1xuICBcInNyYy9saWIvcmVzcG9uc2VzL1B1bGxTdW1tYXJ5LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgUHVsbFN1bW1hcnkgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yZW1vdGVNZXNzYWdlcyA9IHtcbiAgICAgICAgICBhbGw6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY3JlYXRlZCA9IFtdO1xuICAgICAgICB0aGlzLmRlbGV0ZWQgPSBbXTtcbiAgICAgICAgdGhpcy5maWxlcyA9IFtdO1xuICAgICAgICB0aGlzLmRlbGV0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLmluc2VydGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5zdW1tYXJ5ID0ge1xuICAgICAgICAgIGNoYW5nZXM6IDAsXG4gICAgICAgICAgZGVsZXRpb25zOiAwLFxuICAgICAgICAgIGluc2VydGlvbnM6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFB1bGxGYWlsZWRTdW1tYXJ5ID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVtb3RlID0gXCJcIjtcbiAgICAgICAgdGhpcy5oYXNoID0ge1xuICAgICAgICAgIGxvY2FsOiBcIlwiLFxuICAgICAgICAgIHJlbW90ZTogXCJcIlxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJyYW5jaCA9IHtcbiAgICAgICAgICBsb2NhbDogXCJcIixcbiAgICAgICAgICByZW1vdGU6IFwiXCJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3BhcnNlcnMvcGFyc2UtcmVtb3RlLW9iamVjdHMudHNcbmZ1bmN0aW9uIG9iamVjdEVudW1lcmF0aW9uUmVzdWx0KHJlbW90ZU1lc3NhZ2VzKSB7XG4gIHJldHVybiByZW1vdGVNZXNzYWdlcy5vYmplY3RzID0gcmVtb3RlTWVzc2FnZXMub2JqZWN0cyB8fCB7XG4gICAgY29tcHJlc3Npbmc6IDAsXG4gICAgY291bnRpbmc6IDAsXG4gICAgZW51bWVyYXRpbmc6IDAsXG4gICAgcGFja1JldXNlZDogMCxcbiAgICByZXVzZWQ6IHsgY291bnQ6IDAsIGRlbHRhOiAwIH0sXG4gICAgdG90YWw6IHsgY291bnQ6IDAsIGRlbHRhOiAwIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGFzT2JqZWN0Q291bnQoc291cmNlKSB7XG4gIGNvbnN0IGNvdW50ID0gL15cXHMqKFxcZCspLy5leGVjKHNvdXJjZSk7XG4gIGNvbnN0IGRlbHRhID0gL2RlbHRhIChcXGQrKS9pLmV4ZWMoc291cmNlKTtcbiAgcmV0dXJuIHtcbiAgICBjb3VudDogYXNOdW1iZXIoY291bnQgJiYgY291bnRbMV0gfHwgXCIwXCIpLFxuICAgIGRlbHRhOiBhc051bWJlcihkZWx0YSAmJiBkZWx0YVsxXSB8fCBcIjBcIilcbiAgfTtcbn1cbnZhciByZW1vdGVNZXNzYWdlc09iamVjdFBhcnNlcnM7XG52YXIgaW5pdF9wYXJzZV9yZW1vdGVfb2JqZWN0cyA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3BhcnNlcnMvcGFyc2UtcmVtb3RlLW9iamVjdHMudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgcmVtb3RlTWVzc2FnZXNPYmplY3RQYXJzZXJzID0gW1xuICAgICAgbmV3IFJlbW90ZUxpbmVQYXJzZXIoXG4gICAgICAgIC9ecmVtb3RlOlxccyooZW51bWVyYXRpbmd8Y291bnRpbmd8Y29tcHJlc3NpbmcpIG9iamVjdHM6IChcXGQrKSwvaSxcbiAgICAgICAgKHJlc3VsdCwgW2FjdGlvbiwgY291bnRdKSA9PiB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYWN0aW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgY29uc3QgZW51bWVyYXRpb24gPSBvYmplY3RFbnVtZXJhdGlvblJlc3VsdChyZXN1bHQucmVtb3RlTWVzc2FnZXMpO1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24oZW51bWVyYXRpb24sIHsgW2tleV06IGFzTnVtYmVyKGNvdW50KSB9KTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIG5ldyBSZW1vdGVMaW5lUGFyc2VyKFxuICAgICAgICAvXnJlbW90ZTpcXHMqKGVudW1lcmF0aW5nfGNvdW50aW5nfGNvbXByZXNzaW5nKSBvYmplY3RzOiBcXGQrJSBcXChcXGQrXFwvKFxcZCspXFwpLC9pLFxuICAgICAgICAocmVzdWx0LCBbYWN0aW9uLCBjb3VudF0pID0+IHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBhY3Rpb24udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBjb25zdCBlbnVtZXJhdGlvbiA9IG9iamVjdEVudW1lcmF0aW9uUmVzdWx0KHJlc3VsdC5yZW1vdGVNZXNzYWdlcyk7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihlbnVtZXJhdGlvbiwgeyBba2V5XTogYXNOdW1iZXIoY291bnQpIH0pO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgbmV3IFJlbW90ZUxpbmVQYXJzZXIoXG4gICAgICAgIC90b3RhbCAoW14sXSspLCByZXVzZWQgKFteLF0rKSwgcGFjay1yZXVzZWQgKFxcZCspL2ksXG4gICAgICAgIChyZXN1bHQsIFt0b3RhbCwgcmV1c2VkLCBwYWNrUmV1c2VkXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG9iamVjdHMgPSBvYmplY3RFbnVtZXJhdGlvblJlc3VsdChyZXN1bHQucmVtb3RlTWVzc2FnZXMpO1xuICAgICAgICAgIG9iamVjdHMudG90YWwgPSBhc09iamVjdENvdW50KHRvdGFsKTtcbiAgICAgICAgICBvYmplY3RzLnJldXNlZCA9IGFzT2JqZWN0Q291bnQocmV1c2VkKTtcbiAgICAgICAgICBvYmplY3RzLnBhY2tSZXVzZWQgPSBhc051bWJlcihwYWNrUmV1c2VkKTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3BhcnNlcnMvcGFyc2UtcmVtb3RlLW1lc3NhZ2VzLnRzXG5mdW5jdGlvbiBwYXJzZVJlbW90ZU1lc3NhZ2VzKF9zdGRPdXQsIHN0ZEVycikge1xuICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZSh7IHJlbW90ZU1lc3NhZ2VzOiBuZXcgUmVtb3RlTWVzc2FnZVN1bW1hcnkoKSB9LCBwYXJzZXJzMiwgc3RkRXJyKTtcbn1cbnZhciBwYXJzZXJzMiwgUmVtb3RlTWVzc2FnZVN1bW1hcnk7XG52YXIgaW5pdF9wYXJzZV9yZW1vdGVfbWVzc2FnZXMgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9wYXJzZXJzL3BhcnNlLXJlbW90ZS1tZXNzYWdlcy50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBpbml0X3BhcnNlX3JlbW90ZV9vYmplY3RzKCk7XG4gICAgcGFyc2VyczIgPSBbXG4gICAgICBuZXcgUmVtb3RlTGluZVBhcnNlcigvXnJlbW90ZTpcXHMqKC4rKSQvLCAocmVzdWx0LCBbdGV4dF0pID0+IHtcbiAgICAgICAgcmVzdWx0LnJlbW90ZU1lc3NhZ2VzLmFsbC5wdXNoKHRleHQudHJpbSgpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSksXG4gICAgICAuLi5yZW1vdGVNZXNzYWdlc09iamVjdFBhcnNlcnMsXG4gICAgICBuZXcgUmVtb3RlTGluZVBhcnNlcihcbiAgICAgICAgWy9jcmVhdGUgYSAoPzpwdWxsfG1lcmdlKSByZXF1ZXN0L2ksIC9cXHMoaHR0cHM/OlxcL1xcL1xcUyspJC9dLFxuICAgICAgICAocmVzdWx0LCBbcHVsbFJlcXVlc3RVcmxdKSA9PiB7XG4gICAgICAgICAgcmVzdWx0LnJlbW90ZU1lc3NhZ2VzLnB1bGxSZXF1ZXN0VXJsID0gcHVsbFJlcXVlc3RVcmw7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgUmVtb3RlTGluZVBhcnNlcihcbiAgICAgICAgWy9mb3VuZCAoXFxkKykgdnVsbmVyYWJpbGl0aWVzLitcXCgoW14pXSspXFwpL2ksIC9cXHMoaHR0cHM/OlxcL1xcL1xcUyspJC9dLFxuICAgICAgICAocmVzdWx0LCBbY291bnQsIHN1bW1hcnksIHVybF0pID0+IHtcbiAgICAgICAgICByZXN1bHQucmVtb3RlTWVzc2FnZXMudnVsbmVyYWJpbGl0aWVzID0ge1xuICAgICAgICAgICAgY291bnQ6IGFzTnVtYmVyKGNvdW50KSxcbiAgICAgICAgICAgIHN1bW1hcnksXG4gICAgICAgICAgICB1cmxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICApXG4gICAgXTtcbiAgICBSZW1vdGVNZXNzYWdlU3VtbWFyeSA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFsbCA9IFtdO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3BhcnNlcnMvcGFyc2UtcHVsbC50c1xuZnVuY3Rpb24gcGFyc2VQdWxsRXJyb3JSZXN1bHQoc3RkT3V0LCBzdGRFcnIpIHtcbiAgY29uc3QgcHVsbEVycm9yID0gcGFyc2VTdHJpbmdSZXNwb25zZShuZXcgUHVsbEZhaWxlZFN1bW1hcnkoKSwgZXJyb3JQYXJzZXJzLCBbc3RkT3V0LCBzdGRFcnJdKTtcbiAgcmV0dXJuIHB1bGxFcnJvci5tZXNzYWdlICYmIHB1bGxFcnJvcjtcbn1cbnZhciBGSUxFX1VQREFURV9SRUdFWCwgU1VNTUFSWV9SRUdFWCwgQUNUSU9OX1JFR0VYLCBwYXJzZXJzMywgZXJyb3JQYXJzZXJzLCBwYXJzZVB1bGxEZXRhaWwsIHBhcnNlUHVsbFJlc3VsdDtcbnZhciBpbml0X3BhcnNlX3B1bGwgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9wYXJzZXJzL3BhcnNlLXB1bGwudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X1B1bGxTdW1tYXJ5KCk7XG4gICAgaW5pdF91dGlscygpO1xuICAgIGluaXRfcGFyc2VfcmVtb3RlX21lc3NhZ2VzKCk7XG4gICAgRklMRV9VUERBVEVfUkVHRVggPSAvXlxccyooLis/KVxccytcXHxcXHMrXFxkK1xccyooXFwrKikoLSopLztcbiAgICBTVU1NQVJZX1JFR0VYID0gLyhcXGQrKVxcRCsoKFxcZCspXFxEK1xcKFxcK1xcKSk/KFxcRCsoXFxkKylcXEQrXFwoLVxcKSk/LztcbiAgICBBQ1RJT05fUkVHRVggPSAvXihjcmVhdGV8ZGVsZXRlKSBtb2RlIFxcZCsgKC4rKS87XG4gICAgcGFyc2VyczMgPSBbXG4gICAgICBuZXcgTGluZVBhcnNlcihGSUxFX1VQREFURV9SRUdFWCwgKHJlc3VsdCwgW2ZpbGUsIGluc2VydGlvbnMsIGRlbGV0aW9uc10pID0+IHtcbiAgICAgICAgcmVzdWx0LmZpbGVzLnB1c2goZmlsZSk7XG4gICAgICAgIGlmIChpbnNlcnRpb25zKSB7XG4gICAgICAgICAgcmVzdWx0Lmluc2VydGlvbnNbZmlsZV0gPSBpbnNlcnRpb25zLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsZXRpb25zKSB7XG4gICAgICAgICAgcmVzdWx0LmRlbGV0aW9uc1tmaWxlXSA9IGRlbGV0aW9ucy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgbmV3IExpbmVQYXJzZXIoU1VNTUFSWV9SRUdFWCwgKHJlc3VsdCwgW2NoYW5nZXMsICwgaW5zZXJ0aW9ucywgLCBkZWxldGlvbnNdKSA9PiB7XG4gICAgICAgIGlmIChpbnNlcnRpb25zICE9PSB2b2lkIDAgfHwgZGVsZXRpb25zICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXN1bHQuc3VtbWFyeS5jaGFuZ2VzID0gK2NoYW5nZXMgfHwgMDtcbiAgICAgICAgICByZXN1bHQuc3VtbWFyeS5pbnNlcnRpb25zID0gK2luc2VydGlvbnMgfHwgMDtcbiAgICAgICAgICByZXN1bHQuc3VtbWFyeS5kZWxldGlvbnMgPSArZGVsZXRpb25zIHx8IDA7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSksXG4gICAgICBuZXcgTGluZVBhcnNlcihBQ1RJT05fUkVHRVgsIChyZXN1bHQsIFthY3Rpb24sIGZpbGVdKSA9PiB7XG4gICAgICAgIGFwcGVuZChyZXN1bHQuZmlsZXMsIGZpbGUpO1xuICAgICAgICBhcHBlbmQoYWN0aW9uID09PSBcImNyZWF0ZVwiID8gcmVzdWx0LmNyZWF0ZWQgOiByZXN1bHQuZGVsZXRlZCwgZmlsZSk7XG4gICAgICB9KVxuICAgIF07XG4gICAgZXJyb3JQYXJzZXJzID0gW1xuICAgICAgbmV3IExpbmVQYXJzZXIoL15mcm9tXFxzKC4rKSQvaSwgKHJlc3VsdCwgW3JlbW90ZV0pID0+IHZvaWQgKHJlc3VsdC5yZW1vdGUgPSByZW1vdGUpKSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKC9eZmF0YWw6XFxzKC4rKSQvLCAocmVzdWx0LCBbbWVzc2FnZV0pID0+IHZvaWQgKHJlc3VsdC5tZXNzYWdlID0gbWVzc2FnZSkpLFxuICAgICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAgIC8oW2EtejAtOV0rKVxcLlxcLihbYS16MC05XSspXFxzKyhcXFMrKVxccystPlxccysoXFxTKykkLyxcbiAgICAgICAgKHJlc3VsdCwgW2hhc2hMb2NhbCwgaGFzaFJlbW90ZSwgYnJhbmNoTG9jYWwsIGJyYW5jaFJlbW90ZV0pID0+IHtcbiAgICAgICAgICByZXN1bHQuYnJhbmNoLmxvY2FsID0gYnJhbmNoTG9jYWw7XG4gICAgICAgICAgcmVzdWx0Lmhhc2gubG9jYWwgPSBoYXNoTG9jYWw7XG4gICAgICAgICAgcmVzdWx0LmJyYW5jaC5yZW1vdGUgPSBicmFuY2hSZW1vdGU7XG4gICAgICAgICAgcmVzdWx0Lmhhc2gucmVtb3RlID0gaGFzaFJlbW90ZTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIF07XG4gICAgcGFyc2VQdWxsRGV0YWlsID0gKHN0ZE91dCwgc3RkRXJyKSA9PiB7XG4gICAgICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZShuZXcgUHVsbFN1bW1hcnkoKSwgcGFyc2VyczMsIFtzdGRPdXQsIHN0ZEVycl0pO1xuICAgIH07XG4gICAgcGFyc2VQdWxsUmVzdWx0ID0gKHN0ZE91dCwgc3RkRXJyKSA9PiB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgbmV3IFB1bGxTdW1tYXJ5KCksXG4gICAgICAgIHBhcnNlUHVsbERldGFpbChzdGRPdXQsIHN0ZEVyciksXG4gICAgICAgIHBhcnNlUmVtb3RlTWVzc2FnZXMoc3RkT3V0LCBzdGRFcnIpXG4gICAgICApO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3BhcnNlcnMvcGFyc2UtbWVyZ2UudHNcbnZhciBwYXJzZXJzNCwgcGFyc2VNZXJnZVJlc3VsdCwgcGFyc2VNZXJnZURldGFpbDtcbnZhciBpbml0X3BhcnNlX21lcmdlID0gX19lc20oe1xuICBcInNyYy9saWIvcGFyc2Vycy9wYXJzZS1tZXJnZS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfTWVyZ2VTdW1tYXJ5KCk7XG4gICAgaW5pdF91dGlscygpO1xuICAgIGluaXRfcGFyc2VfcHVsbCgpO1xuICAgIHBhcnNlcnM0ID0gW1xuICAgICAgbmV3IExpbmVQYXJzZXIoL15BdXRvLW1lcmdpbmdcXHMrKC4rKSQvLCAoc3VtbWFyeSwgW2F1dG9NZXJnZV0pID0+IHtcbiAgICAgICAgc3VtbWFyeS5tZXJnZXMucHVzaChhdXRvTWVyZ2UpO1xuICAgICAgfSksXG4gICAgICBuZXcgTGluZVBhcnNlcigvXkNPTkZMSUNUXFxzK1xcKCguKylcXCk6IE1lcmdlIGNvbmZsaWN0IGluICguKykkLywgKHN1bW1hcnksIFtyZWFzb24sIGZpbGVdKSA9PiB7XG4gICAgICAgIHN1bW1hcnkuY29uZmxpY3RzLnB1c2gobmV3IE1lcmdlU3VtbWFyeUNvbmZsaWN0KHJlYXNvbiwgZmlsZSkpO1xuICAgICAgfSksXG4gICAgICBuZXcgTGluZVBhcnNlcihcbiAgICAgICAgL15DT05GTElDVFxccytcXCgoLitcXC9kZWxldGUpXFwpOiAoLispIGRlbGV0ZWQgaW4gKC4rKSBhbmQvLFxuICAgICAgICAoc3VtbWFyeSwgW3JlYXNvbiwgZmlsZSwgZGVsZXRlUmVmXSkgPT4ge1xuICAgICAgICAgIHN1bW1hcnkuY29uZmxpY3RzLnB1c2gobmV3IE1lcmdlU3VtbWFyeUNvbmZsaWN0KHJlYXNvbiwgZmlsZSwgeyBkZWxldGVSZWYgfSkpO1xuICAgICAgICB9XG4gICAgICApLFxuICAgICAgbmV3IExpbmVQYXJzZXIoL15DT05GTElDVFxccytcXCgoLispXFwpOi8sIChzdW1tYXJ5LCBbcmVhc29uXSkgPT4ge1xuICAgICAgICBzdW1tYXJ5LmNvbmZsaWN0cy5wdXNoKG5ldyBNZXJnZVN1bW1hcnlDb25mbGljdChyZWFzb24sIG51bGwpKTtcbiAgICAgIH0pLFxuICAgICAgbmV3IExpbmVQYXJzZXIoL15BdXRvbWF0aWMgbWVyZ2UgZmFpbGVkO1xccysoLispJC8sIChzdW1tYXJ5LCBbcmVzdWx0XSkgPT4ge1xuICAgICAgICBzdW1tYXJ5LnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgIH0pXG4gICAgXTtcbiAgICBwYXJzZU1lcmdlUmVzdWx0ID0gKHN0ZE91dCwgc3RkRXJyKSA9PiB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihwYXJzZU1lcmdlRGV0YWlsKHN0ZE91dCwgc3RkRXJyKSwgcGFyc2VQdWxsUmVzdWx0KHN0ZE91dCwgc3RkRXJyKSk7XG4gICAgfTtcbiAgICBwYXJzZU1lcmdlRGV0YWlsID0gKHN0ZE91dCkgPT4ge1xuICAgICAgcmV0dXJuIHBhcnNlU3RyaW5nUmVzcG9uc2UobmV3IE1lcmdlU3VtbWFyeURldGFpbCgpLCBwYXJzZXJzNCwgc3RkT3V0KTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9tZXJnZS50c1xuZnVuY3Rpb24gbWVyZ2VUYXNrKGN1c3RvbUFyZ3MpIHtcbiAgaWYgKCFjdXN0b21BcmdzLmxlbmd0aCkge1xuICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFwiR2l0Lm1lcmdlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBvcHRpb25cIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kczogW1wibWVyZ2VcIiwgLi4uY3VzdG9tQXJnc10sXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyKHN0ZE91dCwgc3RkRXJyKSB7XG4gICAgICBjb25zdCBtZXJnZSA9IHBhcnNlTWVyZ2VSZXN1bHQoc3RkT3V0LCBzdGRFcnIpO1xuICAgICAgaWYgKG1lcmdlLmZhaWxlZCkge1xuICAgICAgICB0aHJvdyBuZXcgR2l0UmVzcG9uc2VFcnJvcihtZXJnZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2U7XG4gICAgfVxuICB9O1xufVxudmFyIGluaXRfbWVyZ2UgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9tZXJnZS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfZ2l0X3Jlc3BvbnNlX2Vycm9yKCk7XG4gICAgaW5pdF9wYXJzZV9tZXJnZSgpO1xuICAgIGluaXRfdGFzaygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9wYXJzZXJzL3BhcnNlLXB1c2gudHNcbmZ1bmN0aW9uIHB1c2hSZXN1bHRQdXNoZWRJdGVtKGxvY2FsLCByZW1vdGUsIHN0YXR1cykge1xuICBjb25zdCBkZWxldGVkID0gc3RhdHVzLmluY2x1ZGVzKFwiZGVsZXRlZFwiKTtcbiAgY29uc3QgdGFnID0gc3RhdHVzLmluY2x1ZGVzKFwidGFnXCIpIHx8IC9ecmVmc1xcL3RhZ3MvLnRlc3QobG9jYWwpO1xuICBjb25zdCBhbHJlYWR5VXBkYXRlZCA9ICFzdGF0dXMuaW5jbHVkZXMoXCJuZXdcIik7XG4gIHJldHVybiB7XG4gICAgZGVsZXRlZCxcbiAgICB0YWcsXG4gICAgYnJhbmNoOiAhdGFnLFxuICAgIG5ldzogIWFscmVhZHlVcGRhdGVkLFxuICAgIGFscmVhZHlVcGRhdGVkLFxuICAgIGxvY2FsLFxuICAgIHJlbW90ZVxuICB9O1xufVxudmFyIHBhcnNlcnM1LCBwYXJzZVB1c2hSZXN1bHQsIHBhcnNlUHVzaERldGFpbDtcbnZhciBpbml0X3BhcnNlX3B1c2ggPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9wYXJzZXJzL3BhcnNlLXB1c2gudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF9wYXJzZV9yZW1vdGVfbWVzc2FnZXMoKTtcbiAgICBwYXJzZXJzNSA9IFtcbiAgICAgIG5ldyBMaW5lUGFyc2VyKC9eUHVzaGluZyB0byAoLispJC8sIChyZXN1bHQsIFtyZXBvXSkgPT4ge1xuICAgICAgICByZXN1bHQucmVwbyA9IHJlcG87XG4gICAgICB9KSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKC9edXBkYXRpbmcgbG9jYWwgdHJhY2tpbmcgcmVmICcoLispJy8sIChyZXN1bHQsIFtsb2NhbF0pID0+IHtcbiAgICAgICAgcmVzdWx0LnJlZiA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHJlc3VsdC5yZWYgfHwge30pLCB7XG4gICAgICAgICAgbG9jYWxcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKC9eWz0qLV1cXHMrKFteOl0rKTooXFxTKylcXHMrXFxbKC4rKV0kLywgKHJlc3VsdCwgW2xvY2FsLCByZW1vdGUsIHR5cGVdKSA9PiB7XG4gICAgICAgIHJlc3VsdC5wdXNoZWQucHVzaChwdXNoUmVzdWx0UHVzaGVkSXRlbShsb2NhbCwgcmVtb3RlLCB0eXBlKSk7XG4gICAgICB9KSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgICAvXkJyYW5jaCAnKFteJ10rKScgc2V0IHVwIHRvIHRyYWNrIHJlbW90ZSBicmFuY2ggJyhbXiddKyknIGZyb20gJyhbXiddKyknLyxcbiAgICAgICAgKHJlc3VsdCwgW2xvY2FsLCByZW1vdGUsIHJlbW90ZU5hbWVdKSA9PiB7XG4gICAgICAgICAgcmVzdWx0LmJyYW5jaCA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIHJlc3VsdC5icmFuY2ggfHwge30pLCB7XG4gICAgICAgICAgICBsb2NhbCxcbiAgICAgICAgICAgIHJlbW90ZSxcbiAgICAgICAgICAgIHJlbW90ZU5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgICAvXihbXjpdKyk6KFxcUyspXFxzKyhbYS16MC05XSspXFwuXFwuKFthLXowLTldKykkLyxcbiAgICAgICAgKHJlc3VsdCwgW2xvY2FsLCByZW1vdGUsIGZyb20sIHRvXSkgPT4ge1xuICAgICAgICAgIHJlc3VsdC51cGRhdGUgPSB7XG4gICAgICAgICAgICBoZWFkOiB7XG4gICAgICAgICAgICAgIGxvY2FsLFxuICAgICAgICAgICAgICByZW1vdGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXNoOiB7XG4gICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgIHRvXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIF07XG4gICAgcGFyc2VQdXNoUmVzdWx0ID0gKHN0ZE91dCwgc3RkRXJyKSA9PiB7XG4gICAgICBjb25zdCBwdXNoRGV0YWlsID0gcGFyc2VQdXNoRGV0YWlsKHN0ZE91dCwgc3RkRXJyKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlRGV0YWlsID0gcGFyc2VSZW1vdGVNZXNzYWdlcyhzdGRPdXQsIHN0ZEVycik7XG4gICAgICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHB1c2hEZXRhaWwpLCByZXNwb25zZURldGFpbCk7XG4gICAgfTtcbiAgICBwYXJzZVB1c2hEZXRhaWwgPSAoc3RkT3V0LCBzdGRFcnIpID0+IHtcbiAgICAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKHsgcHVzaGVkOiBbXSB9LCBwYXJzZXJzNSwgW3N0ZE91dCwgc3RkRXJyXSk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvcHVzaC50c1xudmFyIHB1c2hfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocHVzaF9leHBvcnRzLCB7XG4gIHB1c2hUYWdzVGFzazogKCkgPT4gcHVzaFRhZ3NUYXNrLFxuICBwdXNoVGFzazogKCkgPT4gcHVzaFRhc2tcbn0pO1xuZnVuY3Rpb24gcHVzaFRhZ3NUYXNrKHJlZiA9IHt9LCBjdXN0b21BcmdzKSB7XG4gIGFwcGVuZChjdXN0b21BcmdzLCBcIi0tdGFnc1wiKTtcbiAgcmV0dXJuIHB1c2hUYXNrKHJlZiwgY3VzdG9tQXJncyk7XG59XG5mdW5jdGlvbiBwdXNoVGFzayhyZWYgPSB7fSwgY3VzdG9tQXJncykge1xuICBjb25zdCBjb21tYW5kcyA9IFtcInB1c2hcIiwgLi4uY3VzdG9tQXJnc107XG4gIGlmIChyZWYuYnJhbmNoKSB7XG4gICAgY29tbWFuZHMuc3BsaWNlKDEsIDAsIHJlZi5icmFuY2gpO1xuICB9XG4gIGlmIChyZWYucmVtb3RlKSB7XG4gICAgY29tbWFuZHMuc3BsaWNlKDEsIDAsIHJlZi5yZW1vdGUpO1xuICB9XG4gIHJlbW92ZShjb21tYW5kcywgXCItdlwiKTtcbiAgYXBwZW5kKGNvbW1hbmRzLCBcIi0tdmVyYm9zZVwiKTtcbiAgYXBwZW5kKGNvbW1hbmRzLCBcIi0tcG9yY2VsYWluXCIpO1xuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIHBhcnNlcjogcGFyc2VQdXNoUmVzdWx0XG4gIH07XG59XG52YXIgaW5pdF9wdXNoID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvcHVzaC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfcGFyc2VfcHVzaCgpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3Mvc2hvdy50c1xuZnVuY3Rpb24gc2hvd19kZWZhdWx0KCkge1xuICByZXR1cm4ge1xuICAgIHNob3dCdWZmZXIoKSB7XG4gICAgICBjb25zdCBjb21tYW5kcyA9IFtcInNob3dcIiwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgMSldO1xuICAgICAgaWYgKCFjb21tYW5kcy5pbmNsdWRlcyhcIi0tYmluYXJ5XCIpKSB7XG4gICAgICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCBcIi0tYmluYXJ5XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2soY29tbWFuZHMpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9LFxuICAgIHNob3coKSB7XG4gICAgICBjb25zdCBjb21tYW5kcyA9IFtcInNob3dcIiwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgMSldO1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG52YXIgaW5pdF9zaG93ID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3Mvc2hvdy50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBpbml0X3Rhc2soKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcmVzcG9uc2VzL0ZpbGVTdGF0dXNTdW1tYXJ5LnRzXG52YXIgZnJvbVBhdGhSZWdleCwgRmlsZVN0YXR1c1N1bW1hcnk7XG52YXIgaW5pdF9GaWxlU3RhdHVzU3VtbWFyeSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Jlc3BvbnNlcy9GaWxlU3RhdHVzU3VtbWFyeS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGZyb21QYXRoUmVnZXggPSAvXiguKylcXDAoLispJC87XG4gICAgRmlsZVN0YXR1c1N1bW1hcnkgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcihwYXRoLCBpbmRleCwgd29ya2luZ19kaXIpIHtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLndvcmtpbmdfZGlyID0gd29ya2luZ19kaXI7XG4gICAgICAgIGlmIChpbmRleCA9PT0gXCJSXCIgfHwgd29ya2luZ19kaXIgPT09IFwiUlwiKSB7XG4gICAgICAgICAgY29uc3QgZGV0YWlsID0gZnJvbVBhdGhSZWdleC5leGVjKHBhdGgpIHx8IFtudWxsLCBwYXRoLCBwYXRoXTtcbiAgICAgICAgICB0aGlzLmZyb20gPSBkZXRhaWxbMl0gfHwgXCJcIjtcbiAgICAgICAgICB0aGlzLnBhdGggPSBkZXRhaWxbMV0gfHwgXCJcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Jlc3BvbnNlcy9TdGF0dXNTdW1tYXJ5LnRzXG5mdW5jdGlvbiByZW5hbWVkRmlsZShsaW5lKSB7XG4gIGNvbnN0IFt0bywgZnJvbV0gPSBsaW5lLnNwbGl0KE5VTEwpO1xuICByZXR1cm4ge1xuICAgIGZyb206IGZyb20gfHwgdG8sXG4gICAgdG9cbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlcjMoaW5kZXhYLCBpbmRleFksIGhhbmRsZXIpIHtcbiAgcmV0dXJuIFtgJHtpbmRleFh9JHtpbmRleFl9YCwgaGFuZGxlcl07XG59XG5mdW5jdGlvbiBjb25mbGljdHMoaW5kZXhYLCAuLi5pbmRleFkpIHtcbiAgcmV0dXJuIGluZGV4WS5tYXAoKHkpID0+IHBhcnNlcjMoaW5kZXhYLCB5LCAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0LmNvbmZsaWN0ZWQsIGZpbGUpKSk7XG59XG5mdW5jdGlvbiBzcGxpdExpbmUocmVzdWx0LCBsaW5lU3RyKSB7XG4gIGNvbnN0IHRyaW1tZWQyID0gbGluZVN0ci50cmltKCk7XG4gIHN3aXRjaCAoXCIgXCIpIHtcbiAgICBjYXNlIHRyaW1tZWQyLmNoYXJBdCgyKTpcbiAgICAgIHJldHVybiBkYXRhKHRyaW1tZWQyLmNoYXJBdCgwKSwgdHJpbW1lZDIuY2hhckF0KDEpLCB0cmltbWVkMi5zdWJzdHIoMykpO1xuICAgIGNhc2UgdHJpbW1lZDIuY2hhckF0KDEpOlxuICAgICAgcmV0dXJuIGRhdGEoXCIgXCIgLyogTk9ORSAqLywgdHJpbW1lZDIuY2hhckF0KDApLCB0cmltbWVkMi5zdWJzdHIoMikpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm47XG4gIH1cbiAgZnVuY3Rpb24gZGF0YShpbmRleCwgd29ya2luZ0RpciwgcGF0aCkge1xuICAgIGNvbnN0IHJhdyA9IGAke2luZGV4fSR7d29ya2luZ0Rpcn1gO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBwYXJzZXJzNi5nZXQocmF3KTtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgaGFuZGxlcihyZXN1bHQsIHBhdGgpO1xuICAgIH1cbiAgICBpZiAocmF3ICE9PSBcIiMjXCIgJiYgcmF3ICE9PSBcIiEhXCIpIHtcbiAgICAgIHJlc3VsdC5maWxlcy5wdXNoKG5ldyBGaWxlU3RhdHVzU3VtbWFyeShwYXRoLCBpbmRleCwgd29ya2luZ0RpcikpO1xuICAgIH1cbiAgfVxufVxudmFyIFN0YXR1c1N1bW1hcnksIHBhcnNlcnM2LCBwYXJzZVN0YXR1c1N1bW1hcnk7XG52YXIgaW5pdF9TdGF0dXNTdW1tYXJ5ID0gX19lc20oe1xuICBcInNyYy9saWIvcmVzcG9uc2VzL1N0YXR1c1N1bW1hcnkudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgaW5pdF9GaWxlU3RhdHVzU3VtbWFyeSgpO1xuICAgIFN0YXR1c1N1bW1hcnkgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ub3RfYWRkZWQgPSBbXTtcbiAgICAgICAgdGhpcy5jb25mbGljdGVkID0gW107XG4gICAgICAgIHRoaXMuY3JlYXRlZCA9IFtdO1xuICAgICAgICB0aGlzLmRlbGV0ZWQgPSBbXTtcbiAgICAgICAgdGhpcy5pZ25vcmVkID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm1vZGlmaWVkID0gW107XG4gICAgICAgIHRoaXMucmVuYW1lZCA9IFtdO1xuICAgICAgICB0aGlzLmZpbGVzID0gW107XG4gICAgICAgIHRoaXMuc3RhZ2VkID0gW107XG4gICAgICAgIHRoaXMuYWhlYWQgPSAwO1xuICAgICAgICB0aGlzLmJlaGluZCA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMudHJhY2tpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLmRldGFjaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNDbGVhbiA9ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gIXRoaXMuZmlsZXMubGVuZ3RoO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgcGFyc2VyczYgPSBuZXcgTWFwKFtcbiAgICAgIHBhcnNlcjMoXG4gICAgICAgIFwiIFwiIC8qIE5PTkUgKi8sXG4gICAgICAgIFwiQVwiIC8qIEFEREVEICovLFxuICAgICAgICAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0LmNyZWF0ZWQsIGZpbGUpXG4gICAgICApLFxuICAgICAgcGFyc2VyMyhcbiAgICAgICAgXCIgXCIgLyogTk9ORSAqLyxcbiAgICAgICAgXCJEXCIgLyogREVMRVRFRCAqLyxcbiAgICAgICAgKHJlc3VsdCwgZmlsZSkgPT4gYXBwZW5kKHJlc3VsdC5kZWxldGVkLCBmaWxlKVxuICAgICAgKSxcbiAgICAgIHBhcnNlcjMoXG4gICAgICAgIFwiIFwiIC8qIE5PTkUgKi8sXG4gICAgICAgIFwiTVwiIC8qIE1PRElGSUVEICovLFxuICAgICAgICAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0Lm1vZGlmaWVkLCBmaWxlKVxuICAgICAgKSxcbiAgICAgIHBhcnNlcjMoXG4gICAgICAgIFwiQVwiIC8qIEFEREVEICovLFxuICAgICAgICBcIiBcIiAvKiBOT05FICovLFxuICAgICAgICAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0LmNyZWF0ZWQsIGZpbGUpICYmIGFwcGVuZChyZXN1bHQuc3RhZ2VkLCBmaWxlKVxuICAgICAgKSxcbiAgICAgIHBhcnNlcjMoXG4gICAgICAgIFwiQVwiIC8qIEFEREVEICovLFxuICAgICAgICBcIk1cIiAvKiBNT0RJRklFRCAqLyxcbiAgICAgICAgKHJlc3VsdCwgZmlsZSkgPT4gYXBwZW5kKHJlc3VsdC5jcmVhdGVkLCBmaWxlKSAmJiBhcHBlbmQocmVzdWx0LnN0YWdlZCwgZmlsZSkgJiYgYXBwZW5kKHJlc3VsdC5tb2RpZmllZCwgZmlsZSlcbiAgICAgICksXG4gICAgICBwYXJzZXIzKFxuICAgICAgICBcIkRcIiAvKiBERUxFVEVEICovLFxuICAgICAgICBcIiBcIiAvKiBOT05FICovLFxuICAgICAgICAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0LmRlbGV0ZWQsIGZpbGUpICYmIGFwcGVuZChyZXN1bHQuc3RhZ2VkLCBmaWxlKVxuICAgICAgKSxcbiAgICAgIHBhcnNlcjMoXG4gICAgICAgIFwiTVwiIC8qIE1PRElGSUVEICovLFxuICAgICAgICBcIiBcIiAvKiBOT05FICovLFxuICAgICAgICAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0Lm1vZGlmaWVkLCBmaWxlKSAmJiBhcHBlbmQocmVzdWx0LnN0YWdlZCwgZmlsZSlcbiAgICAgICksXG4gICAgICBwYXJzZXIzKFxuICAgICAgICBcIk1cIiAvKiBNT0RJRklFRCAqLyxcbiAgICAgICAgXCJNXCIgLyogTU9ESUZJRUQgKi8sXG4gICAgICAgIChyZXN1bHQsIGZpbGUpID0+IGFwcGVuZChyZXN1bHQubW9kaWZpZWQsIGZpbGUpICYmIGFwcGVuZChyZXN1bHQuc3RhZ2VkLCBmaWxlKVxuICAgICAgKSxcbiAgICAgIHBhcnNlcjMoXCJSXCIgLyogUkVOQU1FRCAqLywgXCIgXCIgLyogTk9ORSAqLywgKHJlc3VsdCwgZmlsZSkgPT4ge1xuICAgICAgICBhcHBlbmQocmVzdWx0LnJlbmFtZWQsIHJlbmFtZWRGaWxlKGZpbGUpKTtcbiAgICAgIH0pLFxuICAgICAgcGFyc2VyMyhcIlJcIiAvKiBSRU5BTUVEICovLCBcIk1cIiAvKiBNT0RJRklFRCAqLywgKHJlc3VsdCwgZmlsZSkgPT4ge1xuICAgICAgICBjb25zdCByZW5hbWVkID0gcmVuYW1lZEZpbGUoZmlsZSk7XG4gICAgICAgIGFwcGVuZChyZXN1bHQucmVuYW1lZCwgcmVuYW1lZCk7XG4gICAgICAgIGFwcGVuZChyZXN1bHQubW9kaWZpZWQsIHJlbmFtZWQudG8pO1xuICAgICAgfSksXG4gICAgICBwYXJzZXIzKFwiIVwiIC8qIElHTk9SRUQgKi8sIFwiIVwiIC8qIElHTk9SRUQgKi8sIChfcmVzdWx0LCBfZmlsZSkgPT4ge1xuICAgICAgICBhcHBlbmQoX3Jlc3VsdC5pZ25vcmVkID0gX3Jlc3VsdC5pZ25vcmVkIHx8IFtdLCBfZmlsZSk7XG4gICAgICB9KSxcbiAgICAgIHBhcnNlcjMoXG4gICAgICAgIFwiP1wiIC8qIFVOVFJBQ0tFRCAqLyxcbiAgICAgICAgXCI/XCIgLyogVU5UUkFDS0VEICovLFxuICAgICAgICAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0Lm5vdF9hZGRlZCwgZmlsZSlcbiAgICAgICksXG4gICAgICAuLi5jb25mbGljdHMoXCJBXCIgLyogQURERUQgKi8sIFwiQVwiIC8qIEFEREVEICovLCBcIlVcIiAvKiBVTk1FUkdFRCAqLyksXG4gICAgICAuLi5jb25mbGljdHMoXG4gICAgICAgIFwiRFwiIC8qIERFTEVURUQgKi8sXG4gICAgICAgIFwiRFwiIC8qIERFTEVURUQgKi8sXG4gICAgICAgIFwiVVwiIC8qIFVOTUVSR0VEICovXG4gICAgICApLFxuICAgICAgLi4uY29uZmxpY3RzKFxuICAgICAgICBcIlVcIiAvKiBVTk1FUkdFRCAqLyxcbiAgICAgICAgXCJBXCIgLyogQURERUQgKi8sXG4gICAgICAgIFwiRFwiIC8qIERFTEVURUQgKi8sXG4gICAgICAgIFwiVVwiIC8qIFVOTUVSR0VEICovXG4gICAgICApLFxuICAgICAgW1xuICAgICAgICBcIiMjXCIsXG4gICAgICAgIChyZXN1bHQsIGxpbmUpID0+IHtcbiAgICAgICAgICBjb25zdCBhaGVhZFJlZyA9IC9haGVhZCAoXFxkKykvO1xuICAgICAgICAgIGNvbnN0IGJlaGluZFJlZyA9IC9iZWhpbmQgKFxcZCspLztcbiAgICAgICAgICBjb25zdCBjdXJyZW50UmVnID0gL14oLis/KD89KD86XFwuezN9fFxcc3wkKSkpLztcbiAgICAgICAgICBjb25zdCB0cmFja2luZ1JlZyA9IC9cXC57M30oXFxTKikvO1xuICAgICAgICAgIGNvbnN0IG9uRW1wdHlCcmFuY2hSZWcgPSAvXFxzb25cXHMoW1xcU10rKSQvO1xuICAgICAgICAgIGxldCByZWdleFJlc3VsdDtcbiAgICAgICAgICByZWdleFJlc3VsdCA9IGFoZWFkUmVnLmV4ZWMobGluZSk7XG4gICAgICAgICAgcmVzdWx0LmFoZWFkID0gcmVnZXhSZXN1bHQgJiYgK3JlZ2V4UmVzdWx0WzFdIHx8IDA7XG4gICAgICAgICAgcmVnZXhSZXN1bHQgPSBiZWhpbmRSZWcuZXhlYyhsaW5lKTtcbiAgICAgICAgICByZXN1bHQuYmVoaW5kID0gcmVnZXhSZXN1bHQgJiYgK3JlZ2V4UmVzdWx0WzFdIHx8IDA7XG4gICAgICAgICAgcmVnZXhSZXN1bHQgPSBjdXJyZW50UmVnLmV4ZWMobGluZSk7XG4gICAgICAgICAgcmVzdWx0LmN1cnJlbnQgPSByZWdleFJlc3VsdCAmJiByZWdleFJlc3VsdFsxXTtcbiAgICAgICAgICByZWdleFJlc3VsdCA9IHRyYWNraW5nUmVnLmV4ZWMobGluZSk7XG4gICAgICAgICAgcmVzdWx0LnRyYWNraW5nID0gcmVnZXhSZXN1bHQgJiYgcmVnZXhSZXN1bHRbMV07XG4gICAgICAgICAgcmVnZXhSZXN1bHQgPSBvbkVtcHR5QnJhbmNoUmVnLmV4ZWMobGluZSk7XG4gICAgICAgICAgcmVzdWx0LmN1cnJlbnQgPSByZWdleFJlc3VsdCAmJiByZWdleFJlc3VsdFsxXSB8fCByZXN1bHQuY3VycmVudDtcbiAgICAgICAgICByZXN1bHQuZGV0YWNoZWQgPSAvXFwobm8gYnJhbmNoXFwpLy50ZXN0KGxpbmUpO1xuICAgICAgICB9XG4gICAgICBdXG4gICAgXSk7XG4gICAgcGFyc2VTdGF0dXNTdW1tYXJ5ID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KE5VTEwpO1xuICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFN0YXR1c1N1bW1hcnkoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgKSB7XG4gICAgICAgIGxldCBsaW5lID0gbGluZXNbaSsrXS50cmltKCk7XG4gICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lLmNoYXJBdCgwKSA9PT0gXCJSXCIgLyogUkVOQU1FRCAqLykge1xuICAgICAgICAgIGxpbmUgKz0gTlVMTCArIChsaW5lc1tpKytdIHx8IFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHNwbGl0TGluZShzdGF0dXMsIGxpbmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9zdGF0dXMudHNcbmZ1bmN0aW9uIHN0YXR1c1Rhc2soY3VzdG9tQXJncykge1xuICBjb25zdCBjb21tYW5kcyA9IFtcbiAgICBcInN0YXR1c1wiLFxuICAgIFwiLS1wb3JjZWxhaW5cIixcbiAgICBcIi1iXCIsXG4gICAgXCItdVwiLFxuICAgIFwiLS1udWxsXCIsXG4gICAgLi4uY3VzdG9tQXJncy5maWx0ZXIoKGFyZykgPT4gIWlnbm9yZWRPcHRpb25zLmluY2x1ZGVzKGFyZykpXG4gIF07XG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgY29tbWFuZHMsXG4gICAgcGFyc2VyKHRleHQpIHtcbiAgICAgIHJldHVybiBwYXJzZVN0YXR1c1N1bW1hcnkodGV4dCk7XG4gICAgfVxuICB9O1xufVxudmFyIGlnbm9yZWRPcHRpb25zO1xudmFyIGluaXRfc3RhdHVzID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3Mvc3RhdHVzLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9TdGF0dXNTdW1tYXJ5KCk7XG4gICAgaWdub3JlZE9wdGlvbnMgPSBbXCItLW51bGxcIiwgXCItelwiXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvdmVyc2lvbi50c1xuZnVuY3Rpb24gdmVyc2lvblJlc3BvbnNlKG1ham9yID0gMCwgbWlub3IgPSAwLCBwYXRjaCA9IDAsIGFnZW50ID0gXCJcIiwgaW5zdGFsbGVkID0gdHJ1ZSkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgIHtcbiAgICAgIG1ham9yLFxuICAgICAgbWlub3IsXG4gICAgICBwYXRjaCxcbiAgICAgIGFnZW50LFxuICAgICAgaW5zdGFsbGVkXG4gICAgfSxcbiAgICBcInRvU3RyaW5nXCIsXG4gICAge1xuICAgICAgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLm1ham9yfS4ke3RoaXMubWlub3J9LiR7dGhpcy5wYXRjaH1gO1xuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIG5vdEluc3RhbGxlZFJlc3BvbnNlKCkge1xuICByZXR1cm4gdmVyc2lvblJlc3BvbnNlKDAsIDAsIDAsIFwiXCIsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHZlcnNpb25fZGVmYXVsdCgpIHtcbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soe1xuICAgICAgICBjb21tYW5kczogW1wiLS12ZXJzaW9uXCJdLFxuICAgICAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICAgICAgcGFyc2VyOiB2ZXJzaW9uUGFyc2VyLFxuICAgICAgICBvbkVycm9yKHJlc3VsdCwgZXJyb3IsIGRvbmUsIGZhaWwpIHtcbiAgICAgICAgICBpZiAocmVzdWx0LmV4aXRDb2RlID09PSAtMiAvKiBOT1RfRk9VTkQgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKEJ1ZmZlci5mcm9tKE5PVF9JTlNUQUxMRUQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmFpbChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHZlcnNpb25QYXJzZXIoc3RkT3V0KSB7XG4gIGlmIChzdGRPdXQgPT09IE5PVF9JTlNUQUxMRUQpIHtcbiAgICByZXR1cm4gbm90SW5zdGFsbGVkUmVzcG9uc2UoKTtcbiAgfVxuICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZSh2ZXJzaW9uUmVzcG9uc2UoMCwgMCwgMCwgc3RkT3V0KSwgcGFyc2VyczcsIHN0ZE91dCk7XG59XG52YXIgTk9UX0lOU1RBTExFRCwgcGFyc2Vyczc7XG52YXIgaW5pdF92ZXJzaW9uID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvdmVyc2lvbi50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBOT1RfSU5TVEFMTEVEID0gXCJpbnN0YWxsZWQ9ZmFsc2VcIjtcbiAgICBwYXJzZXJzNyA9IFtcbiAgICAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgICAvdmVyc2lvbiAoXFxkKylcXC4oXFxkKylcXC4oXFxkKykoPzpcXHMqXFwoKC4rKVxcKSk/LyxcbiAgICAgICAgKHJlc3VsdCwgW21ham9yLCBtaW5vciwgcGF0Y2gsIGFnZW50ID0gXCJcIl0pID0+IHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgdmVyc2lvblJlc3BvbnNlKGFzTnVtYmVyKG1ham9yKSwgYXNOdW1iZXIobWlub3IpLCBhc051bWJlcihwYXRjaCksIGFnZW50KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgTGluZVBhcnNlcihcbiAgICAgICAgL3ZlcnNpb24gKFxcZCspXFwuKFxcZCspXFwuKFxcRCspKC4rKT8kLyxcbiAgICAgICAgKHJlc3VsdCwgW21ham9yLCBtaW5vciwgcGF0Y2gsIGFnZW50ID0gXCJcIl0pID0+IHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgdmVyc2lvblJlc3BvbnNlKGFzTnVtYmVyKG1ham9yKSwgYXNOdW1iZXIobWlub3IpLCBwYXRjaCwgYWdlbnQpKTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgIF07XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3NpbXBsZS1naXQtYXBpLnRzXG52YXIgc2ltcGxlX2dpdF9hcGlfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc2ltcGxlX2dpdF9hcGlfZXhwb3J0cywge1xuICBTaW1wbGVHaXRBcGk6ICgpID0+IFNpbXBsZUdpdEFwaVxufSk7XG52YXIgU2ltcGxlR2l0QXBpO1xudmFyIGluaXRfc2ltcGxlX2dpdF9hcGkgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9zaW1wbGUtZ2l0LWFwaS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdGFza19jYWxsYmFjaygpO1xuICAgIGluaXRfY2hhbmdlX3dvcmtpbmdfZGlyZWN0b3J5KCk7XG4gICAgaW5pdF9jaGVja291dCgpO1xuICAgIGluaXRfY291bnRfb2JqZWN0cygpO1xuICAgIGluaXRfY29tbWl0KCk7XG4gICAgaW5pdF9jb25maWcoKTtcbiAgICBpbml0X2ZpcnN0X2NvbW1pdCgpO1xuICAgIGluaXRfZ3JlcCgpO1xuICAgIGluaXRfaGFzaF9vYmplY3QoKTtcbiAgICBpbml0X2luaXQoKTtcbiAgICBpbml0X2xvZygpO1xuICAgIGluaXRfbWVyZ2UoKTtcbiAgICBpbml0X3B1c2goKTtcbiAgICBpbml0X3Nob3coKTtcbiAgICBpbml0X3N0YXR1cygpO1xuICAgIGluaXRfdGFzaygpO1xuICAgIGluaXRfdmVyc2lvbigpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBTaW1wbGVHaXRBcGkgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcihfZXhlY3V0b3IpIHtcbiAgICAgICAgdGhpcy5fZXhlY3V0b3IgPSBfZXhlY3V0b3I7XG4gICAgICB9XG4gICAgICBfcnVuVGFzayh0YXNrLCB0aGVuKSB7XG4gICAgICAgIGNvbnN0IGNoYWluID0gdGhpcy5fZXhlY3V0b3IuY2hhaW4oKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IGNoYWluLnB1c2godGFzayk7XG4gICAgICAgIGlmICh0aGVuKSB7XG4gICAgICAgICAgdGFza0NhbGxiYWNrKHRhc2ssIHByb21pc2UsIHRoZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKHRoaXMsIHtcbiAgICAgICAgICB0aGVuOiB7IHZhbHVlOiBwcm9taXNlLnRoZW4uYmluZChwcm9taXNlKSB9LFxuICAgICAgICAgIGNhdGNoOiB7IHZhbHVlOiBwcm9taXNlLmNhdGNoLmJpbmQocHJvbWlzZSkgfSxcbiAgICAgICAgICBfZXhlY3V0b3I6IHsgdmFsdWU6IGNoYWluIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBhZGQoZmlsZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbXCJhZGRcIiwgLi4uYXNBcnJheShmaWxlcyldKSxcbiAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY3dkKGRpcmVjdG9yeSkge1xuICAgICAgICBjb25zdCBuZXh0ID0gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh0eXBlb2YgZGlyZWN0b3J5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soY2hhbmdlV29ya2luZ0RpcmVjdG9yeVRhc2soZGlyZWN0b3J5LCB0aGlzLl9leGVjdXRvciksIG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKGRpcmVjdG9yeSA9PSBudWxsID8gdm9pZCAwIDogZGlyZWN0b3J5LnBhdGgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBjaGFuZ2VXb3JraW5nRGlyZWN0b3J5VGFzayhcbiAgICAgICAgICAgICAgZGlyZWN0b3J5LnBhdGgsXG4gICAgICAgICAgICAgIGRpcmVjdG9yeS5yb290ICYmIHRoaXMuX2V4ZWN1dG9yIHx8IHZvaWQgMFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG5leHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soXCJHaXQuY3dkOiB3b3JraW5nRGlyZWN0b3J5IG11c3QgYmUgc3VwcGxpZWQgYXMgYSBzdHJpbmdcIiksXG4gICAgICAgICAgbmV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaGFzaE9iamVjdChwYXRoLCB3cml0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICBoYXNoT2JqZWN0VGFzayhwYXRoLCB3cml0ZSA9PT0gdHJ1ZSksXG4gICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGluaXQoYmFyZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICBpbml0VGFzayhiYXJlID09PSB0cnVlLCB0aGlzLl9leGVjdXRvci5jd2QsIGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpKSxcbiAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgbWVyZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgIG1lcmdlVGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSksXG4gICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG1lcmdlRnJvbVRvKHJlbW90ZSwgYnJhbmNoKSB7XG4gICAgICAgIGlmICghKGZpbHRlclN0cmluZyhyZW1vdGUpICYmIGZpbHRlclN0cmluZyhicmFuY2gpKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgICAgY29uZmlndXJhdGlvbkVycm9yVGFzayhcbiAgICAgICAgICAgICAgYEdpdC5tZXJnZUZyb21UbyByZXF1aXJlcyB0aGF0IHRoZSAncmVtb3RlJyBhbmQgJ2JyYW5jaCcgYXJndW1lbnRzIGFyZSBzdXBwbGllZCBhcyBzdHJpbmdzYFxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgbWVyZ2VUYXNrKFtyZW1vdGUsIGJyYW5jaCwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cyldKSxcbiAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzLCBmYWxzZSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG91dHB1dEhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9leGVjdXRvci5vdXRwdXRIYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBwdXNoKCkge1xuICAgICAgICBjb25zdCB0YXNrID0gcHVzaFRhc2soXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVtb3RlOiBmaWx0ZXJUeXBlKGFyZ3VtZW50c1swXSwgZmlsdGVyU3RyaW5nKSxcbiAgICAgICAgICAgIGJyYW5jaDogZmlsdGVyVHlwZShhcmd1bWVudHNbMV0sIGZpbHRlclN0cmluZylcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHRhc2ssIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpKTtcbiAgICAgIH1cbiAgICAgIHN0YXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFtcInN0YXNoXCIsIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXSksXG4gICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgc3RhdHVzVGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSksXG4gICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICBTaW1wbGVHaXRBcGkucHJvdG90eXBlLFxuICAgICAgY2hlY2tvdXRfZGVmYXVsdCgpLFxuICAgICAgY29tbWl0X2RlZmF1bHQoKSxcbiAgICAgIGNvbmZpZ19kZWZhdWx0KCksXG4gICAgICBjb3VudF9vYmplY3RzX2RlZmF1bHQoKSxcbiAgICAgIGZpcnN0X2NvbW1pdF9kZWZhdWx0KCksXG4gICAgICBncmVwX2RlZmF1bHQoKSxcbiAgICAgIGxvZ19kZWZhdWx0KCksXG4gICAgICBzaG93X2RlZmF1bHQoKSxcbiAgICAgIHZlcnNpb25fZGVmYXVsdCgpXG4gICAgKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcnVubmVycy9zY2hlZHVsZXIudHNcbnZhciBzY2hlZHVsZXJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc2NoZWR1bGVyX2V4cG9ydHMsIHtcbiAgU2NoZWR1bGVyOiAoKSA9PiBTY2hlZHVsZXJcbn0pO1xuaW1wb3J0IHsgY3JlYXRlRGVmZXJyZWQgfSBmcm9tIFwiQGt3c2l0ZXMvcHJvbWlzZS1kZWZlcnJlZFwiO1xudmFyIGNyZWF0ZVNjaGVkdWxlZFRhc2ssIFNjaGVkdWxlcjtcbnZhciBpbml0X3NjaGVkdWxlciA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3J1bm5lcnMvc2NoZWR1bGVyLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlscygpO1xuICAgIGluaXRfZ2l0X2xvZ2dlcigpO1xuICAgIGNyZWF0ZVNjaGVkdWxlZFRhc2sgPSAoKCkgPT4ge1xuICAgICAgbGV0IGlkID0gMDtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlkKys7XG4gICAgICAgIGNvbnN0IHsgcHJvbWlzZSwgZG9uZSB9ID0gY3JlYXRlRGVmZXJyZWQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwcm9taXNlLFxuICAgICAgICAgIGRvbmUsXG4gICAgICAgICAgaWRcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfSkoKTtcbiAgICBTY2hlZHVsZXIgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3Rvcihjb25jdXJyZW5jeSA9IDIpIHtcbiAgICAgICAgdGhpcy5jb25jdXJyZW5jeSA9IGNvbmN1cnJlbmN5O1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGNyZWF0ZUxvZ2dlcihcIlwiLCBcInNjaGVkdWxlclwiKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nID0gW107XG4gICAgICAgIHRoaXMucnVubmluZyA9IFtdO1xuICAgICAgICB0aGlzLmxvZ2dlcihgQ29uc3RydWN0ZWQsIGNvbmN1cnJlbmN5PSVzYCwgY29uY3VycmVuY3kpO1xuICAgICAgfVxuICAgICAgc2NoZWR1bGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5wZW5kaW5nLmxlbmd0aCB8fCB0aGlzLnJ1bm5pbmcubGVuZ3RoID49IHRoaXMuY29uY3VycmVuY3kpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlcihcbiAgICAgICAgICAgIGBTY2hlZHVsZSBhdHRlbXB0IGlnbm9yZWQsIHBlbmRpbmc9JXMgcnVubmluZz0lcyBjb25jdXJyZW5jeT0lc2AsXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmcubGVuZ3RoLFxuICAgICAgICAgICAgdGhpcy5ydW5uaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRoaXMuY29uY3VycmVuY3lcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXNrID0gYXBwZW5kKHRoaXMucnVubmluZywgdGhpcy5wZW5kaW5nLnNoaWZ0KCkpO1xuICAgICAgICB0aGlzLmxvZ2dlcihgQXR0ZW1wdGluZyBpZD0lc2AsIHRhc2suaWQpO1xuICAgICAgICB0YXNrLmRvbmUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMubG9nZ2VyKGBDb21wbGV0aW5nIGlkPWAsIHRhc2suaWQpO1xuICAgICAgICAgIHJlbW92ZSh0aGlzLnJ1bm5pbmcsIHRhc2spO1xuICAgICAgICAgIHRoaXMuc2NoZWR1bGUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBuZXh0KCkge1xuICAgICAgICBjb25zdCB7IHByb21pc2UsIGlkIH0gPSBhcHBlbmQodGhpcy5wZW5kaW5nLCBjcmVhdGVTY2hlZHVsZWRUYXNrKCkpO1xuICAgICAgICB0aGlzLmxvZ2dlcihgU2NoZWR1bGluZyBpZD0lc2AsIGlkKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZSgpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9hcHBseS1wYXRjaC50c1xudmFyIGFwcGx5X3BhdGNoX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGFwcGx5X3BhdGNoX2V4cG9ydHMsIHtcbiAgYXBwbHlQYXRjaFRhc2s6ICgpID0+IGFwcGx5UGF0Y2hUYXNrXG59KTtcbmZ1bmN0aW9uIGFwcGx5UGF0Y2hUYXNrKHBhdGNoZXMsIGN1c3RvbUFyZ3MpIHtcbiAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soW1wiYXBwbHlcIiwgLi4uY3VzdG9tQXJncywgLi4ucGF0Y2hlc10pO1xufVxudmFyIGluaXRfYXBwbHlfcGF0Y2ggPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9hcHBseS1wYXRjaC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdGFzaygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9yZXNwb25zZXMvQnJhbmNoRGVsZXRlU3VtbWFyeS50c1xuZnVuY3Rpb24gYnJhbmNoRGVsZXRpb25TdWNjZXNzKGJyYW5jaCwgaGFzaCkge1xuICByZXR1cm4ge1xuICAgIGJyYW5jaCxcbiAgICBoYXNoLFxuICAgIHN1Y2Nlc3M6IHRydWVcbiAgfTtcbn1cbmZ1bmN0aW9uIGJyYW5jaERlbGV0aW9uRmFpbHVyZShicmFuY2gpIHtcbiAgcmV0dXJuIHtcbiAgICBicmFuY2gsXG4gICAgaGFzaDogbnVsbCxcbiAgICBzdWNjZXNzOiBmYWxzZVxuICB9O1xufVxudmFyIEJyYW5jaERlbGV0aW9uQmF0Y2g7XG52YXIgaW5pdF9CcmFuY2hEZWxldGVTdW1tYXJ5ID0gX19lc20oe1xuICBcInNyYy9saWIvcmVzcG9uc2VzL0JyYW5jaERlbGV0ZVN1bW1hcnkudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBCcmFuY2hEZWxldGlvbkJhdGNoID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYWxsID0gW107XG4gICAgICAgIHRoaXMuYnJhbmNoZXMgPSB7fTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGdldCBzdWNjZXNzKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZXJyb3JzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9wYXJzZXJzL3BhcnNlLWJyYW5jaC1kZWxldGUudHNcbmZ1bmN0aW9uIGhhc0JyYW5jaERlbGV0aW9uRXJyb3IoZGF0YSwgcHJvY2Vzc0V4aXRDb2RlKSB7XG4gIHJldHVybiBwcm9jZXNzRXhpdENvZGUgPT09IDEgLyogRVJST1IgKi8gJiYgZGVsZXRlRXJyb3JSZWdleC50ZXN0KGRhdGEpO1xufVxudmFyIGRlbGV0ZVN1Y2Nlc3NSZWdleCwgZGVsZXRlRXJyb3JSZWdleCwgcGFyc2VyczgsIHBhcnNlQnJhbmNoRGVsZXRpb25zO1xudmFyIGluaXRfcGFyc2VfYnJhbmNoX2RlbGV0ZSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3BhcnNlcnMvcGFyc2UtYnJhbmNoLWRlbGV0ZS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfQnJhbmNoRGVsZXRlU3VtbWFyeSgpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgICBkZWxldGVTdWNjZXNzUmVnZXggPSAvKFxcUyspXFxzK1xcKFxcUytcXHMoW14pXSspXFwpLztcbiAgICBkZWxldGVFcnJvclJlZ2V4ID0gL15lcnJvclteJ10rJyhbXiddKyknL207XG4gICAgcGFyc2VyczggPSBbXG4gICAgICBuZXcgTGluZVBhcnNlcihkZWxldGVTdWNjZXNzUmVnZXgsIChyZXN1bHQsIFticmFuY2gsIGhhc2hdKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlbGV0aW9uID0gYnJhbmNoRGVsZXRpb25TdWNjZXNzKGJyYW5jaCwgaGFzaCk7XG4gICAgICAgIHJlc3VsdC5hbGwucHVzaChkZWxldGlvbik7XG4gICAgICAgIHJlc3VsdC5icmFuY2hlc1ticmFuY2hdID0gZGVsZXRpb247XG4gICAgICB9KSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKGRlbGV0ZUVycm9yUmVnZXgsIChyZXN1bHQsIFticmFuY2hdKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlbGV0aW9uID0gYnJhbmNoRGVsZXRpb25GYWlsdXJlKGJyYW5jaCk7XG4gICAgICAgIHJlc3VsdC5lcnJvcnMucHVzaChkZWxldGlvbik7XG4gICAgICAgIHJlc3VsdC5hbGwucHVzaChkZWxldGlvbik7XG4gICAgICAgIHJlc3VsdC5icmFuY2hlc1ticmFuY2hdID0gZGVsZXRpb247XG4gICAgICB9KVxuICAgIF07XG4gICAgcGFyc2VCcmFuY2hEZWxldGlvbnMgPSAoc3RkT3V0LCBzdGRFcnIpID0+IHtcbiAgICAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKG5ldyBCcmFuY2hEZWxldGlvbkJhdGNoKCksIHBhcnNlcnM4LCBbc3RkT3V0LCBzdGRFcnJdKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9yZXNwb25zZXMvQnJhbmNoU3VtbWFyeS50c1xudmFyIEJyYW5jaFN1bW1hcnlSZXN1bHQ7XG52YXIgaW5pdF9CcmFuY2hTdW1tYXJ5ID0gX19lc20oe1xuICBcInNyYy9saWIvcmVzcG9uc2VzL0JyYW5jaFN1bW1hcnkudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBCcmFuY2hTdW1tYXJ5UmVzdWx0ID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYWxsID0gW107XG4gICAgICAgIHRoaXMuYnJhbmNoZXMgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gXCJcIjtcbiAgICAgICAgdGhpcy5kZXRhY2hlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcHVzaChzdGF0dXMsIGRldGFjaGVkLCBuYW1lLCBjb21taXQsIGxhYmVsKSB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IFwiKlwiIC8qIENVUlJFTlQgKi8pIHtcbiAgICAgICAgICB0aGlzLmRldGFjaGVkID0gZGV0YWNoZWQ7XG4gICAgICAgICAgdGhpcy5jdXJyZW50ID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFsbC5wdXNoKG5hbWUpO1xuICAgICAgICB0aGlzLmJyYW5jaGVzW25hbWVdID0ge1xuICAgICAgICAgIGN1cnJlbnQ6IHN0YXR1cyA9PT0gXCIqXCIgLyogQ1VSUkVOVCAqLyxcbiAgICAgICAgICBsaW5rZWRXb3JrVHJlZTogc3RhdHVzID09PSBcIitcIiAvKiBMSU5LRUQgKi8sXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBjb21taXQsXG4gICAgICAgICAgbGFiZWxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9wYXJzZXJzL3BhcnNlLWJyYW5jaC50c1xuZnVuY3Rpb24gYnJhbmNoU3RhdHVzKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dCA/IGlucHV0LmNoYXJBdCgwKSA6IFwiXCI7XG59XG5mdW5jdGlvbiBwYXJzZUJyYW5jaFN1bW1hcnkoc3RkT3V0KSB7XG4gIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKG5ldyBCcmFuY2hTdW1tYXJ5UmVzdWx0KCksIHBhcnNlcnM5LCBzdGRPdXQpO1xufVxudmFyIHBhcnNlcnM5O1xudmFyIGluaXRfcGFyc2VfYnJhbmNoID0gX19lc20oe1xuICBcInNyYy9saWIvcGFyc2Vycy9wYXJzZS1icmFuY2gudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X0JyYW5jaFN1bW1hcnkoKTtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgcGFyc2VyczkgPSBbXG4gICAgICBuZXcgTGluZVBhcnNlcihcbiAgICAgICAgL14oWyorXVxccyk/XFwoKD86SEVBRCApP2RldGFjaGVkICg/OmZyb218YXQpIChcXFMrKVxcKVxccysoW2EtejAtOV0rKVxccyguKikkLyxcbiAgICAgICAgKHJlc3VsdCwgW2N1cnJlbnQsIG5hbWUsIGNvbW1pdCwgbGFiZWxdKSA9PiB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goYnJhbmNoU3RhdHVzKGN1cnJlbnQpLCB0cnVlLCBuYW1lLCBjb21taXQsIGxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgICBuZXcgUmVnRXhwKFwiXihbKitdXFxcXHMpPyhcXFxcUyspXFxcXHMrKFthLXowLTldKylcXFxccz8oLiopJFwiLCBcInNcIiksXG4gICAgICAgIChyZXN1bHQsIFtjdXJyZW50LCBuYW1lLCBjb21taXQsIGxhYmVsXSkgPT4ge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGJyYW5jaFN0YXR1cyhjdXJyZW50KSwgZmFsc2UsIG5hbWUsIGNvbW1pdCwgbGFiZWwpO1xuICAgICAgICB9XG4gICAgICApXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvYnJhbmNoLnRzXG52YXIgYnJhbmNoX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGJyYW5jaF9leHBvcnRzLCB7XG4gIGJyYW5jaExvY2FsVGFzazogKCkgPT4gYnJhbmNoTG9jYWxUYXNrLFxuICBicmFuY2hUYXNrOiAoKSA9PiBicmFuY2hUYXNrLFxuICBjb250YWluc0RlbGV0ZUJyYW5jaENvbW1hbmQ6ICgpID0+IGNvbnRhaW5zRGVsZXRlQnJhbmNoQ29tbWFuZCxcbiAgZGVsZXRlQnJhbmNoVGFzazogKCkgPT4gZGVsZXRlQnJhbmNoVGFzayxcbiAgZGVsZXRlQnJhbmNoZXNUYXNrOiAoKSA9PiBkZWxldGVCcmFuY2hlc1Rhc2tcbn0pO1xuZnVuY3Rpb24gY29udGFpbnNEZWxldGVCcmFuY2hDb21tYW5kKGNvbW1hbmRzKSB7XG4gIGNvbnN0IGRlbGV0ZUNvbW1hbmRzID0gW1wiLWRcIiwgXCItRFwiLCBcIi0tZGVsZXRlXCJdO1xuICByZXR1cm4gY29tbWFuZHMuc29tZSgoY29tbWFuZCkgPT4gZGVsZXRlQ29tbWFuZHMuaW5jbHVkZXMoY29tbWFuZCkpO1xufVxuZnVuY3Rpb24gYnJhbmNoVGFzayhjdXN0b21BcmdzKSB7XG4gIGNvbnN0IGlzRGVsZXRlID0gY29udGFpbnNEZWxldGVCcmFuY2hDb21tYW5kKGN1c3RvbUFyZ3MpO1xuICBjb25zdCBjb21tYW5kcyA9IFtcImJyYW5jaFwiLCAuLi5jdXN0b21BcmdzXTtcbiAgaWYgKGNvbW1hbmRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbW1hbmRzLnB1c2goXCItYVwiKTtcbiAgfVxuICBpZiAoIWNvbW1hbmRzLmluY2x1ZGVzKFwiLXZcIikpIHtcbiAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgXCItdlwiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIGNvbW1hbmRzLFxuICAgIHBhcnNlcihzdGRPdXQsIHN0ZEVycikge1xuICAgICAgaWYgKGlzRGVsZXRlKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUJyYW5jaERlbGV0aW9ucyhzdGRPdXQsIHN0ZEVycikuYWxsWzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlQnJhbmNoU3VtbWFyeShzdGRPdXQpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGJyYW5jaExvY2FsVGFzaygpIHtcbiAgY29uc3QgcGFyc2VyNCA9IHBhcnNlQnJhbmNoU3VtbWFyeTtcbiAgcmV0dXJuIHtcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBjb21tYW5kczogW1wiYnJhbmNoXCIsIFwiLXZcIl0sXG4gICAgcGFyc2VyOiBwYXJzZXI0XG4gIH07XG59XG5mdW5jdGlvbiBkZWxldGVCcmFuY2hlc1Rhc2soYnJhbmNoZXMsIGZvcmNlRGVsZXRlID0gZmFsc2UpIHtcbiAgcmV0dXJuIHtcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBjb21tYW5kczogW1wiYnJhbmNoXCIsIFwiLXZcIiwgZm9yY2VEZWxldGUgPyBcIi1EXCIgOiBcIi1kXCIsIC4uLmJyYW5jaGVzXSxcbiAgICBwYXJzZXIoc3RkT3V0LCBzdGRFcnIpIHtcbiAgICAgIHJldHVybiBwYXJzZUJyYW5jaERlbGV0aW9ucyhzdGRPdXQsIHN0ZEVycik7XG4gICAgfSxcbiAgICBvbkVycm9yKHsgZXhpdENvZGUsIHN0ZE91dCB9LCBlcnJvciwgZG9uZSwgZmFpbCkge1xuICAgICAgaWYgKCFoYXNCcmFuY2hEZWxldGlvbkVycm9yKFN0cmluZyhlcnJvciksIGV4aXRDb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFpbChlcnJvcik7XG4gICAgICB9XG4gICAgICBkb25lKHN0ZE91dCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZGVsZXRlQnJhbmNoVGFzayhicmFuY2gsIGZvcmNlRGVsZXRlID0gZmFsc2UpIHtcbiAgY29uc3QgdGFzayA9IHtcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBjb21tYW5kczogW1wiYnJhbmNoXCIsIFwiLXZcIiwgZm9yY2VEZWxldGUgPyBcIi1EXCIgOiBcIi1kXCIsIGJyYW5jaF0sXG4gICAgcGFyc2VyKHN0ZE91dCwgc3RkRXJyKSB7XG4gICAgICByZXR1cm4gcGFyc2VCcmFuY2hEZWxldGlvbnMoc3RkT3V0LCBzdGRFcnIpLmJyYW5jaGVzW2JyYW5jaF07XG4gICAgfSxcbiAgICBvbkVycm9yKHsgZXhpdENvZGUsIHN0ZEVyciwgc3RkT3V0IH0sIGVycm9yLCBfLCBmYWlsKSB7XG4gICAgICBpZiAoIWhhc0JyYW5jaERlbGV0aW9uRXJyb3IoU3RyaW5nKGVycm9yKSwgZXhpdENvZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWlsKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBHaXRSZXNwb25zZUVycm9yKFxuICAgICAgICB0YXNrLnBhcnNlcihidWZmZXJUb1N0cmluZyhzdGRPdXQpLCBidWZmZXJUb1N0cmluZyhzdGRFcnIpKSxcbiAgICAgICAgU3RyaW5nKGVycm9yKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB0YXNrO1xufVxudmFyIGluaXRfYnJhbmNoID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3MvYnJhbmNoLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9naXRfcmVzcG9uc2VfZXJyb3IoKTtcbiAgICBpbml0X3BhcnNlX2JyYW5jaF9kZWxldGUoKTtcbiAgICBpbml0X3BhcnNlX2JyYW5jaCgpO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcmVzcG9uc2VzL0NoZWNrSWdub3JlLnRzXG52YXIgcGFyc2VDaGVja0lnbm9yZTtcbnZhciBpbml0X0NoZWNrSWdub3JlID0gX19lc20oe1xuICBcInNyYy9saWIvcmVzcG9uc2VzL0NoZWNrSWdub3JlLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgcGFyc2VDaGVja0lnbm9yZSA9ICh0ZXh0KSA9PiB7XG4gICAgICByZXR1cm4gdGV4dC5zcGxpdCgvXFxuL2cpLm1hcCgobGluZSkgPT4gbGluZS50cmltKCkpLmZpbHRlcigoZmlsZSkgPT4gISFmaWxlKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9jaGVjay1pZ25vcmUudHNcbnZhciBjaGVja19pZ25vcmVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoY2hlY2tfaWdub3JlX2V4cG9ydHMsIHtcbiAgY2hlY2tJZ25vcmVUYXNrOiAoKSA9PiBjaGVja0lnbm9yZVRhc2tcbn0pO1xuZnVuY3Rpb24gY2hlY2tJZ25vcmVUYXNrKHBhdGhzKSB7XG4gIHJldHVybiB7XG4gICAgY29tbWFuZHM6IFtcImNoZWNrLWlnbm9yZVwiLCAuLi5wYXRoc10sXG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgcGFyc2VyOiBwYXJzZUNoZWNrSWdub3JlXG4gIH07XG59XG52YXIgaW5pdF9jaGVja19pZ25vcmUgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9jaGVjay1pZ25vcmUudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X0NoZWNrSWdub3JlKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL2Nsb25lLnRzXG52YXIgY2xvbmVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoY2xvbmVfZXhwb3J0cywge1xuICBjbG9uZU1pcnJvclRhc2s6ICgpID0+IGNsb25lTWlycm9yVGFzayxcbiAgY2xvbmVUYXNrOiAoKSA9PiBjbG9uZVRhc2tcbn0pO1xuZnVuY3Rpb24gZGlzYWxsb3dlZENvbW1hbmQoY29tbWFuZCkge1xuICByZXR1cm4gL14tLXVwbG9hZC1wYWNrKD18JCkvLnRlc3QoY29tbWFuZCk7XG59XG5mdW5jdGlvbiBjbG9uZVRhc2socmVwbywgZGlyZWN0b3J5LCBjdXN0b21BcmdzKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wiY2xvbmVcIiwgLi4uY3VzdG9tQXJnc107XG4gIGZpbHRlclN0cmluZyhyZXBvKSAmJiBjb21tYW5kcy5wdXNoKHJlcG8pO1xuICBmaWx0ZXJTdHJpbmcoZGlyZWN0b3J5KSAmJiBjb21tYW5kcy5wdXNoKGRpcmVjdG9yeSk7XG4gIGNvbnN0IGJhbm5lZCA9IGNvbW1hbmRzLmZpbmQoZGlzYWxsb3dlZENvbW1hbmQpO1xuICBpZiAoYmFubmVkKSB7XG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soYGdpdC5mZXRjaDogcG90ZW50aWFsIGV4cGxvaXQgYXJndW1lbnQgYmxvY2tlZC5gKTtcbiAgfVxuICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcyk7XG59XG5mdW5jdGlvbiBjbG9uZU1pcnJvclRhc2socmVwbywgZGlyZWN0b3J5LCBjdXN0b21BcmdzKSB7XG4gIGFwcGVuZChjdXN0b21BcmdzLCBcIi0tbWlycm9yXCIpO1xuICByZXR1cm4gY2xvbmVUYXNrKHJlcG8sIGRpcmVjdG9yeSwgY3VzdG9tQXJncyk7XG59XG52YXIgaW5pdF9jbG9uZSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL2Nsb25lLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF90YXNrKCk7XG4gICAgaW5pdF91dGlscygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9wYXJzZXJzL3BhcnNlLWZldGNoLnRzXG5mdW5jdGlvbiBwYXJzZUZldGNoUmVzdWx0KHN0ZE91dCwgc3RkRXJyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICByYXc6IHN0ZE91dCxcbiAgICByZW1vdGU6IG51bGwsXG4gICAgYnJhbmNoZXM6IFtdLFxuICAgIHRhZ3M6IFtdLFxuICAgIHVwZGF0ZWQ6IFtdLFxuICAgIGRlbGV0ZWQ6IFtdXG4gIH07XG4gIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKHJlc3VsdCwgcGFyc2VyczEwLCBbc3RkT3V0LCBzdGRFcnJdKTtcbn1cbnZhciBwYXJzZXJzMTA7XG52YXIgaW5pdF9wYXJzZV9mZXRjaCA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3BhcnNlcnMvcGFyc2UtZmV0Y2gudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3V0aWxzKCk7XG4gICAgcGFyc2VyczEwID0gW1xuICAgICAgbmV3IExpbmVQYXJzZXIoL0Zyb20gKC4rKSQvLCAocmVzdWx0LCBbcmVtb3RlXSkgPT4ge1xuICAgICAgICByZXN1bHQucmVtb3RlID0gcmVtb3RlO1xuICAgICAgfSksXG4gICAgICBuZXcgTGluZVBhcnNlcigvXFwqIFxcW25ldyBicmFuY2hdXFxzKyhcXFMrKVxccyotPiAoLispJC8sIChyZXN1bHQsIFtuYW1lLCB0cmFja2luZ10pID0+IHtcbiAgICAgICAgcmVzdWx0LmJyYW5jaGVzLnB1c2goe1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdHJhY2tpbmdcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIG5ldyBMaW5lUGFyc2VyKC9cXCogXFxbbmV3IHRhZ11cXHMrKFxcUyspXFxzKi0+ICguKykkLywgKHJlc3VsdCwgW25hbWUsIHRyYWNraW5nXSkgPT4ge1xuICAgICAgICByZXN1bHQudGFncy5wdXNoKHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHRyYWNraW5nXG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBuZXcgTGluZVBhcnNlcigvLSBcXFtkZWxldGVkXVxccytcXFMrXFxzKi0+ICguKykkLywgKHJlc3VsdCwgW3RyYWNraW5nXSkgPT4ge1xuICAgICAgICByZXN1bHQuZGVsZXRlZC5wdXNoKHtcbiAgICAgICAgICB0cmFja2luZ1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAgIC9cXHMqKFteLl0rKVxcLlxcLihcXFMrKVxccysoXFxTKylcXHMqLT4gKC4rKSQvLFxuICAgICAgICAocmVzdWx0LCBbZnJvbSwgdG8sIG5hbWUsIHRyYWNraW5nXSkgPT4ge1xuICAgICAgICAgIHJlc3VsdC51cGRhdGVkLnB1c2goe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHRyYWNraW5nLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICBmcm9tXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICBdO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9mZXRjaC50c1xudmFyIGZldGNoX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGZldGNoX2V4cG9ydHMsIHtcbiAgZmV0Y2hUYXNrOiAoKSA9PiBmZXRjaFRhc2tcbn0pO1xuZnVuY3Rpb24gZGlzYWxsb3dlZENvbW1hbmQyKGNvbW1hbmQpIHtcbiAgcmV0dXJuIC9eLS11cGxvYWQtcGFjayg9fCQpLy50ZXN0KGNvbW1hbmQpO1xufVxuZnVuY3Rpb24gZmV0Y2hUYXNrKHJlbW90ZSwgYnJhbmNoLCBjdXN0b21BcmdzKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wiZmV0Y2hcIiwgLi4uY3VzdG9tQXJnc107XG4gIGlmIChyZW1vdGUgJiYgYnJhbmNoKSB7XG4gICAgY29tbWFuZHMucHVzaChyZW1vdGUsIGJyYW5jaCk7XG4gIH1cbiAgY29uc3QgYmFubmVkID0gY29tbWFuZHMuZmluZChkaXNhbGxvd2VkQ29tbWFuZDIpO1xuICBpZiAoYmFubmVkKSB7XG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soYGdpdC5mZXRjaDogcG90ZW50aWFsIGV4cGxvaXQgYXJndW1lbnQgYmxvY2tlZC5gKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIHBhcnNlcjogcGFyc2VGZXRjaFJlc3VsdFxuICB9O1xufVxudmFyIGluaXRfZmV0Y2ggPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9mZXRjaC50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfcGFyc2VfZmV0Y2goKTtcbiAgICBpbml0X3Rhc2soKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvcGFyc2Vycy9wYXJzZS1tb3ZlLnRzXG5mdW5jdGlvbiBwYXJzZU1vdmVSZXN1bHQoc3RkT3V0KSB7XG4gIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKHsgbW92ZXM6IFtdIH0sIHBhcnNlcnMxMSwgc3RkT3V0KTtcbn1cbnZhciBwYXJzZXJzMTE7XG52YXIgaW5pdF9wYXJzZV9tb3ZlID0gX19lc20oe1xuICBcInNyYy9saWIvcGFyc2Vycy9wYXJzZS1tb3ZlLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF91dGlscygpO1xuICAgIHBhcnNlcnMxMSA9IFtcbiAgICAgIG5ldyBMaW5lUGFyc2VyKC9eUmVuYW1pbmcgKC4rKSB0byAoLispJC8sIChyZXN1bHQsIFtmcm9tLCB0b10pID0+IHtcbiAgICAgICAgcmVzdWx0Lm1vdmVzLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgIH0pXG4gICAgXTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvbW92ZS50c1xudmFyIG1vdmVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobW92ZV9leHBvcnRzLCB7XG4gIG1vdmVUYXNrOiAoKSA9PiBtb3ZlVGFza1xufSk7XG5mdW5jdGlvbiBtb3ZlVGFzayhmcm9tLCB0bykge1xuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzOiBbXCJtdlwiLCBcIi12XCIsIC4uLmFzQXJyYXkoZnJvbSksIHRvXSxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXI6IHBhcnNlTW92ZVJlc3VsdFxuICB9O1xufVxudmFyIGluaXRfbW92ZSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL21vdmUudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpbml0X3BhcnNlX21vdmUoKTtcbiAgICBpbml0X3V0aWxzKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Rhc2tzL3B1bGwudHNcbnZhciBwdWxsX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHB1bGxfZXhwb3J0cywge1xuICBwdWxsVGFzazogKCkgPT4gcHVsbFRhc2tcbn0pO1xuZnVuY3Rpb24gcHVsbFRhc2socmVtb3RlLCBicmFuY2gsIGN1c3RvbUFyZ3MpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbXCJwdWxsXCIsIC4uLmN1c3RvbUFyZ3NdO1xuICBpZiAocmVtb3RlICYmIGJyYW5jaCkge1xuICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCByZW1vdGUsIGJyYW5jaCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXIoc3RkT3V0LCBzdGRFcnIpIHtcbiAgICAgIHJldHVybiBwYXJzZVB1bGxSZXN1bHQoc3RkT3V0LCBzdGRFcnIpO1xuICAgIH0sXG4gICAgb25FcnJvcihyZXN1bHQsIF9lcnJvciwgX2RvbmUsIGZhaWwpIHtcbiAgICAgIGNvbnN0IHB1bGxFcnJvciA9IHBhcnNlUHVsbEVycm9yUmVzdWx0KFxuICAgICAgICBidWZmZXJUb1N0cmluZyhyZXN1bHQuc3RkT3V0KSxcbiAgICAgICAgYnVmZmVyVG9TdHJpbmcocmVzdWx0LnN0ZEVycilcbiAgICAgICk7XG4gICAgICBpZiAocHVsbEVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWlsKG5ldyBHaXRSZXNwb25zZUVycm9yKHB1bGxFcnJvcikpO1xuICAgICAgfVxuICAgICAgZmFpbChfZXJyb3IpO1xuICAgIH1cbiAgfTtcbn1cbnZhciBpbml0X3B1bGwgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9wdWxsLnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9naXRfcmVzcG9uc2VfZXJyb3IoKTtcbiAgICBpbml0X3BhcnNlX3B1bGwoKTtcbiAgICBpbml0X3V0aWxzKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvbGliL3Jlc3BvbnNlcy9HZXRSZW1vdGVTdW1tYXJ5LnRzXG5mdW5jdGlvbiBwYXJzZUdldFJlbW90ZXModGV4dCkge1xuICBjb25zdCByZW1vdGVzID0ge307XG4gIGZvckVhY2godGV4dCwgKFtuYW1lXSkgPT4gcmVtb3Rlc1tuYW1lXSA9IHsgbmFtZSB9KTtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMocmVtb3Rlcyk7XG59XG5mdW5jdGlvbiBwYXJzZUdldFJlbW90ZXNWZXJib3NlKHRleHQpIHtcbiAgY29uc3QgcmVtb3RlcyA9IHt9O1xuICBmb3JFYWNoKHRleHQsIChbbmFtZSwgdXJsLCBwdXJwb3NlXSkgPT4ge1xuICAgIGlmICghcmVtb3Rlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgcmVtb3Rlc1tuYW1lXSA9IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcmVmczogeyBmZXRjaDogXCJcIiwgcHVzaDogXCJcIiB9XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAocHVycG9zZSAmJiB1cmwpIHtcbiAgICAgIHJlbW90ZXNbbmFtZV0ucmVmc1twdXJwb3NlLnJlcGxhY2UoL1teYS16XS9nLCBcIlwiKV0gPSB1cmw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMocmVtb3Rlcyk7XG59XG5mdW5jdGlvbiBmb3JFYWNoKHRleHQsIGhhbmRsZXIpIHtcbiAgZm9yRWFjaExpbmVXaXRoQ29udGVudCh0ZXh0LCAobGluZSkgPT4gaGFuZGxlcihsaW5lLnNwbGl0KC9cXHMrLykpKTtcbn1cbnZhciBpbml0X0dldFJlbW90ZVN1bW1hcnkgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi9yZXNwb25zZXMvR2V0UmVtb3RlU3VtbWFyeS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdXRpbHMoKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3MvcmVtb3RlLnRzXG52YXIgcmVtb3RlX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHJlbW90ZV9leHBvcnRzLCB7XG4gIGFkZFJlbW90ZVRhc2s6ICgpID0+IGFkZFJlbW90ZVRhc2ssXG4gIGdldFJlbW90ZXNUYXNrOiAoKSA9PiBnZXRSZW1vdGVzVGFzayxcbiAgbGlzdFJlbW90ZXNUYXNrOiAoKSA9PiBsaXN0UmVtb3Rlc1Rhc2ssXG4gIHJlbW90ZVRhc2s6ICgpID0+IHJlbW90ZVRhc2ssXG4gIHJlbW92ZVJlbW90ZVRhc2s6ICgpID0+IHJlbW92ZVJlbW90ZVRhc2tcbn0pO1xuZnVuY3Rpb24gYWRkUmVtb3RlVGFzayhyZW1vdGVOYW1lLCByZW1vdGVSZXBvLCBjdXN0b21BcmdzKSB7XG4gIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFtcInJlbW90ZVwiLCBcImFkZFwiLCAuLi5jdXN0b21BcmdzLCByZW1vdGVOYW1lLCByZW1vdGVSZXBvXSk7XG59XG5mdW5jdGlvbiBnZXRSZW1vdGVzVGFzayh2ZXJib3NlKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gW1wicmVtb3RlXCJdO1xuICBpZiAodmVyYm9zZSkge1xuICAgIGNvbW1hbmRzLnB1c2goXCItdlwiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGNvbW1hbmRzLFxuICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgIHBhcnNlcjogdmVyYm9zZSA/IHBhcnNlR2V0UmVtb3Rlc1ZlcmJvc2UgOiBwYXJzZUdldFJlbW90ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIGxpc3RSZW1vdGVzVGFzayhjdXN0b21BcmdzKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gWy4uLmN1c3RvbUFyZ3NdO1xuICBpZiAoY29tbWFuZHNbMF0gIT09IFwibHMtcmVtb3RlXCIpIHtcbiAgICBjb21tYW5kcy51bnNoaWZ0KFwibHMtcmVtb3RlXCIpO1xuICB9XG4gIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzKTtcbn1cbmZ1bmN0aW9uIHJlbW90ZVRhc2soY3VzdG9tQXJncykge1xuICBjb25zdCBjb21tYW5kcyA9IFsuLi5jdXN0b21BcmdzXTtcbiAgaWYgKGNvbW1hbmRzWzBdICE9PSBcInJlbW90ZVwiKSB7XG4gICAgY29tbWFuZHMudW5zaGlmdChcInJlbW90ZVwiKTtcbiAgfVxuICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcyk7XG59XG5mdW5jdGlvbiByZW1vdmVSZW1vdGVUYXNrKHJlbW90ZU5hbWUpIHtcbiAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soW1wicmVtb3RlXCIsIFwicmVtb3ZlXCIsIHJlbW90ZU5hbWVdKTtcbn1cbnZhciBpbml0X3JlbW90ZSA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL3JlbW90ZS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfR2V0UmVtb3RlU3VtbWFyeSgpO1xuICAgIGluaXRfdGFzaygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy9zdGFzaC1saXN0LnRzXG52YXIgc3Rhc2hfbGlzdF9leHBvcnRzID0ge307XG5fX2V4cG9ydChzdGFzaF9saXN0X2V4cG9ydHMsIHtcbiAgc3Rhc2hMaXN0VGFzazogKCkgPT4gc3Rhc2hMaXN0VGFza1xufSk7XG5mdW5jdGlvbiBzdGFzaExpc3RUYXNrKG9wdCA9IHt9LCBjdXN0b21BcmdzKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBwYXJzZUxvZ09wdGlvbnMob3B0KTtcbiAgY29uc3QgY29tbWFuZHMgPSBbXCJzdGFzaFwiLCBcImxpc3RcIiwgLi4ub3B0aW9ucy5jb21tYW5kcywgLi4uY3VzdG9tQXJnc107XG4gIGNvbnN0IHBhcnNlcjQgPSBjcmVhdGVMaXN0TG9nU3VtbWFyeVBhcnNlcihcbiAgICBvcHRpb25zLnNwbGl0dGVyLFxuICAgIG9wdGlvbnMuZmllbGRzLFxuICAgIGxvZ0Zvcm1hdEZyb21Db21tYW5kKGNvbW1hbmRzKVxuICApO1xuICByZXR1cm4gdmFsaWRhdGVMb2dGb3JtYXRDb25maWcoY29tbWFuZHMpIHx8IHtcbiAgICBjb21tYW5kcyxcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBwYXJzZXI6IHBhcnNlcjRcbiAgfTtcbn1cbnZhciBpbml0X3N0YXNoX2xpc3QgPSBfX2VzbSh7XG4gIFwic3JjL2xpYi90YXNrcy9zdGFzaC1saXN0LnRzXCIoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaW5pdF9sb2dfZm9ybWF0KCk7XG4gICAgaW5pdF9wYXJzZV9saXN0X2xvZ19zdW1tYXJ5KCk7XG4gICAgaW5pdF9kaWZmKCk7XG4gICAgaW5pdF9sb2coKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvdGFza3Mvc3ViLW1vZHVsZS50c1xudmFyIHN1Yl9tb2R1bGVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3ViX21vZHVsZV9leHBvcnRzLCB7XG4gIGFkZFN1Yk1vZHVsZVRhc2s6ICgpID0+IGFkZFN1Yk1vZHVsZVRhc2ssXG4gIGluaXRTdWJNb2R1bGVUYXNrOiAoKSA9PiBpbml0U3ViTW9kdWxlVGFzayxcbiAgc3ViTW9kdWxlVGFzazogKCkgPT4gc3ViTW9kdWxlVGFzayxcbiAgdXBkYXRlU3ViTW9kdWxlVGFzazogKCkgPT4gdXBkYXRlU3ViTW9kdWxlVGFza1xufSk7XG5mdW5jdGlvbiBhZGRTdWJNb2R1bGVUYXNrKHJlcG8sIHBhdGgpIHtcbiAgcmV0dXJuIHN1Yk1vZHVsZVRhc2soW1wiYWRkXCIsIHJlcG8sIHBhdGhdKTtcbn1cbmZ1bmN0aW9uIGluaXRTdWJNb2R1bGVUYXNrKGN1c3RvbUFyZ3MpIHtcbiAgcmV0dXJuIHN1Yk1vZHVsZVRhc2soW1wiaW5pdFwiLCAuLi5jdXN0b21BcmdzXSk7XG59XG5mdW5jdGlvbiBzdWJNb2R1bGVUYXNrKGN1c3RvbUFyZ3MpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbLi4uY3VzdG9tQXJnc107XG4gIGlmIChjb21tYW5kc1swXSAhPT0gXCJzdWJtb2R1bGVcIikge1xuICAgIGNvbW1hbmRzLnVuc2hpZnQoXCJzdWJtb2R1bGVcIik7XG4gIH1cbiAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpO1xufVxuZnVuY3Rpb24gdXBkYXRlU3ViTW9kdWxlVGFzayhjdXN0b21BcmdzKSB7XG4gIHJldHVybiBzdWJNb2R1bGVUYXNrKFtcInVwZGF0ZVwiLCAuLi5jdXN0b21BcmdzXSk7XG59XG52YXIgaW5pdF9zdWJfbW9kdWxlID0gX19lc20oe1xuICBcInNyYy9saWIvdGFza3Mvc3ViLW1vZHVsZS50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfdGFzaygpO1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi9yZXNwb25zZXMvVGFnTGlzdC50c1xuZnVuY3Rpb24gc2luZ2xlU29ydGVkKGEsIGIpIHtcbiAgY29uc3QgYUlzTnVtID0gaXNOYU4oYSk7XG4gIGNvbnN0IGJJc051bSA9IGlzTmFOKGIpO1xuICBpZiAoYUlzTnVtICE9PSBiSXNOdW0pIHtcbiAgICByZXR1cm4gYUlzTnVtID8gMSA6IC0xO1xuICB9XG4gIHJldHVybiBhSXNOdW0gPyBzb3J0ZWQoYSwgYikgOiAwO1xufVxuZnVuY3Rpb24gc29ydGVkKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTE7XG59XG5mdW5jdGlvbiB0cmltbWVkKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dC50cmltKCk7XG59XG5mdW5jdGlvbiB0b051bWJlcihpbnB1dCkge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LnJlcGxhY2UoL15cXEQrL2csIFwiXCIpLCAxMCkgfHwgMDtcbiAgfVxuICByZXR1cm4gMDtcbn1cbnZhciBUYWdMaXN0LCBwYXJzZVRhZ0xpc3Q7XG52YXIgaW5pdF9UYWdMaXN0ID0gX19lc20oe1xuICBcInNyYy9saWIvcmVzcG9uc2VzL1RhZ0xpc3QudHNcIigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBUYWdMaXN0ID0gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoYWxsLCBsYXRlc3QpIHtcbiAgICAgICAgdGhpcy5hbGwgPSBhbGw7XG4gICAgICAgIHRoaXMubGF0ZXN0ID0gbGF0ZXN0O1xuICAgICAgfVxuICAgIH07XG4gICAgcGFyc2VUYWdMaXN0ID0gZnVuY3Rpb24oZGF0YSwgY3VzdG9tU29ydCA9IGZhbHNlKSB7XG4gICAgICBjb25zdCB0YWdzID0gZGF0YS5zcGxpdChcIlxcblwiKS5tYXAodHJpbW1lZCkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgaWYgKCFjdXN0b21Tb3J0KSB7XG4gICAgICAgIHRhZ3Muc29ydChmdW5jdGlvbih0YWdBLCB0YWdCKSB7XG4gICAgICAgICAgY29uc3QgcGFydHNBID0gdGFnQS5zcGxpdChcIi5cIik7XG4gICAgICAgICAgY29uc3QgcGFydHNCID0gdGFnQi5zcGxpdChcIi5cIik7XG4gICAgICAgICAgaWYgKHBhcnRzQS5sZW5ndGggPT09IDEgfHwgcGFydHNCLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpbmdsZVNvcnRlZCh0b051bWJlcihwYXJ0c0FbMF0pLCB0b051bWJlcihwYXJ0c0JbMF0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBNYXRoLm1heChwYXJ0c0EubGVuZ3RoLCBwYXJ0c0IubGVuZ3RoKTsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IHNvcnRlZCh0b051bWJlcihwYXJ0c0FbaV0pLCB0b051bWJlcihwYXJ0c0JbaV0pKTtcbiAgICAgICAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBsYXRlc3QgPSBjdXN0b21Tb3J0ID8gdGFnc1swXSA6IFsuLi50YWdzXS5yZXZlcnNlKCkuZmluZCgodGFnKSA9PiB0YWcuaW5kZXhPZihcIi5cIikgPj0gMCk7XG4gICAgICByZXR1cm4gbmV3IFRhZ0xpc3QodGFncywgbGF0ZXN0KTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gc3JjL2xpYi90YXNrcy90YWcudHNcbnZhciB0YWdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodGFnX2V4cG9ydHMsIHtcbiAgYWRkQW5ub3RhdGVkVGFnVGFzazogKCkgPT4gYWRkQW5ub3RhdGVkVGFnVGFzayxcbiAgYWRkVGFnVGFzazogKCkgPT4gYWRkVGFnVGFzayxcbiAgdGFnTGlzdFRhc2s6ICgpID0+IHRhZ0xpc3RUYXNrXG59KTtcbmZ1bmN0aW9uIHRhZ0xpc3RUYXNrKGN1c3RvbUFyZ3MgPSBbXSkge1xuICBjb25zdCBoYXNDdXN0b21Tb3J0ID0gY3VzdG9tQXJncy5zb21lKChvcHRpb24pID0+IC9eLS1zb3J0PS8udGVzdChvcHRpb24pKTtcbiAgcmV0dXJuIHtcbiAgICBmb3JtYXQ6IFwidXRmLThcIixcbiAgICBjb21tYW5kczogW1widGFnXCIsIFwiLWxcIiwgLi4uY3VzdG9tQXJnc10sXG4gICAgcGFyc2VyKHRleHQpIHtcbiAgICAgIHJldHVybiBwYXJzZVRhZ0xpc3QodGV4dCwgaGFzQ3VzdG9tU29ydCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYWRkVGFnVGFzayhuYW1lKSB7XG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgY29tbWFuZHM6IFtcInRhZ1wiLCBuYW1lXSxcbiAgICBwYXJzZXIoKSB7XG4gICAgICByZXR1cm4geyBuYW1lIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYWRkQW5ub3RhdGVkVGFnVGFzayhuYW1lLCB0YWdNZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBcInV0Zi04XCIsXG4gICAgY29tbWFuZHM6IFtcInRhZ1wiLCBcIi1hXCIsIFwiLW1cIiwgdGFnTWVzc2FnZSwgbmFtZV0sXG4gICAgcGFyc2VyKCkge1xuICAgICAgcmV0dXJuIHsgbmFtZSB9O1xuICAgIH1cbiAgfTtcbn1cbnZhciBpbml0X3RhZyA9IF9fZXNtKHtcbiAgXCJzcmMvbGliL3Rhc2tzL3RhZy50c1wiKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGluaXRfVGFnTGlzdCgpO1xuICB9XG59KTtcblxuLy8gc3JjL2dpdC5qc1xudmFyIHJlcXVpcmVfZ2l0ID0gX19jb21tb25KUyh7XG4gIFwic3JjL2dpdC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB7IEdpdEV4ZWN1dG9yOiBHaXRFeGVjdXRvcjIgfSA9IChpbml0X2dpdF9leGVjdXRvcigpLCBfX3RvQ29tbW9uSlMoZ2l0X2V4ZWN1dG9yX2V4cG9ydHMpKTtcbiAgICB2YXIgeyBTaW1wbGVHaXRBcGk6IFNpbXBsZUdpdEFwaTIgfSA9IChpbml0X3NpbXBsZV9naXRfYXBpKCksIF9fdG9Db21tb25KUyhzaW1wbGVfZ2l0X2FwaV9leHBvcnRzKSk7XG4gICAgdmFyIHsgU2NoZWR1bGVyOiBTY2hlZHVsZXIyIH0gPSAoaW5pdF9zY2hlZHVsZXIoKSwgX190b0NvbW1vbkpTKHNjaGVkdWxlcl9leHBvcnRzKSk7XG4gICAgdmFyIHsgY29uZmlndXJhdGlvbkVycm9yVGFzazogY29uZmlndXJhdGlvbkVycm9yVGFzazIgfSA9IChpbml0X3Rhc2soKSwgX190b0NvbW1vbkpTKHRhc2tfZXhwb3J0cykpO1xuICAgIHZhciB7XG4gICAgICBhc0FycmF5OiBhc0FycmF5MixcbiAgICAgIGZpbHRlckFycmF5OiBmaWx0ZXJBcnJheTIsXG4gICAgICBmaWx0ZXJQcmltaXRpdmVzOiBmaWx0ZXJQcmltaXRpdmVzMixcbiAgICAgIGZpbHRlclN0cmluZzogZmlsdGVyU3RyaW5nMixcbiAgICAgIGZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXk6IGZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXkyLFxuICAgICAgZmlsdGVyVHlwZTogZmlsdGVyVHlwZTIsXG4gICAgICBnZXRUcmFpbGluZ09wdGlvbnM6IGdldFRyYWlsaW5nT3B0aW9uczIsXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQ6IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIsXG4gICAgICB0cmFpbGluZ09wdGlvbnNBcmd1bWVudDogdHJhaWxpbmdPcHRpb25zQXJndW1lbnQyXG4gICAgfSA9IChpbml0X3V0aWxzKCksIF9fdG9Db21tb25KUyh1dGlsc19leHBvcnRzKSk7XG4gICAgdmFyIHsgYXBwbHlQYXRjaFRhc2s6IGFwcGx5UGF0Y2hUYXNrMiB9ID0gKGluaXRfYXBwbHlfcGF0Y2goKSwgX190b0NvbW1vbkpTKGFwcGx5X3BhdGNoX2V4cG9ydHMpKTtcbiAgICB2YXIge1xuICAgICAgYnJhbmNoVGFzazogYnJhbmNoVGFzazIsXG4gICAgICBicmFuY2hMb2NhbFRhc2s6IGJyYW5jaExvY2FsVGFzazIsXG4gICAgICBkZWxldGVCcmFuY2hlc1Rhc2s6IGRlbGV0ZUJyYW5jaGVzVGFzazIsXG4gICAgICBkZWxldGVCcmFuY2hUYXNrOiBkZWxldGVCcmFuY2hUYXNrMlxuICAgIH0gPSAoaW5pdF9icmFuY2goKSwgX190b0NvbW1vbkpTKGJyYW5jaF9leHBvcnRzKSk7XG4gICAgdmFyIHsgY2hlY2tJZ25vcmVUYXNrOiBjaGVja0lnbm9yZVRhc2syIH0gPSAoaW5pdF9jaGVja19pZ25vcmUoKSwgX190b0NvbW1vbkpTKGNoZWNrX2lnbm9yZV9leHBvcnRzKSk7XG4gICAgdmFyIHsgY2hlY2tJc1JlcG9UYXNrOiBjaGVja0lzUmVwb1Rhc2syIH0gPSAoaW5pdF9jaGVja19pc19yZXBvKCksIF9fdG9Db21tb25KUyhjaGVja19pc19yZXBvX2V4cG9ydHMpKTtcbiAgICB2YXIgeyBjbG9uZVRhc2s6IGNsb25lVGFzazIsIGNsb25lTWlycm9yVGFzazogY2xvbmVNaXJyb3JUYXNrMiB9ID0gKGluaXRfY2xvbmUoKSwgX190b0NvbW1vbkpTKGNsb25lX2V4cG9ydHMpKTtcbiAgICB2YXIgeyBjbGVhbldpdGhPcHRpb25zVGFzazogY2xlYW5XaXRoT3B0aW9uc1Rhc2syLCBpc0NsZWFuT3B0aW9uc0FycmF5OiBpc0NsZWFuT3B0aW9uc0FycmF5MiB9ID0gKGluaXRfY2xlYW4oKSwgX190b0NvbW1vbkpTKGNsZWFuX2V4cG9ydHMpKTtcbiAgICB2YXIgeyBkaWZmU3VtbWFyeVRhc2s6IGRpZmZTdW1tYXJ5VGFzazIgfSA9IChpbml0X2RpZmYoKSwgX190b0NvbW1vbkpTKGRpZmZfZXhwb3J0cykpO1xuICAgIHZhciB7IGZldGNoVGFzazogZmV0Y2hUYXNrMiB9ID0gKGluaXRfZmV0Y2goKSwgX190b0NvbW1vbkpTKGZldGNoX2V4cG9ydHMpKTtcbiAgICB2YXIgeyBtb3ZlVGFzazogbW92ZVRhc2syIH0gPSAoaW5pdF9tb3ZlKCksIF9fdG9Db21tb25KUyhtb3ZlX2V4cG9ydHMpKTtcbiAgICB2YXIgeyBwdWxsVGFzazogcHVsbFRhc2syIH0gPSAoaW5pdF9wdWxsKCksIF9fdG9Db21tb25KUyhwdWxsX2V4cG9ydHMpKTtcbiAgICB2YXIgeyBwdXNoVGFnc1Rhc2s6IHB1c2hUYWdzVGFzazIgfSA9IChpbml0X3B1c2goKSwgX190b0NvbW1vbkpTKHB1c2hfZXhwb3J0cykpO1xuICAgIHZhciB7XG4gICAgICBhZGRSZW1vdGVUYXNrOiBhZGRSZW1vdGVUYXNrMixcbiAgICAgIGdldFJlbW90ZXNUYXNrOiBnZXRSZW1vdGVzVGFzazIsXG4gICAgICBsaXN0UmVtb3Rlc1Rhc2s6IGxpc3RSZW1vdGVzVGFzazIsXG4gICAgICByZW1vdGVUYXNrOiByZW1vdGVUYXNrMixcbiAgICAgIHJlbW92ZVJlbW90ZVRhc2s6IHJlbW92ZVJlbW90ZVRhc2syXG4gICAgfSA9IChpbml0X3JlbW90ZSgpLCBfX3RvQ29tbW9uSlMocmVtb3RlX2V4cG9ydHMpKTtcbiAgICB2YXIgeyBnZXRSZXNldE1vZGU6IGdldFJlc2V0TW9kZTIsIHJlc2V0VGFzazogcmVzZXRUYXNrMiB9ID0gKGluaXRfcmVzZXQoKSwgX190b0NvbW1vbkpTKHJlc2V0X2V4cG9ydHMpKTtcbiAgICB2YXIgeyBzdGFzaExpc3RUYXNrOiBzdGFzaExpc3RUYXNrMiB9ID0gKGluaXRfc3Rhc2hfbGlzdCgpLCBfX3RvQ29tbW9uSlMoc3Rhc2hfbGlzdF9leHBvcnRzKSk7XG4gICAgdmFyIHtcbiAgICAgIGFkZFN1Yk1vZHVsZVRhc2s6IGFkZFN1Yk1vZHVsZVRhc2syLFxuICAgICAgaW5pdFN1Yk1vZHVsZVRhc2s6IGluaXRTdWJNb2R1bGVUYXNrMixcbiAgICAgIHN1Yk1vZHVsZVRhc2s6IHN1Yk1vZHVsZVRhc2syLFxuICAgICAgdXBkYXRlU3ViTW9kdWxlVGFzazogdXBkYXRlU3ViTW9kdWxlVGFzazJcbiAgICB9ID0gKGluaXRfc3ViX21vZHVsZSgpLCBfX3RvQ29tbW9uSlMoc3ViX21vZHVsZV9leHBvcnRzKSk7XG4gICAgdmFyIHsgYWRkQW5ub3RhdGVkVGFnVGFzazogYWRkQW5ub3RhdGVkVGFnVGFzazIsIGFkZFRhZ1Rhc2s6IGFkZFRhZ1Rhc2syLCB0YWdMaXN0VGFzazogdGFnTGlzdFRhc2syIH0gPSAoaW5pdF90YWcoKSwgX190b0NvbW1vbkpTKHRhZ19leHBvcnRzKSk7XG4gICAgdmFyIHsgc3RyYWlnaHRUaHJvdWdoQnVmZmVyVGFzazogc3RyYWlnaHRUaHJvdWdoQnVmZmVyVGFzazIsIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2s6IHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2syIH0gPSAoaW5pdF90YXNrKCksIF9fdG9Db21tb25KUyh0YXNrX2V4cG9ydHMpKTtcbiAgICBmdW5jdGlvbiBHaXQyKG9wdGlvbnMsIHBsdWdpbnMpIHtcbiAgICAgIHRoaXMuX3BsdWdpbnMgPSBwbHVnaW5zO1xuICAgICAgdGhpcy5fZXhlY3V0b3IgPSBuZXcgR2l0RXhlY3V0b3IyKFxuICAgICAgICBvcHRpb25zLmJhc2VEaXIsXG4gICAgICAgIG5ldyBTY2hlZHVsZXIyKG9wdGlvbnMubWF4Q29uY3VycmVudFByb2Nlc3NlcyksXG4gICAgICAgIHBsdWdpbnNcbiAgICAgICk7XG4gICAgICB0aGlzLl90cmltbWVkID0gb3B0aW9ucy50cmltbWVkO1xuICAgIH1cbiAgICAoR2l0Mi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNpbXBsZUdpdEFwaTIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBHaXQyO1xuICAgIEdpdDIucHJvdG90eXBlLmN1c3RvbUJpbmFyeSA9IGZ1bmN0aW9uKGNvbW1hbmQpIHtcbiAgICAgIHRoaXMuX3BsdWdpbnMucmVjb25maWd1cmUoXCJiaW5hcnlcIiwgY29tbWFuZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmVudiA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgbmFtZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aGlzLl9leGVjdXRvci5lbnYgPSBuYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKHRoaXMuX2V4ZWN1dG9yLmVudiA9IHRoaXMuX2V4ZWN1dG9yLmVudiB8fCB7fSlbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuc3Rhc2hMaXN0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHN0YXNoTGlzdFRhc2syKFxuICAgICAgICAgIHRyYWlsaW5nT3B0aW9uc0FyZ3VtZW50Mihhcmd1bWVudHMpIHx8IHt9LFxuICAgICAgICAgIGZpbHRlckFycmF5MihvcHRpb25zKSAmJiBvcHRpb25zIHx8IFtdXG4gICAgICAgICksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNsb25lVGFzayhhcGksIHRhc2ssIHJlcG9QYXRoLCBsb2NhbFBhdGgpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVwb1BhdGggIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25FcnJvclRhc2syKGBnaXQuJHthcGl9KCkgcmVxdWlyZXMgYSBzdHJpbmcgJ3JlcG9QYXRoJ2ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhc2socmVwb1BhdGgsIGZpbHRlclR5cGUyKGxvY2FsUGF0aCwgZmlsdGVyU3RyaW5nMiksIGdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzKSk7XG4gICAgfVxuICAgIEdpdDIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgY3JlYXRlQ2xvbmVUYXNrKFwiY2xvbmVcIiwgY2xvbmVUYXNrMiwgLi4uYXJndW1lbnRzKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUubWlycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgY3JlYXRlQ2xvbmVUYXNrKFwibWlycm9yXCIsIGNsb25lTWlycm9yVGFzazIsIC4uLmFyZ3VtZW50cyksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLm12ID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKG1vdmVUYXNrMihmcm9tLCB0byksIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5jaGVja291dExhdGVzdFRhZyA9IGZ1bmN0aW9uKHRoZW4pIHtcbiAgICAgIHZhciBnaXQgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMucHVsbChmdW5jdGlvbigpIHtcbiAgICAgICAgZ2l0LnRhZ3MoZnVuY3Rpb24oZXJyLCB0YWdzKSB7XG4gICAgICAgICAgZ2l0LmNoZWNrb3V0KHRhZ3MubGF0ZXN0LCB0aGVuKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnB1bGwgPSBmdW5jdGlvbihyZW1vdGUsIGJyYW5jaCwgb3B0aW9ucywgdGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHB1bGxUYXNrMihcbiAgICAgICAgICBmaWx0ZXJUeXBlMihyZW1vdGUsIGZpbHRlclN0cmluZzIpLFxuICAgICAgICAgIGZpbHRlclR5cGUyKGJyYW5jaCwgZmlsdGVyU3RyaW5nMiksXG4gICAgICAgICAgZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMpXG4gICAgICAgICksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24ocmVtb3RlLCBicmFuY2gpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBmZXRjaFRhc2syKFxuICAgICAgICAgIGZpbHRlclR5cGUyKHJlbW90ZSwgZmlsdGVyU3RyaW5nMiksXG4gICAgICAgICAgZmlsdGVyVHlwZTIoYnJhbmNoLCBmaWx0ZXJTdHJpbmcyKSxcbiAgICAgICAgICBnZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cylcbiAgICAgICAgKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuc2lsZW50ID0gZnVuY3Rpb24oc2lsZW5jZSkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcInNpbXBsZS1naXQgZGVwcmVjYXRpb24gbm90aWNlOiBnaXQuc2lsZW50OiBsb2dnaW5nIHNob3VsZCBiZSBjb25maWd1cmVkIHVzaW5nIHRoZSBgZGVidWdgIGxpYnJhcnkgLyBgREVCVUdgIGVudmlyb25tZW50IHZhcmlhYmxlLCB0aGlzIHdpbGwgYmUgYW4gZXJyb3IgaW4gdmVyc2lvbiAzXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnRhZ3MgPSBmdW5jdGlvbihvcHRpb25zLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgdGFnTGlzdFRhc2syKGdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzKSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnJlYmFzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2syKFtcInJlYmFzZVwiLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cyldKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbihtb2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgcmVzZXRUYXNrMihnZXRSZXNldE1vZGUyKG1vZGUpLCBnZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cykpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbihjb21taXQpIHtcbiAgICAgIGNvbnN0IG5leHQgPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cyk7XG4gICAgICBpZiAodHlwZW9mIGNvbW1pdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhjb25maWd1cmF0aW9uRXJyb3JUYXNrMihcIkNvbW1pdCBtdXN0IGJlIGEgc3RyaW5nXCIpLCBuZXh0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrMihbXCJyZXZlcnRcIiwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMsIDAsIHRydWUpLCBjb21taXRdKSxcbiAgICAgICAgbmV4dFxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmFkZFRhZyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGNvbnN0IHRhc2sgPSB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiA/IGFkZFRhZ1Rhc2syKG5hbWUpIDogY29uZmlndXJhdGlvbkVycm9yVGFzazIoXCJHaXQuYWRkVGFnIHJlcXVpcmVzIGEgdGFnIG5hbWVcIik7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuYWRkQW5ub3RhdGVkVGFnID0gZnVuY3Rpb24odGFnTmFtZSwgdGFnTWVzc2FnZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGFkZEFubm90YXRlZFRhZ1Rhc2syKHRhZ05hbWUsIHRhZ01lc3NhZ2UpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5kZWxldGVMb2NhbEJyYW5jaCA9IGZ1bmN0aW9uKGJyYW5jaE5hbWUsIGZvcmNlRGVsZXRlLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgZGVsZXRlQnJhbmNoVGFzazIoYnJhbmNoTmFtZSwgdHlwZW9mIGZvcmNlRGVsZXRlID09PSBcImJvb2xlYW5cIiA/IGZvcmNlRGVsZXRlIDogZmFsc2UpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5kZWxldGVMb2NhbEJyYW5jaGVzID0gZnVuY3Rpb24oYnJhbmNoTmFtZXMsIGZvcmNlRGVsZXRlLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgZGVsZXRlQnJhbmNoZXNUYXNrMihicmFuY2hOYW1lcywgdHlwZW9mIGZvcmNlRGVsZXRlID09PSBcImJvb2xlYW5cIiA/IGZvcmNlRGVsZXRlIDogZmFsc2UpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5icmFuY2ggPSBmdW5jdGlvbihvcHRpb25zLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgYnJhbmNoVGFzazIoZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMpKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuYnJhbmNoTG9jYWwgPSBmdW5jdGlvbih0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhicmFuY2hMb2NhbFRhc2syKCksIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5yYXcgPSBmdW5jdGlvbihjb21tYW5kcykge1xuICAgICAgY29uc3QgY3JlYXRlUmVzdENvbW1hbmRzID0gIUFycmF5LmlzQXJyYXkoY29tbWFuZHMpO1xuICAgICAgY29uc3QgY29tbWFuZCA9IFtdLnNsaWNlLmNhbGwoY3JlYXRlUmVzdENvbW1hbmRzID8gYXJndW1lbnRzIDogY29tbWFuZHMsIDApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21tYW5kLmxlbmd0aCAmJiBjcmVhdGVSZXN0Q29tbWFuZHM7IGkrKykge1xuICAgICAgICBpZiAoIWZpbHRlclByaW1pdGl2ZXMyKGNvbW1hbmRbaV0pKSB7XG4gICAgICAgICAgY29tbWFuZC5zcGxpY2UoaSwgY29tbWFuZC5sZW5ndGggLSBpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29tbWFuZC5wdXNoKC4uLmdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzLCAwLCB0cnVlKSk7XG4gICAgICB2YXIgbmV4dCA9IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKTtcbiAgICAgIGlmICghY29tbWFuZC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgY29uZmlndXJhdGlvbkVycm9yVGFzazIoXCJSYXc6IG11c3Qgc3VwcGx5IG9uZSBvciBtb3JlIGNvbW1hbmQgdG8gZXhlY3V0ZVwiKSxcbiAgICAgICAgICBuZXh0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrMihjb21tYW5kLCB0aGlzLl90cmltbWVkKSwgbmV4dCk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5zdWJtb2R1bGVBZGQgPSBmdW5jdGlvbihyZXBvLCBwYXRoLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhhZGRTdWJNb2R1bGVUYXNrMihyZXBvLCBwYXRoKSwgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnN1Ym1vZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uKGFyZ3MsIHRoZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICB1cGRhdGVTdWJNb2R1bGVUYXNrMihnZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cywgdHJ1ZSkpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5zdWJtb2R1bGVJbml0ID0gZnVuY3Rpb24oYXJncywgdGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGluaXRTdWJNb2R1bGVUYXNrMihnZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cywgdHJ1ZSkpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5zdWJNb2R1bGUgPSBmdW5jdGlvbihvcHRpb25zLCB0aGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgc3ViTW9kdWxlVGFzazIoZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMpKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUubGlzdFJlbW90ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGxpc3RSZW1vdGVzVGFzazIoZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMpKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuYWRkUmVtb3RlID0gZnVuY3Rpb24ocmVtb3RlTmFtZSwgcmVtb3RlUmVwbywgdGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGFkZFJlbW90ZVRhc2syKHJlbW90ZU5hbWUsIHJlbW90ZVJlcG8sIGdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzKSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnJlbW92ZVJlbW90ZSA9IGZ1bmN0aW9uKHJlbW90ZU5hbWUsIHRoZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHJlbW92ZVJlbW90ZVRhc2syKHJlbW90ZU5hbWUpLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuZ2V0UmVtb3RlcyA9IGZ1bmN0aW9uKHZlcmJvc2UsIHRoZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKGdldFJlbW90ZXNUYXNrMih2ZXJib3NlID09PSB0cnVlKSwgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnJlbW90ZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIHRoZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICByZW1vdGVUYXNrMihnZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cykpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS50YWcgPSBmdW5jdGlvbihvcHRpb25zLCB0aGVuKSB7XG4gICAgICBjb25zdCBjb21tYW5kID0gZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMpO1xuICAgICAgaWYgKGNvbW1hbmRbMF0gIT09IFwidGFnXCIpIHtcbiAgICAgICAgY29tbWFuZC51bnNoaWZ0KFwidGFnXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzazIoY29tbWFuZCksIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS51cGRhdGVTZXJ2ZXJJbmZvID0gZnVuY3Rpb24odGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2syKFtcInVwZGF0ZS1zZXJ2ZXItaW5mb1wiXSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnB1c2hUYWdzID0gZnVuY3Rpb24ocmVtb3RlLCB0aGVuKSB7XG4gICAgICBjb25zdCB0YXNrID0gcHVzaFRhZ3NUYXNrMihcbiAgICAgICAgeyByZW1vdGU6IGZpbHRlclR5cGUyKHJlbW90ZSwgZmlsdGVyU3RyaW5nMikgfSxcbiAgICAgICAgZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLnJtID0gZnVuY3Rpb24oZmlsZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrMihbXCJybVwiLCBcIi1mXCIsIC4uLmFzQXJyYXkyKGZpbGVzKV0pLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5ybUtlZXBMb2NhbCA9IGZ1bmN0aW9uKGZpbGVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzazIoW1wicm1cIiwgXCItLWNhY2hlZFwiLCAuLi5hc0FycmF5MihmaWxlcyldKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuY2F0RmlsZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIHRoZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYXRGaWxlKFwidXRmLThcIiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmJpbmFyeUNhdEZpbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYXRGaWxlKFwiYnVmZmVyXCIsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5fY2F0RmlsZSA9IGZ1bmN0aW9uKGZvcm1hdCwgYXJncykge1xuICAgICAgdmFyIGhhbmRsZXIgPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3MpO1xuICAgICAgdmFyIGNvbW1hbmQgPSBbXCJjYXQtZmlsZVwiXTtcbiAgICAgIHZhciBvcHRpb25zID0gYXJnc1swXTtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICBjb25maWd1cmF0aW9uRXJyb3JUYXNrMihcIkdpdC5jYXRGaWxlOiBvcHRpb25zIG11c3QgYmUgc3VwcGxpZWQgYXMgYW4gYXJyYXkgb2Ygc3RyaW5nc1wiKSxcbiAgICAgICAgICBoYW5kbGVyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICBjb21tYW5kLnB1c2guYXBwbHkoY29tbWFuZCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0YXNrID0gZm9ybWF0ID09PSBcImJ1ZmZlclwiID8gc3RyYWlnaHRUaHJvdWdoQnVmZmVyVGFzazIoY29tbWFuZCkgOiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrMihjb21tYW5kKTtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHRhc2ssIGhhbmRsZXIpO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uKG9wdGlvbnMsIHRoZW4pIHtcbiAgICAgIGNvbnN0IHRhc2sgPSBmaWx0ZXJTdHJpbmcyKG9wdGlvbnMpID8gY29uZmlndXJhdGlvbkVycm9yVGFzazIoXG4gICAgICAgIFwiZ2l0LmRpZmY6IHN1cHBseWluZyBvcHRpb25zIGFzIGEgc2luZ2xlIHN0cmluZyBpcyBubyBsb25nZXIgc3VwcG9ydGVkLCBzd2l0Y2ggdG8gYW4gYXJyYXkgb2Ygc3RyaW5nc1wiXG4gICAgICApIDogc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzazIoW1wiZGlmZlwiLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMyKGFyZ3VtZW50cyldKTtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHRhc2ssIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5kaWZmU3VtbWFyeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGRpZmZTdW1tYXJ5VGFzazIoZ2V0VHJhaWxpbmdPcHRpb25zMihhcmd1bWVudHMsIDEpKSxcbiAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50Mihhcmd1bWVudHMpXG4gICAgICApO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuYXBwbHlQYXRjaCA9IGZ1bmN0aW9uKHBhdGNoZXMpIHtcbiAgICAgIGNvbnN0IHRhc2sgPSAhZmlsdGVyU3RyaW5nT3JTdHJpbmdBcnJheTIocGF0Y2hlcykgPyBjb25maWd1cmF0aW9uRXJyb3JUYXNrMihcbiAgICAgICAgYGdpdC5hcHBseVBhdGNoIHJlcXVpcmVzIG9uZSBvciBtb3JlIHN0cmluZyBwYXRjaGVzIGFzIHRoZSBmaXJzdCBhcmd1bWVudGBcbiAgICAgICkgOiBhcHBseVBhdGNoVGFzazIoYXNBcnJheTIocGF0Y2hlcyksIGdldFRyYWlsaW5nT3B0aW9uczIoW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSk7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUucmV2cGFyc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGNvbW1hbmRzID0gW1wicmV2LXBhcnNlXCIsIC4uLmdldFRyYWlsaW5nT3B0aW9uczIoYXJndW1lbnRzLCB0cnVlKV07XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzazIoY29tbWFuZHMsIHRydWUpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5jbGVhbiA9IGZ1bmN0aW9uKG1vZGUsIG9wdGlvbnMsIHRoZW4pIHtcbiAgICAgIGNvbnN0IHVzaW5nQ2xlYW5PcHRpb25zQXJyYXkgPSBpc0NsZWFuT3B0aW9uc0FycmF5Mihtb2RlKTtcbiAgICAgIGNvbnN0IGNsZWFuTW9kZSA9IHVzaW5nQ2xlYW5PcHRpb25zQXJyYXkgJiYgbW9kZS5qb2luKFwiXCIpIHx8IGZpbHRlclR5cGUyKG1vZGUsIGZpbHRlclN0cmluZzIpIHx8IFwiXCI7XG4gICAgICBjb25zdCBjdXN0b21BcmdzID0gZ2V0VHJhaWxpbmdPcHRpb25zMihbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgdXNpbmdDbGVhbk9wdGlvbnNBcnJheSA/IDEgOiAwKSk7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgY2xlYW5XaXRoT3B0aW9uc1Rhc2syKGNsZWFuTW9kZSwgY3VzdG9tQXJncyksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbih0aGVuKSB7XG4gICAgICBjb25zdCB0YXNrID0ge1xuICAgICAgICBjb21tYW5kczogW10sXG4gICAgICAgIGZvcm1hdDogXCJ1dGYtOFwiLFxuICAgICAgICBwYXJzZXIoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoZW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrKTtcbiAgICB9O1xuICAgIEdpdDIucHJvdG90eXBlLmNsZWFyUXVldWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgR2l0Mi5wcm90b3R5cGUuY2hlY2tJZ25vcmUgPSBmdW5jdGlvbihwYXRobmFtZXMsIHRoZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICBjaGVja0lnbm9yZVRhc2syKGFzQXJyYXkyKGZpbHRlclR5cGUyKHBhdGhuYW1lcywgZmlsdGVyU3RyaW5nT3JTdHJpbmdBcnJheTIsIFtdKSkpLFxuICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQyKGFyZ3VtZW50cylcbiAgICAgICk7XG4gICAgfTtcbiAgICBHaXQyLnByb3RvdHlwZS5jaGVja0lzUmVwbyA9IGZ1bmN0aW9uKGNoZWNrVHlwZSwgdGhlbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgIGNoZWNrSXNSZXBvVGFzazIoZmlsdGVyVHlwZTIoY2hlY2tUeXBlLCBmaWx0ZXJTdHJpbmcyKSksXG4gICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudDIoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgICB9O1xuICAgIG1vZHVsZS5leHBvcnRzID0gR2l0MjtcbiAgfVxufSk7XG5cbi8vIHNyYy9saWIvYXBpLnRzXG5pbml0X3BhdGhzcGVjKCk7XG5cbi8vIHNyYy9saWIvZXJyb3JzL2dpdC1jb25zdHJ1Y3QtZXJyb3IudHNcbmluaXRfZ2l0X2Vycm9yKCk7XG52YXIgR2l0Q29uc3RydWN0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEdpdEVycm9yIHtcbiAgY29uc3RydWN0b3IoY29uZmlnLCBtZXNzYWdlKSB7XG4gICAgc3VwZXIodm9pZCAwLCBtZXNzYWdlKTtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9hcGkudHNcbmluaXRfZ2l0X2Vycm9yKCk7XG5cbi8vIHNyYy9saWIvZXJyb3JzL2dpdC1wbHVnaW4tZXJyb3IudHNcbmluaXRfZ2l0X2Vycm9yKCk7XG52YXIgR2l0UGx1Z2luRXJyb3IgPSBjbGFzcyBleHRlbmRzIEdpdEVycm9yIHtcbiAgY29uc3RydWN0b3IodGFzaywgcGx1Z2luLCBtZXNzYWdlKSB7XG4gICAgc3VwZXIodGFzaywgbWVzc2FnZSk7XG4gICAgdGhpcy50YXNrID0gdGFzaztcbiAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL2FwaS50c1xuaW5pdF9naXRfcmVzcG9uc2VfZXJyb3IoKTtcbmluaXRfdGFza19jb25maWd1cmF0aW9uX2Vycm9yKCk7XG5pbml0X2NoZWNrX2lzX3JlcG8oKTtcbmluaXRfY2xlYW4oKTtcbmluaXRfY29uZmlnKCk7XG5pbml0X2RpZmZfbmFtZV9zdGF0dXMoKTtcbmluaXRfZ3JlcCgpO1xuaW5pdF9yZXNldCgpO1xuXG4vLyBzcmMvbGliL3BsdWdpbnMvYWJvcnQtcGx1Z2luLnRzXG5mdW5jdGlvbiBhYm9ydFBsdWdpbihzaWduYWwpIHtcbiAgaWYgKCFzaWduYWwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb25TcGF3bkFmdGVyID0ge1xuICAgIHR5cGU6IFwic3Bhd24uYWZ0ZXJcIixcbiAgICBhY3Rpb24oX2RhdGEsIGNvbnRleHQpIHtcbiAgICAgIGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICAgIGNvbnRleHQua2lsbChuZXcgR2l0UGx1Z2luRXJyb3Iodm9pZCAwLCBcImFib3J0XCIsIFwiQWJvcnQgc2lnbmFsIHJlY2VpdmVkXCIpKTtcbiAgICAgIH1cbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwga2lsbCk7XG4gICAgICBjb250ZXh0LnNwYXduZWQub24oXCJjbG9zZVwiLCAoKSA9PiBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGtpbGwpKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG9uU3Bhd25CZWZvcmUgPSB7XG4gICAgdHlwZTogXCJzcGF3bi5iZWZvcmVcIixcbiAgICBhY3Rpb24oX2RhdGEsIGNvbnRleHQpIHtcbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICBjb250ZXh0LmtpbGwobmV3IEdpdFBsdWdpbkVycm9yKHZvaWQgMCwgXCJhYm9ydFwiLCBcIkFib3J0IGFscmVhZHkgc2lnbmFsZWRcIikpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFtvblNwYXduQmVmb3JlLCBvblNwYXduQWZ0ZXJdO1xufVxuXG4vLyBzcmMvbGliL3BsdWdpbnMvYmxvY2stdW5zYWZlLW9wZXJhdGlvbnMtcGx1Z2luLnRzXG5mdW5jdGlvbiBpc0NvbmZpZ1N3aXRjaChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIgJiYgYXJnLnRyaW0oKS50b0xvd2VyQ2FzZSgpID09PSBcIi1jXCI7XG59XG5mdW5jdGlvbiBwcmV2ZW50UHJvdG9jb2xPdmVycmlkZShhcmcsIG5leHQpIHtcbiAgaWYgKCFpc0NvbmZpZ1N3aXRjaChhcmcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghL15cXHMqcHJvdG9jb2woLlthLXpdKyk/LmFsbG93Ly50ZXN0KG5leHQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRocm93IG5ldyBHaXRQbHVnaW5FcnJvcihcbiAgICB2b2lkIDAsXG4gICAgXCJ1bnNhZmVcIixcbiAgICBcIkNvbmZpZ3VyaW5nIHByb3RvY29sLmFsbG93IGlzIG5vdCBwZXJtaXR0ZWQgd2l0aG91dCBlbmFibGluZyBhbGxvd1Vuc2FmZUV4dFByb3RvY29sXCJcbiAgKTtcbn1cbmZ1bmN0aW9uIHByZXZlbnRVcGxvYWRQYWNrKGFyZywgbWV0aG9kKSB7XG4gIGlmICgvXlxccyotLSh1cGxvYWR8cmVjZWl2ZSktcGFjay8udGVzdChhcmcpKSB7XG4gICAgdGhyb3cgbmV3IEdpdFBsdWdpbkVycm9yKFxuICAgICAgdm9pZCAwLFxuICAgICAgXCJ1bnNhZmVcIixcbiAgICAgIGBVc2Ugb2YgLS11cGxvYWQtcGFjayBvciAtLXJlY2VpdmUtcGFjayBpcyBub3QgcGVybWl0dGVkIHdpdGhvdXQgZW5hYmxpbmcgYWxsb3dVbnNhZmVQYWNrYFxuICAgICk7XG4gIH1cbiAgaWYgKG1ldGhvZCA9PT0gXCJjbG9uZVwiICYmIC9eXFxzKi11XFxiLy50ZXN0KGFyZykpIHtcbiAgICB0aHJvdyBuZXcgR2l0UGx1Z2luRXJyb3IoXG4gICAgICB2b2lkIDAsXG4gICAgICBcInVuc2FmZVwiLFxuICAgICAgYFVzZSBvZiBjbG9uZSB3aXRoIG9wdGlvbiAtdSBpcyBub3QgcGVybWl0dGVkIHdpdGhvdXQgZW5hYmxpbmcgYWxsb3dVbnNhZmVQYWNrYFxuICAgICk7XG4gIH1cbiAgaWYgKG1ldGhvZCA9PT0gXCJwdXNoXCIgJiYgL15cXHMqLS1leGVjXFxiLy50ZXN0KGFyZykpIHtcbiAgICB0aHJvdyBuZXcgR2l0UGx1Z2luRXJyb3IoXG4gICAgICB2b2lkIDAsXG4gICAgICBcInVuc2FmZVwiLFxuICAgICAgYFVzZSBvZiBwdXNoIHdpdGggb3B0aW9uIC0tZXhlYyBpcyBub3QgcGVybWl0dGVkIHdpdGhvdXQgZW5hYmxpbmcgYWxsb3dVbnNhZmVQYWNrYFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGJsb2NrVW5zYWZlT3BlcmF0aW9uc1BsdWdpbih7XG4gIGFsbG93VW5zYWZlUHJvdG9jb2xPdmVycmlkZSA9IGZhbHNlLFxuICBhbGxvd1Vuc2FmZVBhY2sgPSBmYWxzZVxufSA9IHt9KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzcGF3bi5hcmdzXCIsXG4gICAgYWN0aW9uKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgIGFyZ3MuZm9yRWFjaCgoY3VycmVudCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgbmV4dCA9IGluZGV4IDwgYXJncy5sZW5ndGggPyBhcmdzW2luZGV4ICsgMV0gOiBcIlwiO1xuICAgICAgICBhbGxvd1Vuc2FmZVByb3RvY29sT3ZlcnJpZGUgfHwgcHJldmVudFByb3RvY29sT3ZlcnJpZGUoY3VycmVudCwgbmV4dCk7XG4gICAgICAgIGFsbG93VW5zYWZlUGFjayB8fCBwcmV2ZW50VXBsb2FkUGFjayhjdXJyZW50LCBjb250ZXh0Lm1ldGhvZCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9wbHVnaW5zL2NvbW1hbmQtY29uZmlnLXByZWZpeGluZy1wbHVnaW4udHNcbmluaXRfdXRpbHMoKTtcbmZ1bmN0aW9uIGNvbW1hbmRDb25maWdQcmVmaXhpbmdQbHVnaW4oY29uZmlndXJhdGlvbikge1xuICBjb25zdCBwcmVmaXggPSBwcmVmaXhlZEFycmF5KGNvbmZpZ3VyYXRpb24sIFwiLWNcIik7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzcGF3bi5hcmdzXCIsXG4gICAgYWN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBbLi4ucHJlZml4LCAuLi5kYXRhXTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9saWIvcGx1Z2lucy9jb21wbGV0aW9uLWRldGVjdGlvbi5wbHVnaW4udHNcbmluaXRfdXRpbHMoKTtcbmltcG9ydCB7IGRlZmVycmVkIH0gZnJvbSBcIkBrd3NpdGVzL3Byb21pc2UtZGVmZXJyZWRcIjtcbnZhciBuZXZlciA9IGRlZmVycmVkKCkucHJvbWlzZTtcbmZ1bmN0aW9uIGNvbXBsZXRpb25EZXRlY3Rpb25QbHVnaW4oe1xuICBvbkNsb3NlID0gdHJ1ZSxcbiAgb25FeGl0ID0gNTBcbn0gPSB7fSkge1xuICBmdW5jdGlvbiBjcmVhdGVFdmVudHMoKSB7XG4gICAgbGV0IGV4aXRDb2RlID0gLTE7XG4gICAgY29uc3QgZXZlbnRzID0ge1xuICAgICAgY2xvc2U6IGRlZmVycmVkKCksXG4gICAgICBjbG9zZVRpbWVvdXQ6IGRlZmVycmVkKCksXG4gICAgICBleGl0OiBkZWZlcnJlZCgpLFxuICAgICAgZXhpdFRpbWVvdXQ6IGRlZmVycmVkKClcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IFByb21pc2UucmFjZShbXG4gICAgICBvbkNsb3NlID09PSBmYWxzZSA/IG5ldmVyIDogZXZlbnRzLmNsb3NlVGltZW91dC5wcm9taXNlLFxuICAgICAgb25FeGl0ID09PSBmYWxzZSA/IG5ldmVyIDogZXZlbnRzLmV4aXRUaW1lb3V0LnByb21pc2VcbiAgICBdKTtcbiAgICBjb25maWd1cmVUaW1lb3V0KG9uQ2xvc2UsIGV2ZW50cy5jbG9zZSwgZXZlbnRzLmNsb3NlVGltZW91dCk7XG4gICAgY29uZmlndXJlVGltZW91dChvbkV4aXQsIGV2ZW50cy5leGl0LCBldmVudHMuZXhpdFRpbWVvdXQpO1xuICAgIHJldHVybiB7XG4gICAgICBjbG9zZShjb2RlKSB7XG4gICAgICAgIGV4aXRDb2RlID0gY29kZTtcbiAgICAgICAgZXZlbnRzLmNsb3NlLmRvbmUoKTtcbiAgICAgIH0sXG4gICAgICBleGl0KGNvZGUpIHtcbiAgICAgICAgZXhpdENvZGUgPSBjb2RlO1xuICAgICAgICBldmVudHMuZXhpdC5kb25lKCk7XG4gICAgICB9LFxuICAgICAgZ2V0IGV4aXRDb2RlKCkge1xuICAgICAgICByZXR1cm4gZXhpdENvZGU7XG4gICAgICB9LFxuICAgICAgcmVzdWx0XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBjb25maWd1cmVUaW1lb3V0KGZsYWcsIGV2ZW50LCB0aW1lb3V0KSB7XG4gICAgaWYgKGZsYWcgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIChmbGFnID09PSB0cnVlID8gZXZlbnQucHJvbWlzZSA6IGV2ZW50LnByb21pc2UudGhlbigoKSA9PiBkZWxheShmbGFnKSkpLnRoZW4odGltZW91dC5kb25lKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3Bhd24uYWZ0ZXJcIixcbiAgICBhY3Rpb24oXzAsIF8xKSB7XG4gICAgICByZXR1cm4gX19hc3luYyh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoX2RhdGEsIHsgc3Bhd25lZCwgY2xvc2UgfSkge1xuICAgICAgICB2YXIgX2EzLCBfYjtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gY3JlYXRlRXZlbnRzKCk7XG4gICAgICAgIGxldCBkZWZlckNsb3NlID0gdHJ1ZTtcbiAgICAgICAgbGV0IHF1aWNrQ2xvc2UgPSAoKSA9PiB2b2lkIChkZWZlckNsb3NlID0gZmFsc2UpO1xuICAgICAgICAoX2EzID0gc3Bhd25lZC5zdGRvdXQpID09IG51bGwgPyB2b2lkIDAgOiBfYTMub24oXCJkYXRhXCIsIHF1aWNrQ2xvc2UpO1xuICAgICAgICAoX2IgPSBzcGF3bmVkLnN0ZGVycikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm9uKFwiZGF0YVwiLCBxdWlja0Nsb3NlKTtcbiAgICAgICAgc3Bhd25lZC5vbihcImVycm9yXCIsIHF1aWNrQ2xvc2UpO1xuICAgICAgICBzcGF3bmVkLm9uKFwiY2xvc2VcIiwgKGNvZGUpID0+IGV2ZW50cy5jbG9zZShjb2RlKSk7XG4gICAgICAgIHNwYXduZWQub24oXCJleGl0XCIsIChjb2RlKSA9PiBldmVudHMuZXhpdChjb2RlKSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgeWllbGQgZXZlbnRzLnJlc3VsdDtcbiAgICAgICAgICBpZiAoZGVmZXJDbG9zZSkge1xuICAgICAgICAgICAgeWllbGQgZGVsYXkoNTApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbG9zZShldmVudHMuZXhpdENvZGUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjbG9zZShldmVudHMuZXhpdENvZGUsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9wbHVnaW5zL2N1c3RvbS1iaW5hcnkucGx1Z2luLnRzXG5pbml0X3V0aWxzKCk7XG52YXIgV1JPTkdfTlVNQkVSX0VSUiA9IGBJbnZhbGlkIHZhbHVlIHN1cHBsaWVkIGZvciBjdXN0b20gYmluYXJ5LCByZXF1aXJlcyBhIHNpbmdsZSBzdHJpbmcgb3IgYW4gYXJyYXkgY29udGFpbmluZyBlaXRoZXIgb25lIG9yIHR3byBzdHJpbmdzYDtcbnZhciBXUk9OR19DSEFSU19FUlIgPSBgSW52YWxpZCB2YWx1ZSBzdXBwbGllZCBmb3IgY3VzdG9tIGJpbmFyeSwgcmVzdHJpY3RlZCBjaGFyYWN0ZXJzIG11c3QgYmUgcmVtb3ZlZCBvciBzdXBwbHkgdGhlIHVuc2FmZS5hbGxvd1Vuc2FmZUN1c3RvbUJpbmFyeSBvcHRpb25gO1xuZnVuY3Rpb24gaXNCYWRBcmd1bWVudChhcmcpIHtcbiAgcmV0dXJuICFhcmcgfHwgIS9eKFthLXpdOik/KFthLXowLTkvLlxcXFxfLV0rKSQvaS50ZXN0KGFyZyk7XG59XG5mdW5jdGlvbiB0b0JpbmFyeUNvbmZpZyhpbnB1dCwgYWxsb3dVbnNhZmUpIHtcbiAgaWYgKGlucHV0Lmxlbmd0aCA8IDEgfHwgaW5wdXQubGVuZ3RoID4gMikge1xuICAgIHRocm93IG5ldyBHaXRQbHVnaW5FcnJvcih2b2lkIDAsIFwiYmluYXJ5XCIsIFdST05HX05VTUJFUl9FUlIpO1xuICB9XG4gIGNvbnN0IGlzQmFkID0gaW5wdXQuc29tZShpc0JhZEFyZ3VtZW50KTtcbiAgaWYgKGlzQmFkKSB7XG4gICAgaWYgKGFsbG93VW5zYWZlKSB7XG4gICAgICBjb25zb2xlLndhcm4oV1JPTkdfQ0hBUlNfRVJSKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEdpdFBsdWdpbkVycm9yKHZvaWQgMCwgXCJiaW5hcnlcIiwgV1JPTkdfQ0hBUlNfRVJSKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgW2JpbmFyeSwgcHJlZml4XSA9IGlucHV0O1xuICByZXR1cm4ge1xuICAgIGJpbmFyeSxcbiAgICBwcmVmaXhcbiAgfTtcbn1cbmZ1bmN0aW9uIGN1c3RvbUJpbmFyeVBsdWdpbihwbHVnaW5zLCBpbnB1dCA9IFtcImdpdFwiXSwgYWxsb3dVbnNhZmUgPSBmYWxzZSkge1xuICBsZXQgY29uZmlnID0gdG9CaW5hcnlDb25maWcoYXNBcnJheShpbnB1dCksIGFsbG93VW5zYWZlKTtcbiAgcGx1Z2lucy5vbihcImJpbmFyeVwiLCAoaW5wdXQyKSA9PiB7XG4gICAgY29uZmlnID0gdG9CaW5hcnlDb25maWcoYXNBcnJheShpbnB1dDIpLCBhbGxvd1Vuc2FmZSk7XG4gIH0pO1xuICBwbHVnaW5zLmFwcGVuZChcInNwYXduLmJpbmFyeVwiLCAoKSA9PiB7XG4gICAgcmV0dXJuIGNvbmZpZy5iaW5hcnk7XG4gIH0pO1xuICBwbHVnaW5zLmFwcGVuZChcInNwYXduLmFyZ3NcIiwgKGRhdGEpID0+IHtcbiAgICByZXR1cm4gY29uZmlnLnByZWZpeCA/IFtjb25maWcucHJlZml4LCAuLi5kYXRhXSA6IGRhdGE7XG4gIH0pO1xufVxuXG4vLyBzcmMvbGliL3BsdWdpbnMvZXJyb3ItZGV0ZWN0aW9uLnBsdWdpbi50c1xuaW5pdF9naXRfZXJyb3IoKTtcbmZ1bmN0aW9uIGlzVGFza0Vycm9yKHJlc3VsdCkge1xuICByZXR1cm4gISEocmVzdWx0LmV4aXRDb2RlICYmIHJlc3VsdC5zdGRFcnIubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShyZXN1bHQpIHtcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoWy4uLnJlc3VsdC5zdGRPdXQsIC4uLnJlc3VsdC5zdGRFcnJdKTtcbn1cbmZ1bmN0aW9uIGVycm9yRGV0ZWN0aW9uSGFuZGxlcihvdmVyd3JpdGUgPSBmYWxzZSwgaXNFcnJvciA9IGlzVGFza0Vycm9yLCBlcnJvck1lc3NhZ2UgPSBnZXRFcnJvck1lc3NhZ2UpIHtcbiAgcmV0dXJuIChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgaWYgKCFvdmVyd3JpdGUgJiYgZXJyb3IgfHwgIWlzRXJyb3IocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JNZXNzYWdlKHJlc3VsdCk7XG4gIH07XG59XG5mdW5jdGlvbiBlcnJvckRldGVjdGlvblBsdWdpbihjb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInRhc2suZXJyb3JcIixcbiAgICBhY3Rpb24oZGF0YSwgY29udGV4dCkge1xuICAgICAgY29uc3QgZXJyb3IgPSBjb25maWcoZGF0YS5lcnJvciwge1xuICAgICAgICBzdGRFcnI6IGNvbnRleHQuc3RkRXJyLFxuICAgICAgICBzdGRPdXQ6IGNvbnRleHQuc3RkT3V0LFxuICAgICAgICBleGl0Q29kZTogY29udGV4dC5leGl0Q29kZVxuICAgICAgfSk7XG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGVycm9yKSkge1xuICAgICAgICByZXR1cm4geyBlcnJvcjogbmV3IEdpdEVycm9yKHZvaWQgMCwgZXJyb3IudG9TdHJpbmcoXCJ1dGYtOFwiKSkgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2xpYi9wbHVnaW5zL3BsdWdpbi1zdG9yZS50c1xuaW5pdF91dGlscygpO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSBcIm5vZGU6ZXZlbnRzXCI7XG52YXIgUGx1Z2luU3RvcmUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucGx1Z2lucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5ldmVudHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIH1cbiAgb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLmV2ZW50cy5vbih0eXBlLCBsaXN0ZW5lcik7XG4gIH1cbiAgcmVjb25maWd1cmUodHlwZSwgZGF0YSkge1xuICAgIHRoaXMuZXZlbnRzLmVtaXQodHlwZSwgZGF0YSk7XG4gIH1cbiAgYXBwZW5kKHR5cGUsIGFjdGlvbikge1xuICAgIGNvbnN0IHBsdWdpbiA9IGFwcGVuZCh0aGlzLnBsdWdpbnMsIHsgdHlwZSwgYWN0aW9uIH0pO1xuICAgIHJldHVybiAoKSA9PiB0aGlzLnBsdWdpbnMuZGVsZXRlKHBsdWdpbik7XG4gIH1cbiAgYWRkKHBsdWdpbikge1xuICAgIGNvbnN0IHBsdWdpbnMgPSBbXTtcbiAgICBhc0FycmF5KHBsdWdpbikuZm9yRWFjaCgocGx1Z2luMikgPT4gcGx1Z2luMiAmJiB0aGlzLnBsdWdpbnMuYWRkKGFwcGVuZChwbHVnaW5zLCBwbHVnaW4yKSkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBwbHVnaW5zLmZvckVhY2goKHBsdWdpbjIpID0+IHRoaXMucGx1Z2lucy5kZWxldGUocGx1Z2luMikpO1xuICAgIH07XG4gIH1cbiAgZXhlYyh0eXBlLCBkYXRhLCBjb250ZXh0KSB7XG4gICAgbGV0IG91dHB1dCA9IGRhdGE7XG4gICAgY29uc3QgY29udGV4dHVhbCA9IE9iamVjdC5mcmVlemUoT2JqZWN0LmNyZWF0ZShjb250ZXh0KSk7XG4gICAgZm9yIChjb25zdCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKSB7XG4gICAgICBpZiAocGx1Z2luLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgb3V0cHV0ID0gcGx1Z2luLmFjdGlvbihvdXRwdXQsIGNvbnRleHR1YWwpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG59O1xuXG4vLyBzcmMvbGliL3BsdWdpbnMvcHJvZ3Jlc3MtbW9uaXRvci1wbHVnaW4udHNcbmluaXRfdXRpbHMoKTtcbmZ1bmN0aW9uIHByb2dyZXNzTW9uaXRvclBsdWdpbihwcm9ncmVzcykge1xuICBjb25zdCBwcm9ncmVzc0NvbW1hbmQgPSBcIi0tcHJvZ3Jlc3NcIjtcbiAgY29uc3QgcHJvZ3Jlc3NNZXRob2RzID0gW1wiY2hlY2tvdXRcIiwgXCJjbG9uZVwiLCBcImZldGNoXCIsIFwicHVsbFwiLCBcInB1c2hcIl07XG4gIGNvbnN0IG9uUHJvZ3Jlc3MgPSB7XG4gICAgdHlwZTogXCJzcGF3bi5hZnRlclwiLFxuICAgIGFjdGlvbihfZGF0YSwgY29udGV4dCkge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGlmICghY29udGV4dC5jb21tYW5kcy5pbmNsdWRlcyhwcm9ncmVzc0NvbW1hbmQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIChfYTIgPSBjb250ZXh0LnNwYXduZWQuc3RkZXJyKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLm9uKFwiZGF0YVwiLCAoY2h1bmspID0+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IC9eKFtcXHNcXFNdKz8pOlxccyooXFxkKyklIFxcKChcXGQrKVxcLyhcXGQrKVxcKS8uZXhlYyhjaHVuay50b1N0cmluZyhcInV0ZjhcIikpO1xuICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJvZ3Jlc3Moe1xuICAgICAgICAgIG1ldGhvZDogY29udGV4dC5tZXRob2QsXG4gICAgICAgICAgc3RhZ2U6IHByb2dyZXNzRXZlbnRTdGFnZShtZXNzYWdlWzFdKSxcbiAgICAgICAgICBwcm9ncmVzczogYXNOdW1iZXIobWVzc2FnZVsyXSksXG4gICAgICAgICAgcHJvY2Vzc2VkOiBhc051bWJlcihtZXNzYWdlWzNdKSxcbiAgICAgICAgICB0b3RhbDogYXNOdW1iZXIobWVzc2FnZVs0XSlcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IG9uQXJncyA9IHtcbiAgICB0eXBlOiBcInNwYXduLmFyZ3NcIixcbiAgICBhY3Rpb24oYXJncywgY29udGV4dCkge1xuICAgICAgaWYgKCFwcm9ncmVzc01ldGhvZHMuaW5jbHVkZXMoY29udGV4dC5tZXRob2QpKSB7XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluY2x1ZGluZyhhcmdzLCBwcm9ncmVzc0NvbW1hbmQpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFtvbkFyZ3MsIG9uUHJvZ3Jlc3NdO1xufVxuZnVuY3Rpb24gcHJvZ3Jlc3NFdmVudFN0YWdlKGlucHV0KSB7XG4gIHJldHVybiBTdHJpbmcoaW5wdXQudG9Mb3dlckNhc2UoKS5zcGxpdChcIiBcIiwgMSkpIHx8IFwidW5rbm93blwiO1xufVxuXG4vLyBzcmMvbGliL3BsdWdpbnMvc3Bhd24tb3B0aW9ucy1wbHVnaW4udHNcbmluaXRfdXRpbHMoKTtcbmZ1bmN0aW9uIHNwYXduT3B0aW9uc1BsdWdpbihzcGF3bk9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHBpY2soc3Bhd25PcHRpb25zLCBbXCJ1aWRcIiwgXCJnaWRcIl0pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3Bhd24ub3B0aW9uc1wiLFxuICAgIGFjdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCBkYXRhKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9saWIvcGx1Z2lucy90aW1vdXQtcGx1Z2luLnRzXG5mdW5jdGlvbiB0aW1lb3V0UGx1Z2luKHtcbiAgYmxvY2ssXG4gIHN0ZEVyciA9IHRydWUsXG4gIHN0ZE91dCA9IHRydWVcbn0pIHtcbiAgaWYgKGJsb2NrID4gMCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInNwYXduLmFmdGVyXCIsXG4gICAgICBhY3Rpb24oX2RhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF9hMiwgX2I7XG4gICAgICAgIGxldCB0aW1lb3V0O1xuICAgICAgICBmdW5jdGlvbiB3YWl0KCkge1xuICAgICAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGtpbGwsIGJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICAgIHZhciBfYTMsIF9iMjtcbiAgICAgICAgICAoX2EzID0gY29udGV4dC5zcGF3bmVkLnN0ZG91dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5vZmYoXCJkYXRhXCIsIHdhaXQpO1xuICAgICAgICAgIChfYjIgPSBjb250ZXh0LnNwYXduZWQuc3RkZXJyKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLm9mZihcImRhdGFcIiwgd2FpdCk7XG4gICAgICAgICAgY29udGV4dC5zcGF3bmVkLm9mZihcImV4aXRcIiwgc3RvcCk7XG4gICAgICAgICAgY29udGV4dC5zcGF3bmVkLm9mZihcImNsb3NlXCIsIHN0b3ApO1xuICAgICAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgIGNvbnRleHQua2lsbChuZXcgR2l0UGx1Z2luRXJyb3Iodm9pZCAwLCBcInRpbWVvdXRcIiwgYGJsb2NrIHRpbWVvdXQgcmVhY2hlZGApKTtcbiAgICAgICAgfVxuICAgICAgICBzdGRPdXQgJiYgKChfYTIgPSBjb250ZXh0LnNwYXduZWQuc3Rkb3V0KSA9PSBudWxsID8gdm9pZCAwIDogX2EyLm9uKFwiZGF0YVwiLCB3YWl0KSk7XG4gICAgICAgIHN0ZEVyciAmJiAoKF9iID0gY29udGV4dC5zcGF3bmVkLnN0ZGVycikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm9uKFwiZGF0YVwiLCB3YWl0KSk7XG4gICAgICAgIGNvbnRleHQuc3Bhd25lZC5vbihcImV4aXRcIiwgc3RvcCk7XG4gICAgICAgIGNvbnRleHQuc3Bhd25lZC5vbihcImNsb3NlXCIsIHN0b3ApO1xuICAgICAgICB3YWl0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvbGliL3BsdWdpbnMvc3VmZml4LXBhdGhzLnBsdWdpbi50c1xuaW5pdF9wYXRoc3BlYygpO1xuZnVuY3Rpb24gc3VmZml4UGF0aHNQbHVnaW4oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzcGF3bi5hcmdzXCIsXG4gICAgYWN0aW9uKGRhdGEpIHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IFtdO1xuICAgICAgbGV0IHN1ZmZpeDtcbiAgICAgIGZ1bmN0aW9uIGFwcGVuZDIoYXJncykge1xuICAgICAgICAoc3VmZml4ID0gc3VmZml4IHx8IFtdKS5wdXNoKC4uLmFyZ3MpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtID0gZGF0YVtpXTtcbiAgICAgICAgaWYgKGlzUGF0aFNwZWMocGFyYW0pKSB7XG4gICAgICAgICAgYXBwZW5kMih0b1BhdGhzKHBhcmFtKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtID09PSBcIi0tXCIpIHtcbiAgICAgICAgICBhcHBlbmQyKFxuICAgICAgICAgICAgZGF0YS5zbGljZShpICsgMSkuZmxhdE1hcCgoaXRlbSkgPT4gaXNQYXRoU3BlYyhpdGVtKSAmJiB0b1BhdGhzKGl0ZW0pIHx8IGl0ZW0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwcmVmaXgucHVzaChwYXJhbSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gIXN1ZmZpeCA/IHByZWZpeCA6IFsuLi5wcmVmaXgsIFwiLS1cIiwgLi4uc3VmZml4Lm1hcChTdHJpbmcpXTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9saWIvZ2l0LWZhY3RvcnkudHNcbmluaXRfdXRpbHMoKTtcbnZhciBHaXQgPSByZXF1aXJlX2dpdCgpO1xuZnVuY3Rpb24gZ2l0SW5zdGFuY2VGYWN0b3J5KGJhc2VEaXIsIG9wdGlvbnMpIHtcbiAgdmFyIF9hMjtcbiAgY29uc3QgcGx1Z2lucyA9IG5ldyBQbHVnaW5TdG9yZSgpO1xuICBjb25zdCBjb25maWcgPSBjcmVhdGVJbnN0YW5jZUNvbmZpZyhcbiAgICBiYXNlRGlyICYmICh0eXBlb2YgYmFzZURpciA9PT0gXCJzdHJpbmdcIiA/IHsgYmFzZURpciB9IDogYmFzZURpcikgfHwge30sXG4gICAgb3B0aW9uc1xuICApO1xuICBpZiAoIWZvbGRlckV4aXN0cyhjb25maWcuYmFzZURpcikpIHtcbiAgICB0aHJvdyBuZXcgR2l0Q29uc3RydWN0RXJyb3IoXG4gICAgICBjb25maWcsXG4gICAgICBgQ2Fubm90IHVzZSBzaW1wbGUtZ2l0IG9uIGEgZGlyZWN0b3J5IHRoYXQgZG9lcyBub3QgZXhpc3RgXG4gICAgKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcuY29uZmlnKSkge1xuICAgIHBsdWdpbnMuYWRkKGNvbW1hbmRDb25maWdQcmVmaXhpbmdQbHVnaW4oY29uZmlnLmNvbmZpZykpO1xuICB9XG4gIHBsdWdpbnMuYWRkKGJsb2NrVW5zYWZlT3BlcmF0aW9uc1BsdWdpbihjb25maWcudW5zYWZlKSk7XG4gIHBsdWdpbnMuYWRkKHN1ZmZpeFBhdGhzUGx1Z2luKCkpO1xuICBwbHVnaW5zLmFkZChjb21wbGV0aW9uRGV0ZWN0aW9uUGx1Z2luKGNvbmZpZy5jb21wbGV0aW9uKSk7XG4gIGNvbmZpZy5hYm9ydCAmJiBwbHVnaW5zLmFkZChhYm9ydFBsdWdpbihjb25maWcuYWJvcnQpKTtcbiAgY29uZmlnLnByb2dyZXNzICYmIHBsdWdpbnMuYWRkKHByb2dyZXNzTW9uaXRvclBsdWdpbihjb25maWcucHJvZ3Jlc3MpKTtcbiAgY29uZmlnLnRpbWVvdXQgJiYgcGx1Z2lucy5hZGQodGltZW91dFBsdWdpbihjb25maWcudGltZW91dCkpO1xuICBjb25maWcuc3Bhd25PcHRpb25zICYmIHBsdWdpbnMuYWRkKHNwYXduT3B0aW9uc1BsdWdpbihjb25maWcuc3Bhd25PcHRpb25zKSk7XG4gIHBsdWdpbnMuYWRkKGVycm9yRGV0ZWN0aW9uUGx1Z2luKGVycm9yRGV0ZWN0aW9uSGFuZGxlcih0cnVlKSkpO1xuICBjb25maWcuZXJyb3JzICYmIHBsdWdpbnMuYWRkKGVycm9yRGV0ZWN0aW9uUGx1Z2luKGNvbmZpZy5lcnJvcnMpKTtcbiAgY3VzdG9tQmluYXJ5UGx1Z2luKHBsdWdpbnMsIGNvbmZpZy5iaW5hcnksIChfYTIgPSBjb25maWcudW5zYWZlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmFsbG93VW5zYWZlQ3VzdG9tQmluYXJ5KTtcbiAgcmV0dXJuIG5ldyBHaXQoY29uZmlnLCBwbHVnaW5zKTtcbn1cblxuLy8gc3JjL2xpYi9ydW5uZXJzL3Byb21pc2Utd3JhcHBlZC50c1xuaW5pdF9naXRfcmVzcG9uc2VfZXJyb3IoKTtcbnZhciBmdW5jdGlvbk5hbWVzQnVpbGRlckFwaSA9IFtcImN1c3RvbUJpbmFyeVwiLCBcImVudlwiLCBcIm91dHB1dEhhbmRsZXJcIiwgXCJzaWxlbnRcIl07XG52YXIgZnVuY3Rpb25OYW1lc1Byb21pc2VBcGkgPSBbXG4gIFwiYWRkXCIsXG4gIFwiYWRkQW5ub3RhdGVkVGFnXCIsXG4gIFwiYWRkQ29uZmlnXCIsXG4gIFwiYWRkUmVtb3RlXCIsXG4gIFwiYWRkVGFnXCIsXG4gIFwiYXBwbHlQYXRjaFwiLFxuICBcImJpbmFyeUNhdEZpbGVcIixcbiAgXCJicmFuY2hcIixcbiAgXCJicmFuY2hMb2NhbFwiLFxuICBcImNhdEZpbGVcIixcbiAgXCJjaGVja0lnbm9yZVwiLFxuICBcImNoZWNrSXNSZXBvXCIsXG4gIFwiY2hlY2tvdXRcIixcbiAgXCJjaGVja291dEJyYW5jaFwiLFxuICBcImNoZWNrb3V0TGF0ZXN0VGFnXCIsXG4gIFwiY2hlY2tvdXRMb2NhbEJyYW5jaFwiLFxuICBcImNsZWFuXCIsXG4gIFwiY2xvbmVcIixcbiAgXCJjb21taXRcIixcbiAgXCJjd2RcIixcbiAgXCJkZWxldGVMb2NhbEJyYW5jaFwiLFxuICBcImRlbGV0ZUxvY2FsQnJhbmNoZXNcIixcbiAgXCJkaWZmXCIsXG4gIFwiZGlmZlN1bW1hcnlcIixcbiAgXCJleGVjXCIsXG4gIFwiZmV0Y2hcIixcbiAgXCJnZXRSZW1vdGVzXCIsXG4gIFwiaW5pdFwiLFxuICBcImxpc3RDb25maWdcIixcbiAgXCJsaXN0UmVtb3RlXCIsXG4gIFwibG9nXCIsXG4gIFwibWVyZ2VcIixcbiAgXCJtZXJnZUZyb21Ub1wiLFxuICBcIm1pcnJvclwiLFxuICBcIm12XCIsXG4gIFwicHVsbFwiLFxuICBcInB1c2hcIixcbiAgXCJwdXNoVGFnc1wiLFxuICBcInJhd1wiLFxuICBcInJlYmFzZVwiLFxuICBcInJlbW90ZVwiLFxuICBcInJlbW92ZVJlbW90ZVwiLFxuICBcInJlc2V0XCIsXG4gIFwicmV2ZXJ0XCIsXG4gIFwicmV2cGFyc2VcIixcbiAgXCJybVwiLFxuICBcInJtS2VlcExvY2FsXCIsXG4gIFwic2hvd1wiLFxuICBcInN0YXNoXCIsXG4gIFwic3Rhc2hMaXN0XCIsXG4gIFwic3RhdHVzXCIsXG4gIFwic3ViTW9kdWxlXCIsXG4gIFwic3VibW9kdWxlQWRkXCIsXG4gIFwic3VibW9kdWxlSW5pdFwiLFxuICBcInN1Ym1vZHVsZVVwZGF0ZVwiLFxuICBcInRhZ1wiLFxuICBcInRhZ3NcIixcbiAgXCJ1cGRhdGVTZXJ2ZXJJbmZvXCJcbl07XG5mdW5jdGlvbiBnaXRQKC4uLmFyZ3MpIHtcbiAgbGV0IGdpdDtcbiAgbGV0IGNoYWluID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHRyeSB7XG4gICAgZ2l0ID0gZ2l0SW5zdGFuY2VGYWN0b3J5KC4uLmFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2hhaW4gPSBQcm9taXNlLnJlamVjdChlKTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZGVyUmV0dXJuKCkge1xuICAgIHJldHVybiBwcm9taXNlQXBpO1xuICB9XG4gIGZ1bmN0aW9uIGNoYWluUmV0dXJuKCkge1xuICAgIHJldHVybiBjaGFpbjtcbiAgfVxuICBjb25zdCBwcm9taXNlQXBpID0gWy4uLmZ1bmN0aW9uTmFtZXNCdWlsZGVyQXBpLCAuLi5mdW5jdGlvbk5hbWVzUHJvbWlzZUFwaV0ucmVkdWNlKFxuICAgIChhcGksIG5hbWUpID0+IHtcbiAgICAgIGNvbnN0IGlzQXN5bmMgPSBmdW5jdGlvbk5hbWVzUHJvbWlzZUFwaS5pbmNsdWRlcyhuYW1lKTtcbiAgICAgIGNvbnN0IHZhbGlkID0gaXNBc3luYyA/IGFzeW5jV3JhcHBlcihuYW1lLCBnaXQpIDogc3luY1dyYXBwZXIobmFtZSwgZ2l0LCBhcGkpO1xuICAgICAgY29uc3QgYWx0ZXJuYXRpdmUgPSBpc0FzeW5jID8gY2hhaW5SZXR1cm4gOiBidWlsZGVyUmV0dXJuO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwaSwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IGdpdCA/IHZhbGlkIDogYWx0ZXJuYXRpdmVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFwaTtcbiAgICB9LFxuICAgIHt9XG4gICk7XG4gIHJldHVybiBwcm9taXNlQXBpO1xuICBmdW5jdGlvbiBhc3luY1dyYXBwZXIoZm4sIGdpdDIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJnczIpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJnczJbYXJnczIubGVuZ3RoXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJQcm9taXNlIGludGVyZmFjZSByZXF1aXJlcyB0aGF0IGhhbmRsZXJzIGFyZSBub3Qgc3VwcGxpZWQgaW5saW5lLCB0cmFpbGluZyBmdW5jdGlvbiBub3QgYWxsb3dlZCBpbiBjYWxsIHRvIFwiICsgZm5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGFpbi50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCh0b0Vycm9yKGVycikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgYXJnczIucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgZ2l0Mltmbl0uYXBwbHkoZ2l0MiwgYXJnczIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gc3luY1dyYXBwZXIoZm4sIGdpdDIsIGFwaSkge1xuICAgIHJldHVybiAoLi4uYXJnczIpID0+IHtcbiAgICAgIGdpdDJbZm5dKC4uLmFyZ3MyKTtcbiAgICAgIHJldHVybiBhcGk7XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gdG9FcnJvcihlcnJvcikge1xuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihlcnJvcik7XG4gIH1cbiAgcmV0dXJuIG5ldyBHaXRSZXNwb25zZUVycm9yKGVycm9yKTtcbn1cblxuLy8gc3JjL2VzbS5tanNcbnZhciBzaW1wbGVHaXQgPSBnaXRJbnN0YW5jZUZhY3Rvcnk7XG52YXIgZXNtX2RlZmF1bHQgPSBnaXRJbnN0YW5jZUZhY3Rvcnk7XG5leHBvcnQge1xuICBDaGVja1JlcG9BY3Rpb25zLFxuICBDbGVhbk9wdGlvbnMsXG4gIERpZmZOYW1lU3RhdHVzLFxuICBHaXRDb25maWdTY29wZSxcbiAgR2l0Q29uc3RydWN0RXJyb3IsXG4gIEdpdEVycm9yLFxuICBHaXRQbHVnaW5FcnJvcixcbiAgR2l0UmVzcG9uc2VFcnJvcixcbiAgUmVzZXRNb2RlLFxuICBUYXNrQ29uZmlndXJhdGlvbkVycm9yLFxuICBlc21fZGVmYXVsdCBhcyBkZWZhdWx0LFxuICBnaXRQLFxuICBncmVwUXVlcnlCdWlsZGVyLFxuICBwYXRoc3BlYyxcbiAgc2ltcGxlR2l0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/simple-git/dist/esm/index.js\n");

/***/ })

};
;